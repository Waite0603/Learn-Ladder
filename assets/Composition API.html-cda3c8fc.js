const t=JSON.parse('{"key":"v-c2dc457e","path":"/web/vue/learn/essential/Composition%20API.html","title":"Composition API","lang":"zh-CN","frontmatter":{"title":"Composition API","icon":"post","order":null,"date":"2023-12-16T00:00:00.000Z","description":"[TOC] Options API的弊端 在Vue2中，我们编写组件的方式是Options API： Options API的一大特点就是在对应的属性中编写对应的功能模块； 比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子； 但是这种代码有一个很大的弊端： 当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中； 当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散； 尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）； 下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分： 这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题； 并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中；","head":[["meta",{"property":"og:url","content":"https://brain.sunguoqi.com/web/vue/learn/essential/Composition%20API.html"}],["meta",{"property":"og:site_name","content":"Waite Wang"}],["meta",{"property":"og:title","content":"Composition API"}],["meta",{"property":"og:description","content":"[TOC] Options API的弊端 在Vue2中，我们编写组件的方式是Options API： Options API的一大特点就是在对应的属性中编写对应的功能模块； 比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子； 但是这种代码有一个很大的弊端： 当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中； 当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散； 尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）； 下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分： 这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题； 并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中；"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-16T15:19:30.000Z"}],["meta",{"property":"article:published_time","content":"2023-12-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-16T15:19:30.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Composition API\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-12-16T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-16T15:19:30.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Options API的弊端","slug":"options-api的弊端","link":"#options-api的弊端","children":[]},{"level":2,"title":"认识 组合式 API (Composition API)","slug":"认识-组合式-api-composition-api","link":"#认识-组合式-api-composition-api","children":[]},{"level":2,"title":"setup()","slug":"setup","link":"#setup","children":[{"level":3,"title":"setup函数的参数","slug":"setup函数的参数","link":"#setup函数的参数","children":[]},{"level":3,"title":"setup函数的返回值","slug":"setup函数的返回值","link":"#setup函数的返回值","children":[]},{"level":3,"title":"补充: 为什么 setup 不能使用 this","slug":"补充-为什么-setup-不能使用-this","link":"#补充-为什么-setup-不能使用-this","children":[]}]},{"level":2,"title":"","slug":"","link":"#","children":[]}],"git":{"createdTime":1702739970000,"updatedTime":1702739970000,"contributors":[{"name":"Waite Wang","email":"waite@waite.wang","commits":1}]},"readingTime":{"minutes":7.92,"words":2376},"filePathRelative":"web/vue/learn/essential/Composition API.md","localizedDate":"2023年12月16日","excerpt":"<p>[TOC]</p>\\n<h2> Options API的弊端</h2>\\n<ul>\\n<li>\\n<p>在Vue2中，我们编写组件的方式是Options API：</p>\\n<ul>\\n<li>Options API的一大特点就是在对应的属性中编写对应的功能模块；</li>\\n<li>比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子；</li>\\n</ul>\\n</li>\\n<li>\\n<p>但是这种代码有一个很大的弊端：</p>\\n<ul>\\n<li>当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中；</li>\\n<li>当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散；</li>\\n<li>尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）；</li>\\n</ul>\\n</li>\\n<li>\\n<p>下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分：</p>\\n<ul>\\n<li>这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题；</li>\\n<li>并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中；</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{t as data};
