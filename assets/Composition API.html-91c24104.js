const e=JSON.parse('{"key":"v-c2dc457e","path":"/web/vue/learn/essential/Composition%20API.html","title":"Composition API","lang":"zh-CN","frontmatter":{"title":"Composition API","icon":"post","order":null,"date":"2023-12-16T00:00:00.000Z","description":"Options API的弊端 在Vue2中，我们编写组件的方式是Options API： Options API的一大特点就是在对应的属性中编写对应的功能模块； 比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子； 但是这种代码有一个很大的弊端： 当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中； 当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散； 尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）； 下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分： 这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题； 并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中；","head":[["meta",{"property":"og:url","content":"https://brain.sunguoqi.com/web/vue/learn/essential/Composition%20API.html"}],["meta",{"property":"og:site_name","content":"Waite Wang"}],["meta",{"property":"og:title","content":"Composition API"}],["meta",{"property":"og:description","content":"Options API的弊端 在Vue2中，我们编写组件的方式是Options API： Options API的一大特点就是在对应的属性中编写对应的功能模块； 比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子； 但是这种代码有一个很大的弊端： 当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中； 当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散； 尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）； 下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分： 这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题； 并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中；"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-18T16:29:12.000Z"}],["meta",{"property":"article:published_time","content":"2023-12-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-18T16:29:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Composition API\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-12-16T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-18T16:29:12.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Options API的弊端","slug":"options-api的弊端","link":"#options-api的弊端","children":[]},{"level":2,"title":"认识 组合式 API (Composition API)","slug":"认识-组合式-api-composition-api","link":"#认识-组合式-api-composition-api","children":[]},{"level":2,"title":"setup()","slug":"setup","link":"#setup","children":[{"level":3,"title":"setup函数的参数","slug":"setup函数的参数","link":"#setup函数的参数","children":[]},{"level":3,"title":"setup函数的返回值","slug":"setup函数的返回值","link":"#setup函数的返回值","children":[]},{"level":3,"title":"补充: 为什么 setup 不能使用 this","slug":"补充-为什么-setup-不能使用-this","link":"#补充-为什么-setup-不能使用-this","children":[]}]},{"level":2,"title":"定义响应式数据的两种方式","slug":"定义响应式数据的两种方式","link":"#定义响应式数据的两种方式","children":[{"level":3,"title":"Reactive API","slug":"reactive-api","link":"#reactive-api","children":[]},{"level":3,"title":"Ref API","slug":"ref-api","link":"#ref-api","children":[]}]},{"level":2,"title":"readonly","slug":"readonly","link":"#readonly","children":[{"level":3,"title":"概念","slug":"概念","link":"#概念","children":[]}]},{"level":2,"title":"toRefs && toRef","slug":"torefs-toref","link":"#torefs-toref","children":[{"level":3,"title":"toRefs","slug":"torefs","link":"#torefs","children":[]},{"level":3,"title":"toRef","slug":"toref","link":"#toref","children":[]}]},{"level":2,"title":"computed","slug":"computed","link":"#computed","children":[{"level":3,"title":"方式一","slug":"方式一","link":"#方式一","children":[]},{"level":3,"title":"方式二","slug":"方式二","link":"#方式二","children":[]}]},{"level":2,"title":"生命周期钩子","slug":"生命周期钩子","link":"#生命周期钩子","children":[]},{"level":2,"title":"setup中使用ref获取元素或组件","slug":"setup中使用ref获取元素或组件","link":"#setup中使用ref获取元素或组件","children":[{"level":3,"title":"获取元素","slug":"获取元素","link":"#获取元素","children":[]},{"level":3,"title":"获取组件","slug":"获取组件","link":"#获取组件","children":[]}]},{"level":2,"title":"侦听数据的变化","slug":"侦听数据的变化","link":"#侦听数据的变化","children":[{"level":3,"title":"watchEffect","slug":"watcheffect","link":"#watcheffect","children":[]},{"level":3,"title":"Watch","slug":"watch","link":"#watch","children":[]}]},{"level":2,"title":"provide && inject","slug":"provide-inject","link":"#provide-inject","children":[]},{"level":2,"title":"h函数","slug":"h函数","link":"#h函数","children":[{"level":3,"title":"参数","slug":"参数","link":"#参数","children":[]},{"level":3,"title":"基本使用","slug":"基本使用-2","link":"#基本使用-2","children":[]},{"level":3,"title":"函数组件和插槽的使用","slug":"函数组件和插槽的使用","link":"#函数组件和插槽的使用","children":[]}]},{"level":2,"title":"Jsx","slug":"jsx","link":"#jsx","children":[{"level":3,"title":"配置","slug":"配置","link":"#配置","children":[]},{"level":3,"title":"基本使用","slug":"基本使用-3","link":"#基本使用-3","children":[]}]},{"level":2,"title":"script setup语法糖","slug":"script-setup语法糖","link":"#script-setup语法糖","children":[{"level":3,"title":"顶层的绑定会被暴露给模板","slug":"顶层的绑定会被暴露给模板","link":"#顶层的绑定会被暴露给模板","children":[]},{"level":3,"title":"defineProps()","slug":"defineprops","link":"#defineprops","children":[]},{"level":3,"title":"defineEmits()","slug":"defineemits","link":"#defineemits","children":[]},{"level":3,"title":"defineExpose()","slug":"defineexpose","link":"#defineexpose","children":[]}]},{"level":2,"title":"自定义组件","slug":"自定义组件","link":"#自定义组件","children":[{"level":3,"title":"指令的生命周期","slug":"指令的生命周期","link":"#指令的生命周期","children":[]},{"level":3,"title":"指令钩子","slug":"指令钩子","link":"#指令钩子","children":[]},{"level":3,"title":"简单使用","slug":"简单使用","link":"#简单使用","children":[]}]},{"level":2,"title":"内置组件","slug":"内置组件","link":"#内置组件","children":[{"level":3,"title":"Teleport","slug":"teleport","link":"#teleport","children":[]},{"level":3,"title":"其他","slug":"其他","link":"#其他","children":[]}]},{"level":2,"title":"Vue插件","slug":"vue插件","link":"#vue插件","children":[{"level":3,"title":"对象类型","slug":"对象类型","link":"#对象类型","children":[]},{"level":3,"title":"函数类型","slug":"函数类型","link":"#函数类型","children":[]},{"level":3,"title":"改写自定义指令","slug":"改写自定义指令","link":"#改写自定义指令","children":[]}]}],"git":{"createdTime":1702739970000,"updatedTime":1702916952000,"contributors":[{"name":"Waite Wang","email":"waite@waite.wang","commits":3}]},"readingTime":{"minutes":40.97,"words":12291},"filePathRelative":"web/vue/learn/essential/Composition API.md","localizedDate":"2023年12月16日","excerpt":"<h2> Options API的弊端</h2>\\n<ul>\\n<li>\\n<p>在Vue2中，我们编写组件的方式是Options API：</p>\\n<ul>\\n<li>Options API的一大特点就是在对应的属性中编写对应的功能模块；</li>\\n<li>比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子；</li>\\n</ul>\\n</li>\\n<li>\\n<p>但是这种代码有一个很大的弊端：</p>\\n<ul>\\n<li>当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中；</li>\\n<li>当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散；</li>\\n<li>尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）；</li>\\n</ul>\\n</li>\\n<li>\\n<p>下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分：</p>\\n<ul>\\n<li>这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题；</li>\\n<li>并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中；</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
