<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://brain.sunguoqi.com/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://brain.sunguoqi.com/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Waite Wang</title>
    <link>https://brain.sunguoqi.com/</link>
    <description>热爱可抵漫长岁月！</description>
    <language>zh-CN</language>
    <pubDate>Tue, 31 Oct 2023 13:40:04 GMT</pubDate>
    <lastBuildDate>Tue, 31 Oct 2023 13:40:04 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <item>
      <title>认识组件化开发</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/components/%E8%AE%A4%E8%AF%86%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/components/%E8%AE%A4%E8%AF%86%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">认识组件化开发</source>
      <description>认识组件化开发 人面对复杂问题的处理方式： 任何一个人处理信息的逻辑能力都是有限的 所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。 但是，我们人有一种天生的能力，就是将问题进行拆解。 如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，你会发现大的问题也会迎刃而解。 组件化也是类似的思想： 如果我们将一个页面中所有的处理逻辑 全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展； 但如果，我们讲一个页面拆分成一个个 小的功能块，每个功能块完成属于自己 这部分独立的功能，那么之后整个页面 的管理和维护就变得非常容易了； 如果我们将一个个功能块拆分后，就可 以像搭建积木一下来搭建我们的项目； 现在可以说整个的大前端开发都是组件化的天下，无论从三大框架（Vue、React、Angular），还是跨平台方案 的Flutter，甚至是移动端都在转向组件化开发，包括小程序的开发也是采用组件化开发的思想 所以，学习组件化最重要的是它的思想，每个框架或者平台可能实现方法不同，但是思想都是一样的。 我们需要通过组件化的思想来思考整个应用程序： 我们将一个完整的页面分成很多个组件； 每个组件都用于实现页面的一个功能块； 而每一个组件又可以进行细分； 而组件本身又可以在多个地方进行复用；</description>
      <pubDate>Tue, 31 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 认识组件化开发</h2>
<ul>
<li>人面对复杂问题的处理方式：
<ul>
<li>任何一个人处理信息的逻辑能力都是有限的</li>
<li>所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。</li>
<li>但是，我们人有一种天生的能力，就是将问题进行拆解。</li>
<li>如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，你会发现大的问题也会迎刃而解。</li>
</ul>
</li>
<li>组件化也是类似的思想：
<ul>
<li>如果我们将一个页面中所有的处理逻辑 全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展；</li>
<li>但如果，我们讲一个页面拆分成一个个 小的功能块，每个功能块完成属于自己 这部分独立的功能，那么之后整个页面 的管理和维护就变得非常容易了；</li>
<li>如果我们将一个个功能块拆分后，就可 以像搭建积木一下来搭建我们的项目；</li>
</ul>
</li>
<li>现在可以说整个的大前端开发都是组件化的天下，无论从三大框架（Vue、React、Angular），还是跨平台方案 的Flutter，甚至是移动端都在转向组件化开发，包括小程序的开发也是采用组件化开发的思想</li>
<li>所以，学习组件化最重要的是它的思想，每个框架或者平台可能实现方法不同，但是思想都是一样的。</li>
<li>我们需要通过组件化的思想来思考整个应用程序：
<ul>
<li>我们将一个完整的页面分成很多个组件；</li>
<li>每个组件都用于实现页面的一个功能块；</li>
<li>而每一个组件又可以进行细分；</li>
<li>而组件本身又可以在多个地方进行复用；</li>
</ul>
</li>
</ul>
<h2> Vue的组件化</h2>
<ul>
<li>vue 项目起始文件 <code>createApp</code> 函数传入了一个对象App，这个对象其实本质上就是一个组件，也是我们应用程序的根 组件；</li>
<li>组件化提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用；</li>
<li>任何的应用都会被抽象成一颗组件树；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310312042389.png" alt="image-20231031204213497" tabindex="0" loading="lazy"><figcaption>image-20231031204213497</figcaption></figure>
<h2> 组件名称</h2>
<ul>
<li>在通过 <code>app.componen</code> t注册一个组件的时候，第一个参数是组件的名称，定义组件名的方式有两种：</li>
<li>方式一：使用 kebab-case（短横线分割符）
<ul>
<li>当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case， 例如 <code>&lt;my-component-name&gt;</code>;</li>
</ul>
</li>
<li>方式二：使用 PascalCase（驼峰标识符）
<ul>
<li>当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也 就是说  <code>&lt;my-component-name&gt;</code>和 <code>MyComponentName</code>  都是可接受的；</li>
</ul>
</li>
<li>在单文件组件和内联字符串模板中，我们都推荐这样做。但是，PascalCase 的标签名在 DOM 模板中是不可用的，详情参见 <a href="https://cn.vuejs.org/guide/essentials/component-basics.html#in-dom-template-parsing-caveats" target="_blank" rel="noopener noreferrer">DOM 内模板解析注意事项</a>。</li>
<li>为了方便，Vue 支持将模板中使用 kebab-case 的标签解析为使用 PascalCase 注册的组件。这意味着一个以 <code>MyComponent</code> 为名注册的组件，在模板中可以通过 <code>&lt;MyComponent&gt;</code> 或 <code>&lt;my-component&gt;</code> 引用。这让我们能够使用同样的 JavaScript 组件注册代码来配合不同来源的模板。</li>
</ul>
<h2> 注册组件的方式</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/components/registration.html#component-registration</p>
</blockquote>
<ul>
<li>如果我们现在有一部分内容（模板、逻辑等），我们希望将这部分内容抽取到一个独立的组件中去维护，这个时候 如何注册一个组件呢？</li>
<li>我们先从简单的开始谈起，比如下面的模板希望抽离到一个单独的组件：</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>注册组件分成两种：
<ul>
<li>全局组件：在任何其他的组件中都可以使用的组件；</li>
<li>局部组件：只有在注册的组件中才能使用的组件；</li>
</ul>
</li>
</ul>
<h3> 注册全局组件</h3>
<ul>
<li>全局组件需要使用我们全局创建的app来注册组件；</li>
<li>通过component方法传入组件名称、组件对象即可注册一个全局组件了；</li>
<li>之后，我们可以在App组件的template中直接使用这个全局组件：</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>也可以</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 注册局部组件</h3>
<p>全局注册虽然很方便，但有以下几个问题：</p>
<ol>
<li>全局注册，但并没有被使用的组件无法在生产打包时被自动移除 (也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。</li>
<li>全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。</li>
</ol>
<p>相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。</p>
<p>局部注册需要使用 <code>components</code> 选项：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于每个 <code>components</code> 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>请注意：<strong>局部注册的组件在后代组件中并不可用</strong>。在这个例子中，<code>ComponentA</code> 注册后仅在当前组件可用，而在任何的子组件或更深层的子组件中都不可用。</p>
</blockquote>
<ul>
<li>全局组件往往是在应用程序一开始就会全局组件完成，那么就意味着如果某些组件我们并没有用到，也会一起被注 册：
<ul>
<li>比如我们注册了三个全局组件：ComponentA、ComponentB、ComponentC；</li>
<li>在开发中我们只使用了ComponentA、ComponentB，如果ComponentC没有用到但是我们依然在全局进行 了注册，那么就意味着类似于webpack这种打包工具在打包我们的项目时，我们依然会对其进行打包；</li>
<li>这样最终打包出的JavaScript包就会有关于ComponentC的内容，用户在下载对应的JavaScript时也会增加包 的大小；</li>
</ul>
</li>
<li>所以在开发中我们通常使用组件的时候采用的都是局部注册：
<ul>
<li>局部注册是在我们需要使用到的组件中，通过components属性选项来进行注册；</li>
<li>比如之前的App组件中，我们有data、computed、methods等选项了，事实上还可以有一个components选项；</li>
<li>该components选项对应的是一个对象，对象中的键值对是 组件的名称: 组件对象；</li>
</ul>
</li>
</ul>
<h2> Vue的开发模式</h2>
<ul>
<li>目前我们使用vue的过程都是在html文件中，通过template编写自己的模板、脚本逻辑、样式等。</li>
<li>但是随着项目越来越复杂，我们会采用组件化的方式来进行开发：
<ul>
<li>这就意味着每个组件都会有自己的模板、脚本逻辑、样式等；</li>
<li>当然我们依然可以把它们抽离到单独的js、css文件中，但是它们还是会分离开来；</li>
<li>也包括我们的script是在一个全局的作用域下，很容易出现命名冲突的问题；</li>
<li>并且我们的代码为了适配一些浏览器，必须使用ES5的语法；</li>
<li>在我们编写代码完成之后，依然需要通过工具对代码进行构建、代码；</li>
</ul>
</li>
<li>所以在真实开发中，我们可以通过一个后缀名为 .vue 的single-file components (单文件组件) 来解决，并且可以使用 webpack 或者 vite 或者 rollup 等构建工具来对其进行处理。</li>
</ul>
<blockquote>
<p>比如: 我们可以单独抽离组件 componentA</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>在这个组件中我们可以获得非常多的特性：</p>
<ul>
<li>代码的高亮；</li>
<li>ES6、CommonJS的模块化能力；</li>
<li>组件作用域的CSS；</li>
<li>可以使用预处理器来构建更加丰富的组件，比如TypeScript、Babel、Less、Sass等；</li>
</ul>
</blockquote>
<h2> 如何支持SFC</h2>
<ul>
<li>如果我们想要使用这一 componentA.vue 文件，比较常见的是两种方式：
<ul>
<li>方式一：使用Vue CLI来创建项目，项目会默认帮助我们配置好所有的配置选项，可以在其中直接使用.vue文件；</li>
<li>方式二：自己使用webpack或rollup或 vite 这类打包工具，对其进行打包处理；</li>
</ul>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310312042389.png" type="image/png"/>
    </item>
    <item>
      <title>Js 的浅拷贝与深拷贝</title>
      <link>https://brain.sunguoqi.com/web/js/Js%20%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D.html</link>
      <guid>https://brain.sunguoqi.com/web/js/Js%20%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Js 的浅拷贝与深拷贝</source>
      <description>数据类型 在探讨深浅拷贝之前，我们先梳理一下js中的数据类型，js的数据类型分为两类：基本数据类型和引用数据类型 前者是存储在栈内存中，后者是将其地址存在栈内存中，而真实数据存储在堆内存中。 如下图所示，基本类型如number、string、boolean、Null和 undefined 等存储在栈内存中，而引用数据类型如 Array、Object 和函数等则是分别存储数据1的地址、数据2的地址和数据3的地址。</description>
      <pubDate>Mon, 30 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 数据类型</h2>
<ol>
<li>在探讨深浅拷贝之前，我们先梳理一下js中的数据类型，js的数据类型分为两类：基本数据类型和引用数据类型</li>
<li>前者是存储在栈内存中，后者是将其地址存在栈内存中，而真实数据存储在堆内存中。</li>
<li>如下图所示，基本类型如number、string、boolean、Null和 undefined 等存储在栈内存中，而引用数据类型如 Array、Object 和函数等则是分别存储数据1的地址、数据2的地址和数据3的地址。</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202310301908367.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 深浅拷贝</h2>
<blockquote>
<p>js中的基本数据类型：<code>String Number Boolean Null Undefined</code>，在赋值的过程中都是深拷贝。</p>
<p>例如，let a = 10 ; b = a , 修改其中一个变量的值，不会影响到另一个变量的值。</p>
</blockquote>
<h3> 概念</h3>
<ol>
<li>浅拷贝：会在栈中开辟另一块空间，并将被拷贝对象的栈内存数据完全拷贝到该块空间中，即基本数据类型的值会被完全拷贝，而引用类型的值则是拷贝了“指向堆内存的地址”。因此，当修改其中一个变量的值时，会影响到另一个变量的值。</li>
<li>深拷贝：不仅会在栈中开辟另一块空间，若被拷贝对象中有引用类型，则还会在堆内存中开辟另一块空间存储引用类型的真实数据。因此，当修改其中一个变量的值时，不会影响到另一个变量的值。</li>
</ol>
<blockquote>
<p>两者示意图如下：</p>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202310301911328.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址</p>
<p>深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址</p>
</blockquote>
<h2> Js 中的深浅拷贝</h2>
<h3> 浅拷贝</h3>
<blockquote>
<p>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p>
<p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址</p>
</blockquote>
<h4> 手写递归</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 展开语法</h4>
<blockquote>
<p>展开语法(spread syntax)允许一个表达式在期望多个参数(用于函数调用)或多个元素(用于数组字面量)或多个变量(用于解构赋值)的位置扩展。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Object.assign()</h4>
<blockquote>
<p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> slice()</h4>
<blockquote>
<p>slice() 方法可从已有的数组中返回选定的元素。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> concat()</h4>
<blockquote>
<p>concat() 方法用于连接两个或多个数组。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310301917518.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 深拷贝</h3>
<blockquote>
<p>深拷贝开辟一个新的栈，两个对象属性完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p>
</blockquote>
<h4> 手写递归</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Object.entries(obj) 遍历对象</h4>
<blockquote>
<p>Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组</p>
<p>比如：Object.entries({ foo: 'bar', baz: 42 }); // [ ['foo', 'bar'], ['baz', 42] ]</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> JSON.parse(JSON.stringify(待拷贝对象) -&gt; 常用</h4>
<blockquote>
<p>JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串。</p>
<p>比如: JSON.stringify({ x: 5, y: 6 }); // "{"x":5,"y":6}" -&gt; string</p>
<p>JSON.parse() 方法用于将一个 JSON 字符串转换为对象。</p>
<p>比如: JSON.parse('{"name":"cxk","age":18}'); // {name: "cxk", age: 18} -&gt; object</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 其他方法</h4>
<ul>
<li>_.cloneDeep()</li>
<li>jQuery.extend()</li>
<li>手写循环递归</li>
</ul>
<h2> Vue 中的深拷贝实现</h2>
<blockquote>
<p>引入loadsh,提供 cloneDeep 实现深拷贝</p>
</blockquote>
<ol>
<li>安装loadsh    npm i --save lodash</li>
<li>引入loadsh    import _ from 'lodash'</li>
<li>直接调用 loadsh 库的方法 <code>const newObj = _.cloneDeep(this.obj)</code></li>
</ol>
<blockquote>
<p>_clone 实现浅拷贝</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310301908367.png" type="image/png"/>
    </item>
    <item>
      <title>Vue3 基本指令</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/Vue3%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/Vue3%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Vue3 基本指令</source>
      <description>VSCode 代码片段 我们在前面练习Vue的过程中，有些代码片段是需要经常写的，我们再VSCode中我们可以生成一个代码片段，方便我们快速生成。 VSCode中的代码片段有固定的格式，所以我们一般会借助于一个在线工具来完成。 具体的步骤如下： 第一步，复制自己需要生成代码片段的代码； 第二步，https://snippet-generator.app/在该网站中生成代码片段； 第三步，在VSCode中配置代码片段； 直接 Tab trigger 即可自动填充</description>
      <pubDate>Thu, 07 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> VSCode 代码片段</h2>
<ul>
<li>我们在前面练习Vue的过程中，有些代码片段是需要经常写的，我们再VSCode中我们可以生成一个代码片段，方便我们快速生成。</li>
<li>VSCode中的代码片段有固定的格式，所以我们一般会借助于一个在线工具来完成。</li>
<li>具体的步骤如下：
<ul>
<li>第一步，复制自己需要生成代码片段的代码；</li>
<li>第二步，https://snippet-generator.app/在该网站中生成代码片段；</li>
<li>第三步，在VSCode中配置代码片段；</li>
</ul>
</li>
<li>直接 Tab trigger 即可自动填充</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310162330091.png" alt="image-20231016233051010" tabindex="0" loading="lazy"><figcaption>image-20231016233051010</figcaption></figure>
<h2> 模板语法</h2>
<ul>
<li>React的开发模式[了解]
<ul>
<li>React使用的jsx,所以对应的代码都是编写的类似于js的一种语法</li>
<li>之后通过Babe将js编译成 React. create Element函数调用</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>vue也支持 jsx 的开发模式:
<ul>
<li>但是大多数情况下,使用基于HTML的模板语法</li>
<li>在模板中,允许开发者以声明式的方式将 DOM 和底层组件实例的数据绑定在-起;口在底层的实现中,vue将模板编译成虚拟DOM渲染函数</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Mustache 语法 双大括号语法</h2>
<ul>
<li>如果我们希望把数据显示到模板（template）中，使用最多的语法是 “Mustache”语法 (双大括号) 的文本插值。
<ul>
<li>并且我们前端提到过，data返回的对象是有添加到Vue的响应式系统中；</li>
<li>当data中的数据发生改变时，对应的内容也会发生更新。</li>
<li>当然，Mustache中不仅仅可以是data中的属性，也可以是一个JavaScript的表达式。</li>
</ul>
</li>
<li>mustache的使用
1. 基本使用
2. 表达式
3. 函数
4. 三元运算符</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>以下为错误写法</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 不常用指令</h2>
<h3> v-once指令</h3>
<ul>
<li>
<p>v-once用于指定元素或者组件只渲染一次</p>
<ul>
<li>
<p>当数据发生变化时,元素或者组件以及其所有的子元素将视为静态内容并且跳过;</p>
</li>
<li>
<p>该指令可以用于性能优化;</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p>如果是子节点的化，也只能渲染一次</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<blockquote>
<p>完整代码</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-html</h3>
<ul>
<li>默认情况下，如果我们展示的内容本身是 html 的，那么vue并不会对其进行特殊的解析。
<ul>
<li>如果我们希望这个内容被Vue可以解析出来，那么可以使用 v-html 来展示</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310180836759.png" alt="image-20231018083558572" tabindex="0" loading="lazy"><figcaption>image-20231018083558572</figcaption></figure>
<h3> v-text</h3>
<ul>
<li>用于更新元素的 textContent</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-pre</h3>
<ul>
<li>v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签：
<ul>
<li>跳过不需要编译的节点，加快编译的速度</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-cloak</h3>
<ul>
<li>用于隐藏尚未完成编译的 DOM 模板。
<ul>
<li><strong>无需传入</strong></li>
<li><strong>详细信息</strong></li>
</ul>
</li>
<li><strong>该指令只在没有构建步骤的环境下需要使用。</strong>
<ul>
<li>当使用直接在 DOM 中书写的模板时，可能会出现一种叫做“未编译模板闪现”的情况：用户可能先看到的是还没编译完成的双大括号标签，直到挂载的组件将它们替换为实际渲染的内容。</li>
<li><code>v-cloak</code> 会保留在所绑定的元素上，直到相关组件实例被挂载后才移除。配合像 <code>[v-cloak] { display: none }</code> 这样的 CSS 规则，它可以在组件编译完毕前隐藏原始模板。</li>
</ul>
</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>直到编译完成前，<code>&lt;div&gt;</code> 将不可见。</p>
</blockquote>
<h2> v-bind</h2>
<p>动态的绑定一个或多个 attribute，也可以是组件的 prop。</p>
<ul>
<li>
<p><strong>缩写：</strong><code>:</code> 或者 <code>.</code> (当使用 <code>.prop</code> 修饰符)</p>
</li>
<li>
<p><strong>期望：</strong><code>any (带参数) | Object (不带参数)</code></p>
</li>
<li>
<p><strong>参数：</strong><code>attrOrProp (可选的)</code></p>
</li>
<li>
<p><strong>修饰符</strong></p>
<ul>
<li><code>.camel</code> - 将短横线命名的 attribute 转变为驼峰式命名。</li>
<li><code>.prop</code> - 强制绑定为 DOM property。<code>3.2+</code></li>
<li><code>.attr</code> - 强制绑定为 DOM attribute。<code>3.2+</code></li>
</ul>
</li>
<li>
<p><strong>用途</strong></p>
<p>当用于绑定 <code>class</code> 或 <code>style</code> attribute，<code>v-bind</code> 支持额外的值类型如数组或对象。详见下方的指南链接。</p>
<p>在处理绑定时，Vue 默认会利用 <code>in</code> 操作符来检查该元素上是否定义了和绑定的 key 同名的 DOM property。如果存在同名的 property，则 Vue 会将它作为 DOM property 赋值，而不是作为 attribute 设置。这个行为在大多数情况都符合期望的绑定值类型，但是你也可以显式用 <code>.prop</code> 和 <code>.attr</code> 修饰符来强制绑定方式。有时这是必要的，特别是在和<a href="https://cn.vuejs.org/guide/extras/web-components.html#passing-dom-properties" target="_blank" rel="noopener noreferrer">自定义元素</a>打交道时。</p>
<p>当用于组件 props 绑定时，所绑定的 props 必须在子组件中已被正确声明。</p>
<p>当不带参数使用时，可以用于绑定一个包含了多个 attribute 名称-绑定值对的对象。</p>
</li>
<li>
<p><strong>用法</strong></p>
<ul>
<li>动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</li>
</ul>
</li>
</ul>
<blockquote>
<p>小知识: vue3 是允许template中有多个根元素</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 基本使用</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 绑定 class</h3>
<ul>
<li>在开发中,有时候我们的元素 class也是动态的,比如
<ul>
<li>当数据为某个状态时,字体显示红色。</li>
<li>当数据另一个状态时,字体显示黑色</li>
</ul>
</li>
<li>绑定class有两种方式：
<ul>
<li>对象语法</li>
<li>数组语法</li>
</ul>
</li>
</ul>
<h4> 对象语法</h4>
<ul>
<li>对象语法：我们可以传给 :class (v-bind:class 的简写) 一个对象，以动态地切换 class</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 数组语法</h4>
<ul>
<li>绑定class – 数组语法
<ul>
<li>数组语法：我们可以把一个数组传给 :class，以应用一个 class 列表</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 绑定 style</h3>
<ul>
<li>我们可以利用 <code>v-bind:style</code> 来绑定一些CSS内联样式
<ul>
<li>这次因为某些样式我们需要根据数据动态来决定</li>
<li>比如某段文字的颜色，大小等等</li>
</ul>
</li>
<li>CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名</li>
<li>绑定class有两种方式
<ul>
<li>对象语法</li>
<li>数组语法</li>
</ul>
</li>
</ul>
<blockquote>
<p>CSS property 名短横线分隔 (kebab-case，记得用引号括起来)</p>
</blockquote>
<h4> 对象语法</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 数组语法</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 动态绑定属性</h3>
<ul>
<li>在某些情况下，我们属性的名称可能也不是固定的
<ul>
<li>前端我们无论绑定src、href、class、style，属性名称都是固定的</li>
<li>如果属性名称不是固定的，我们可以使用 :[属性名]=“值” 的格式来定义</li>
<li>这种绑定的方式，我们称之为 <code>动态绑定属性</code>；如下:</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 属性直接绑定一个对象</h3>
<ul>
<li>如果我们希望将一个对象的所有属性，绑定到元素上的所有属性，应该怎么做呢？
<ul>
<li>非常简单，我们可以直接使用 v-bind 绑定一个 对象</li>
</ul>
</li>
<li>案例：info对象会被拆解成div的各个属性</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> v-on</h2>
<ul>
<li>
<p>v-on绑定事件</p>
<ul>
<li>前面我们绑定了元素的内容和属性，在前端开发中另外一个非常重要的特性就是交互。</li>
<li>在前端开发中，我们需要经常和用户进行各种各样的交互
<ul>
<li>这个时候，我们就必须监听用户发生的事件，比如点击、拖拽、键盘事件等等</li>
<li>在Vue中如何监听事件呢？使用v-on指令。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>v-on的用法</p>
<ul>
<li>缩写：@</li>
<li>预期：Function | Inline Statement | Object</li>
<li>参数：event p 修饰符：
<ul>
<li>.stop - 调用 event.stopPropagation()。</li>
<li>.prevent - 调用 event.preventDefault()。</li>
<li>.capture - 添加事件侦听器时使用 capture 模式。</li>
<li>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>
<li>.{keyAlias} - 仅当事件是从特定键触发时才触发回调。</li>
<li>.once - 只触发一次回调。</li>
<li>.left - 只当点击鼠标左键时触发。</li>
<li>.right - 只当点击鼠标右键时触发。</li>
<li>.middle - 只当点击鼠标中键时触发。</li>
<li>.passive - { passive: true } 模式添加侦听器</li>
</ul>
</li>
</ul>
<ul>
<li>用法：绑定事件监听</li>
</ul>
</li>
</ul>
<blockquote>
<p>event 事件可以参考 https://developer.mozilla.org/en-US/docs/Web/Events</p>
</blockquote>
<h3> 基本使用</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 参数传递</h3>
<ul>
<li>当通过methods中定义方法，以供 <code>@click</code>调用时，需要注意参数问题：</li>
<li>情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。
<ul>
<li>但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去</li>
</ul>
</li>
<li>情况二：如果需要同时传入某个参数，同时需要 <code>event</code> 时，可以通过 <code>$event</code> 传入事件。</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310190046946.png" alt="image-20231019004604619" tabindex="0" loading="lazy"><figcaption>image-20231019004604619</figcaption></figure>
<h3> v-on <strong>的修饰符</strong></h3>
<ul>
<li>v-on支持修饰符，修饰符相当于对事件进行了一些特殊的处理：
<ul>
<li>.stop - 调用 event.stopPropagation()。</li>
<li>.prevent - 调用 event.preventDefault()。</li>
<li>.capture - 添加事件侦听器时使用 capture 模式。</li>
<li>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>
<li>.{keyAlias} - 仅当事件是从特定键触发时才触发回调。</li>
<li>.once - 只触发一次回调。</li>
<li>.left - 只当点击鼠标左键时触发。</li>
<li>.right - 只当点击鼠标右键时触发。</li>
<li>.middle - 只当点击鼠标中键时触发。</li>
<li>.passive - { passive: true } 模式添加侦听器</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>stopPropagation</code> 是一个事件修饰符，用于阻止事件冒泡。在 Vue.js 中，当一个元素上的事件被触发时，它会先执行该元素上的事件处理函数，然后再冒泡到该元素的父元素，继续执行父元素的事件处理函数。使用 <code>stopPropagation</code> 可以阻止事件继续冒泡到父元素。在给元素绑定事件时，可以使用 <code>@click.stop</code> 来阻止 <code>click</code> 事件冒泡到父元素。</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310190052768.png" alt="image-20231019005251770" tabindex="0" loading="lazy"><figcaption>image-20231019005251770</figcaption></figure>
<h2> 条件渲染</h2>
<ul>
<li>在某些情况下，我们需要根据当前的条件决定某些元素或组件是否渲染，这个时候我们就需要进行条件判断了。
<ul>
<li>Vue提供了下面的指令来进行条件判断：
<ul>
<li>v-if</li>
<li>v-else</li>
<li>v-else-if</li>
<li>v-show</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3> 基本使用</h3>
<ul>
<li>v-if、v-else、v-else-if用于根据条件来渲染某一块的内容：
<ul>
<li>这些内容只有在条件为true时，才会被渲染出来；</li>
<li>这三个指令与JavaScript的条件语句if、else、else if类似；</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> template 和  v-if  结合使用</h3>
<ul>
<li>v-if的渲染原理：
<ul>
<li>v-if是惰性的；</li>
<li>当条件为false时，其判断的内容完全不会被渲染或者会被销毁掉；</li>
<li>当条件为true时，才会真正渲染条件块中的内容;</li>
</ul>
</li>
<li>template元素
<ul>
<li>因为v-if是一个指令，所以必须将其添加到一个元素上：
<ul>
<li>但是如果我们希望切换的是多个元素呢？</li>
<li>此时我们渲染div，但是我们并不希望div这种元素被渲染；</li>
<li>这个时候，我们可以选择使用template；</li>
</ul>
</li>
<li>template元素可以当做不可见的包裹元素，并且在v-if上使用，但是最终template不会被渲染出来：
<ul>
<li>有点类似于小程序中的block</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-show</h3>
<ul>
<li>v-show和v-if的用法看起来是一致的，也是根据一个条件决定是否显示元素或者组件</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-show和v-if的区别</h3>
<ul>
<li>首先，在用法上的区别：
<ul>
<li>v-show是不支持template；</li>
<li>v-show不可以和v-else一起使用；</li>
</ul>
</li>
<li>其次，本质的区别：
<ul>
<li>v-show元素无论是否需要显示到浏览器上，它的DOM实际都是有渲染的，只是通过CSS的display属性来进行 切换；</li>
<li>v-if当条件为false时，其对应的元素压根不会被渲染到DOM中；</li>
</ul>
</li>
<li>开发中如何进行选择呢？
<ul>
<li>如果我们的元素需要在显示和隐藏之间频繁的切换，那么使用v-show；</li>
<li>如果不会频繁的发生切换，那么使用v-if；</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310192228448.png" alt="image-20231019222841008" tabindex="0" loading="lazy"><figcaption>image-20231019222841008</figcaption></figure>
<h2> 列表渲染</h2>
<ul>
<li>在真实开发中，我们往往会从服务器拿到一组数据，并且需要对其进行渲染。
<ul>
<li>这个时候我们可以使用v-for来完成；</li>
<li>v-for类似于JavaScript的for循环，可以用于遍历一组数据；</li>
</ul>
</li>
</ul>
<h3> 基本使用</h3>
<ul>
<li>
<p>n v-for的基本格式是 "item in 数组"：</p>
<ul>
<li>数组通常是来自data或者prop，也可以是其他方式；</li>
<li>item是我们给每项元素起的一个别名，这个别名可以自定来定义；</li>
</ul>
</li>
<li>
<p>我们知道，在遍历一个数组的时候会经常需要拿到数组的索引：</p>
<ul>
<li>如果我们需要索引，可以使用格式： "(item, index) in 数组"；</li>
<li>注意上面的顺序：数组元素项item是在前面的，索引项index是在后面的；</li>
</ul>
</li>
<li>
<p>v-for支持的类型</p>
<ul>
<li>v-for也支持遍历对象，并且支持有一二三个参数：
<ul>
<li>一个参数： "value in object";</li>
<li>二个参数： "(value, key) in object";</li>
<li>三个参数： "(value, key, index) in object";</li>
</ul>
</li>
<li>v-for同时也支持数字的遍历：
<ul>
<li>每一个item都是一个数字；</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> template元素使用</h3>
<ul>
<li>类似于v-if，你可以使用 template 元素来循环渲染一段包含多个元素的内容：
<ul>
<li>我们使用template来对多个元素进行包裹，而不是使用div来完成；</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 数组更新检测</h3>
<ul>
<li>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
</li>
<li>替换数组的方法
<ul>
<li>上面的方法会直接修改原来的数组，但是某些方法不会替换原来的数组，而是会生成新的数组，比如 filter()、 concat() 和 slice()。</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-for 中的 key 是什么作用？</h3>
<blockquote>
<p>https://cn.vuejs.org/api/built-in-special-attributes.html#key</p>
</blockquote>
<ul>
<li>
<p>在使用v-for进行列表渲染时，我们通常会给元素或者组件绑定一个key属性。</p>
</li>
<li>
<p>这个key属性有什么作用呢？我们先来看一下官方的解释：</p>
<ul>
<li>
<p>key属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes；</p>
</li>
<li>
<p>如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法；</p>
</li>
<li>
<p>而使用key时，它会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素；</p>
</li>
</ul>
</li>
<li>
<p>官方的解释对于初学者来说并不好理解，比如下面的问题：</p>
<ul>
<li>什么是新旧nodes，什么是VNode？</li>
<li>没有key的时候，如何尝试修改和复用的？</li>
<li>有key的时候，如何基于key重新排列的？</li>
</ul>
</li>
</ul>
<h4> 认识 VNode</h4>
<ul>
<li>我们先来解释一下VNode的概念：
<ul>
<li>因为目前我们还没有比较完整的学习组件的概念，所以目前我们先理解HTML元素创建出来的VNode；</li>
<li>VNode的全称是Virtual Node，也就是虚拟节点；</li>
<li>事实上，无论是组件还是元素，它们最终在Vue中表示出来的都是一个个VNode；</li>
<li>VNode的本质是一个JavaScript的对象；可以用于描述某一个标签/ 元素 的样子</li>
<li>好处: 多平台的渲染, 跨平台(主要好处)</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310201628396.png" alt="image-20231020162812819" tabindex="0" loading="lazy"><figcaption>image-20231020162812819</figcaption></figure>
<h4> 虚拟 DOM</h4>
<ul>
<li>如果我们不只是一个简单的div，而是有一大堆的元素，那么它们应该会形成一个 VNode Tree</li>
<li>虚拟 DOM 与 真实 DOM 不一定一一对应</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310201631261.png" alt="image-20231020163154944" tabindex="0" loading="lazy"><figcaption>image-20231020163154944</figcaption></figure>
<h4> 插入 F 的案例</h4>
<ul>
<li>
<p>我们先来看一个案例：这个案例是当我点击按钮时会在中间插入一个f；</p>
</li>
<li>
<p>我们可以确定的是，这次更新对于ul和button是不需要进行更新，需要更新的是我们 li 的列表：</p>
<ul>
<li>
<p>在Vue中，对于相同父元素的子元素节点并不会重新渲染整个列 表；</p>
</li>
<li>
<p>因为对于列表中 a、b、c、d它们都是没有变化的；</p>
</li>
<li>
<p>在操作真实DOM的时候，我们只需要在中间插入一个 f 的 li 即可；</p>
</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>那么Vue中对于列表的更新究竟是如何操作的呢？
<ul>
<li>Vue事实上会对于有key和没有key会调用两个不同的方法；</li>
</ul>
</li>
</ul>
<h5> Vue源码对于key的判断</h5>
<ul>
<li>有key，那么就使用 patchKeyedChildren方法；</li>
<li>没有key，那么久使用 patchUnkeyedChildren方法；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310201647317.png" alt="image-20231020164733530" tabindex="0" loading="lazy"><figcaption>image-20231020164733530</figcaption></figure>
<blockquote>
<p>diff算法: diff 算法是指生成更新补丁的方式,主要应用于虚拟 DOM 树变化后,更新真实 DOM。所以 diff 算法一定存在这样一个过程:触发更新 → 生成补丁 → 应用补丁。</p>
</blockquote>
<ul>
<li>没有key的操作过程</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310221823690.png" alt="image-20231022182341619" tabindex="0" loading="lazy"><figcaption>image-20231022182341619</figcaption></figure>
<ul>
<li>我们会发现上面的diff算法效率并不高：
<ul>
<li>c和d来说它们事实上并不需要有任何的改动；</li>
<li>但是因为我们的c被f所使用了，所有后续所有的内容都要一次进行改动，并且最后进行新增；</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310221820519.png" alt="image-20231022182012027" tabindex="0" loading="lazy"><figcaption>image-20231022182012027</figcaption></figure>
<ul>
<li>有key的操作过程-diff算法
<ul>
<li>第一步的操作是从头开始进行遍历、比较：
<ul>
<li>a和b是一致的会继续进行比较；</li>
<li>c和f因为key不一致，所以就会break跳出循环</li>
</ul>
</li>
<li>第二步的操作是从尾部开始进行遍历、比较</li>
<li>第三步是如果旧节点遍历完毕，但是依然有新的节点，那么就新增节点：</li>
<li>第四步是如果新的节点遍历完毕，但是依然有旧的节点，那么就移除旧节点：</li>
<li>第五步是最特色的情况，中间还有很多未知的或者乱序的节点：</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310221822567.png" alt="image-20231022182232738" tabindex="0" loading="lazy"><figcaption>image-20231022182232738</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202310221821946.png" alt="image-20231022182140133" tabindex="0" loading="lazy"><figcaption>image-20231022182140133</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202310221822262.png" alt="image-20231022182241976" tabindex="0" loading="lazy"><figcaption>image-20231022182241976</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202310221822079.png" alt="image-20231022182251535" tabindex="0" loading="lazy"><figcaption>image-20231022182251535</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202310221823627.png" alt="image-20231022182300781" tabindex="0" loading="lazy"><figcaption>image-20231022182300781</figcaption></figure>
<h5> 有无key的结论</h5>
<ul>
<li>有无key的结论
<ul>
<li>所以我们可以发现，Vue在进行diff算法的时候，会尽量利用我们的key来进行优化操作：
<ul>
<li>在没有key的时候我们的效率是非常低效的；</li>
<li>在进行插入或者重置顺序的时候，保持相同的key可以让diff算法更加的高效；</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310162330091.png" type="image/png"/>
    </item>
    <item>
      <title>Vue 的Options API</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/Vue3%E7%9A%84Options-API.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/Vue3%E7%9A%84Options-API.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Vue 的Options API</source>
      <description>Computed 认识计算属性 我们知道，在模板中可以直接通过插值语法显示一些data中的数据。 但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示； 比如我们需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示； 在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算； 在模板中放入太多的逻辑会让模板过重和难以维护； 并且如果多个地方都使用到，那么会有大量重复的代码；</description>
      <pubDate>Tue, 31 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Computed</h2>
<h3> 认识计算属性</h3>
<p>我们知道，在模板中可以直接通过插值语法显示一些data中的数据。</p>
<p>但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示；</p>
<ul>
<li>比如我们需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示；</li>
<li>在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算；</li>
<li>在模板中放入太多的逻辑会让模板过重和难以维护；</li>
<li>并且如果多个地方都使用到，那么会有大量重复的代码；</li>
</ul>
<p>我们有没有什么方法可以将逻辑抽离出去呢？</p>
<ul>
<li>可以，其中一种方式就是将逻辑抽取到一个method中，放到methods的options中；</li>
<li>但是，这种做法有一个直观的弊端，就是所有的data使用过程都会变成了一个方法的调用；</li>
<li>另外一种方式就是使用计算属性computed；</li>
</ul>
<p>什么是计算属性呢？</p>
<ul>
<li>https://cn.vuejs.org/api/reactivity-core.html#computed</li>
<li>官方并没有给出直接的概念解释；</li>
<li>而是说：对于任何包含响应式数据的复杂逻辑，你都应该使用<strong>计算属性</strong>；</li>
<li>计算属性将被混入到组件实例中。所有 getter 和 setter 的 <code>this</code> 上下文自动地绑定为组件实例；</li>
</ul>
<h3> 基本使用</h3>
<p>计算属性的用法：</p>
<ul>
<li><strong>选项：</strong> computed</li>
<li><strong>类型：</strong><code>{ [key: string]: Function | { get: Function, set: Function } }</code></li>
</ul>
<p>我们来看三个案例：</p>
<ul>
<li>我们有两个变量：firstName 和 lastName，希望它们拼接之后在界面上显示；</li>
<li>我们有一个分数：score
<ul>
<li>当score大于60的时候，在界面上显示及格；</li>
<li>当score小于60的时候，在界面上显示不及格；</li>
</ul>
</li>
<li>我们有一个变量message，记录一段文字：比如Hello World
<ul>
<li>某些情况下我们是直接显示这段文字；</li>
<li>某些情况下我们需要对这段文字进行反转；</li>
</ul>
</li>
<li>我们可以有三种实现思路：
<ul>
<li>思路一：在模板语法中直接使用表达式；</li>
<li>思路二：使用method对逻辑进行抽取；</li>
<li>思路三：使用计算属性computed；</li>
</ul>
</li>
</ul>
<h4> 在模板语法中直接使用表达式</h4>
<ul>
<li>缺点一：模板中存在大量的复杂逻辑，不便于维护（模板中表达式的初衷是用于简单的计算）；</li>
<li>缺点二：当有多次一样的逻辑时，存在重复的代码；</li>
<li>缺点三：多次使用的时候，很多运算也需要多次执行，没有缓存；</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 使用method对逻辑进行抽取</h4>
<ul>
<li>缺点一：我们事实上先显示的是一个结果，但是都变成了一种方法的调用；</li>
<li>缺点二：多次使用方法的时候，没有缓存，也需要多次计算；</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> computed 实现</h4>
<ul>
<li>注意：计算属性看起来像是一个函数，但是我们在使用的时候不需要加()，这个后面讲setter和getter时会讲到；</li>
<li>我们会发现无论是直观上，还是效果上计算属性都是更好的选择；</li>
<li>并且计算属性是有缓存的；</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 计算属性 vs methods</h3>
<p>在上面的实现思路中，我们会发现计算属性和methods的实现看起来是差别是不大的，而且我们多次提到计算属性有缓存。</p>
<p>接下来我们来看一下同一个计算多次使用，计算属性和methods的差异：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>打印结果如下：</p>
<ul>
<li>我们会发现methods在多次使用时，会调用多次；</li>
<li>而计算属性虽然使用了多次，但是计算的过程只调用了一次；</li>
<li>这是因为计算属性会基于它们的依赖关系进行缓存；</li>
<li>在数据不发生变化时，计算属性是不需要重新计算的；</li>
<li>但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算；如下:</li>
</ul>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>当 score 变化, console 输出如下:</p>
</blockquote>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 计算属性的 setter 和 getter</h3>
<p>计算属性在大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数。</p>
<p>但是，如果我们确实想设置计算属性的值呢？</p>
<ul>
<li>这个时候我们也可以给计算属性设置一个setter的方法；</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>以下为内部判断</p>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202310251728011.jpeg" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>
<h2> 侦听器 watch</h2>
<blockquote>
<p>用于声明在数据更改时调用的侦听回调。<code>watch</code> 选项期望接受一个对象，其中键是需要侦听的响应式组件实例属性 (例如，通过 <code>data</code> 或 <code>computed</code> 声明的属性)——值是相应的回调函数。该回调函数接受被侦听源的新值和旧值。</p>
</blockquote>
<ul>
<li>什么是侦听器？
<ul>
<li>开发中我们在data返回的对象中定义了数据，这个数据通过插值语法等方式绑定到template中;</li>
<li>当数据变化时，template会自动进行更新来显示最新的数据;</li>
<li>但是在某些情况下，我们希望在代码逻辑中监听某个数据的变化，这个时候就需要用侦听器watch来完成了;</li>
</ul>
</li>
<li>用法如下：
<ul>
<li>选项：watch</li>
<li>类型: <code>{[key: string]: string | Function | Object | Array}</code></li>
</ul>
</li>
</ul>
<h3> 简单案例</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 配置选项</h3>
<ul>
<li><code>watch</code> 默认是浅层的：被侦听的属性，仅在被赋新值时，才会触发回调函数——而嵌套属性的变化不会触发。如果想侦听所有嵌套的变更，你需要深层侦听器：</li>
<li>以下为不使用深度监听, 当 info.name 在方法中被赋值改变时, 页面会改变, 但是watch不会侦听到, 理由如上</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>将 watch 中更改如下, 不管多深都会侦听到</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>immediate: true</code> 立即执行,  这个时候无论后面数据是否有变化，侦听的函数都会有限执行一次；即当刷新页面时会立刻执行一次, 回调函数的初次执行就发生在 <code>created</code> 钩子之前。Vue 此时已经处理了 <code>data</code>、<code>computed</code> 和 <code>methods</code> 选项，所以这些属性在第一次调用时就是可用的。</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p>注意: 引用对象 or watch 不能侦听到旧值, 可以利用 计算属性 缓存旧值, 或者自己深拷贝一份作为保存</p>
</blockquote>
<h3> 其他方式</h3>
<blockquote>
<p>https://cn.vuejs.org/api/options-state.html#watch</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> $watch 的API：</h4>
<ul>
<li>https://cn.vuejs.org/api/component-instance.html#watch</li>
</ul>
<ul>
<li>我们可以在created的生命周期（后续会讲到）中，使用 this.$watchs 来侦听；</li>
<li>
<ul>
<li>第一个参数是要侦听的源；</li>
<li>第二个参数是侦听的回调函数callback；</li>
<li>第三个参数是额外的其他选项，比如deep、immediate；</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 阶段案例</h2>
<blockquote>
<p>现在我们来做一个相对综合一点的练习：书籍购物车</p>
</blockquote>
<ul>
<li>css</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>index</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> v-model</h2>
<ul>
<li>
<p><code>v-model</code> 可以在组件上使用以实现双向绑定。</p>
</li>
<li>
<p>首先让我们回忆一下 <code>v-model</code> 在原生元素上的用法：</p>
<p>template</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>在代码背后，模板编译器会对 <code>v-model</code> 进行更冗长的等价展开。因此上面的代码其实等价于下面这段：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>而当使用在一个组件上时，<code>v-model</code> 会被展开为如下的形式：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>要让这个例子实际工作起来，<code>&lt;CustomInput&gt;</code> 组件内部需要做两件事：</p>
<ol>
<li>将内部原生 <code>&lt;input&gt;</code> 元素的 <code>value</code> attribute 绑定到 <code>modelValue</code> prop</li>
<li>当原生的 <code>input</code> 事件触发时，触发一个携带了新值的 <code>update:modelValue</code> 自定义事件</li>
</ol>
</li>
</ul>
<h3> 内部实现</h3>
<figure><img src="https://qiniu.waite.wang/202310311437450.jpeg" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>
<h3> 绑定其他表单</h3>
<blockquote>
<p>具体可以看: https://cn.vuejs.org/guide/essentials/forms.html#modifiers</p>
</blockquote>
<blockquote>
<p>在 HTML 中，<code>&lt;label&gt;</code> 标签的 <code>for</code> 属性被用来关联 <code>&lt;label&gt;</code> 标签和表单控件（如 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 等）。<code>for</code> 属性的值应该是你想要关联的表单控件的 <code>id</code>。 当 <code>&lt;label&gt;</code> 被点击时，与其关联的表单控件会获得焦点。</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310312002330.png" alt="image-20231031200224648" tabindex="0" loading="lazy"><figcaption>image-20231031200224648</figcaption></figure>
<p>目前我们在前面的案例中大部分的值都是在template中固定好的：</p>
<ul>
<li>比如gender的两个输入框值male、female；</li>
<li>比如hobbies的三个输入框值basketball、football、tennis；</li>
</ul>
<p>在真实开发中，我们的数据可能是来自服务器的，那么我们就可以先将值请求下来，绑定到data返回的对象中，再通过v-bind来进行值的绑定，这个过程就是值绑定。</p>
<h3> 修饰符</h3>
<h4> 内置修饰符</h4>
<h5> <code>.lazy</code></h5>
<p>默认情况下，<code>v-model</code> 会在每次 <code>input</code> 事件后更新数据 (<a href="https://cn.vuejs.org/guide/essentials/forms.html#vmodel-ime-tip" target="_blank" rel="noopener noreferrer">IME 拼字阶段的状态</a>例外)。你可以添加 <code>lazy</code> 修饰符来改为在每次 <code>change</code> 事件后更新数据：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5> <a href="https://cn.vuejs.org/guide/essentials/forms.html#number" target="_blank" rel="noopener noreferrer"><code>.number</code></a></h5>
<p>如果你想让用户输入自动转换为数字，你可以在 <code>v-model</code> 后添加 <code>.number</code> 修饰符来管理输入：</p>
<p>另外，在我们进行逻辑判断时，如果是一个string类型，在可以转化的情况下会进行隐式转换的：</p>
<ul>
<li>下面的score在进行判断的过程中会进行隐式转化的；</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果该值无法被 <code>parseFloat()</code> 处理，那么将返回原始值。</p>
<p><code>number</code> 修饰符会在输入框有 <code>type="number"</code> 时自动启用。</p>
<h5> <a href="https://cn.vuejs.org/guide/essentials/forms.html#trim" target="_blank" rel="noopener noreferrer"><code>.trim</code></a></h5>
<p>如果你想要默认自动去除用户输入内容中两端的空格，你可以在 <code>v-model</code> 后添加 <code>.trim</code> 修饰符：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 自定义的修饰符</h4>
<p>在某些场景下，你可能想要一个自定义组件的 <code>v-model</code> 支持自定义的修饰符。</p>
<p>我们来创建一个自定义的修饰符 <code>capitalize</code>，它会自动将 <code>v-model</code> 绑定输入的字符串值第一个字母转为大写：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>组件的 <code>v-model</code> 上所添加的修饰符，可以通过 <code>modelModifiers</code> prop 在组件内访问到。在下面的组件中，我们声明了 <code>modelModifiers</code> 这个 prop，它的默认值是一个空对象：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意这里组件的 <code>modelModifiers</code> prop 包含了 <code>capitalize</code> 且其值为 <code>true</code>，因为它在模板中的 <code>v-model</code> 绑定 <code>v-model.capitalize="myText"</code> 上被使用了。</p>
<p>有了这个 prop，我们就可以检查 <code>modelModifiers</code> 对象的键，并编写一个处理函数来改变抛出的值。在下面的代码里，我们就是在每次 <code>&lt;input /&gt;</code> 元素触发 <code>input</code> 事件时将值的首字母大写：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 多个 <code>v-model</code> 绑定</h3>
<p>我们可以在单个组件实例上创建多个 <code>v-model</code> 双向绑定。</p>
<p>组件上的每一个 <code>v-model</code> 都会同步不同的 prop，而无需额外的选项：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310251728011.jpeg" type="image/jpeg"/>
    </item>
    <item>
      <title>邂逅Vue3开发</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/%E9%82%82%E9%80%85%20Vue%20%E5%BC%80%E5%8F%91.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/%E9%82%82%E9%80%85%20Vue%20%E5%BC%80%E5%8F%91.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">邂逅Vue3开发</source>
      <description>认识 Vue 什么是 Vue Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。 全程是Vue.js或者Vuejs； 什么是渐进式框架呢？表示我们可以在项目中一点点来引入和使用Vue，而不一定需要全部使用Vue来开发整个 项目； Vue3带来的变化 源码通过monorepo的形式来管理源代码： Mono：单个 Repo：repository仓库 主要是将许多项目的代码存储在同一个 repository 中； 这样做的目的是多个包本身相互独立，可以有自己的功能逻辑、单元测试等，同时又在同一个仓库下方便管理； 而且模块划分的更加清晰，可维护性、可扩展性更强； 源码使用TypeScript来进行重写： 在Vue2.x的时候，Vue使用 Flow 来进行类型检测； 在Vue3.x的时候，Vue的源码全部使用 TypeScript 来进行重构，并且 Vue 本身对 TypeScript 支持也更好了；</description>
      <pubDate>Thu, 07 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 认识 Vue</h2>
<h3> 什么是 Vue</h3>
<ul>
<li>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。
<ul>
<li>全程是Vue.js或者Vuejs；</li>
<li>什么是渐进式框架呢？表示我们可以在项目中一点点来引入和使用Vue，而不一定需要全部使用Vue来开发整个 项目；</li>
</ul>
</li>
</ul>
<h3> Vue3带来的变化</h3>
<ul>
<li>源码通过monorepo的形式来管理源代码：
<ul>
<li>Mono：单个</li>
<li>Repo：repository仓库</li>
<li>主要是将许多项目的代码存储在同一个 repository 中；</li>
<li>这样做的目的是多个包本身相互独立，可以有自己的功能逻辑、单元测试等，同时又在同一个仓库下方便管理；</li>
<li>而且模块划分的更加清晰，可维护性、可扩展性更强；</li>
</ul>
</li>
<li>源码使用TypeScript来进行重写：
<ul>
<li>在Vue2.x的时候，Vue使用 Flow 来进行类型检测；</li>
<li>在Vue3.x的时候，Vue的源码全部使用 TypeScript 来进行重构，并且 Vue 本身对 TypeScript 支持也更好了；</li>
</ul>
</li>
</ul>
<h4> 性能方面</h4>
<ul>
<li>使用Proxy进行数据劫持
<ul>
<li>在 Vue2.x 的时候，Vue2 是使用 <code>Object.defineProperty</code> 来劫持数据的 getter 和 setter 方法的；</li>
<li>这种方式一致存在一个缺陷就是当给对象添加或者删除属性时，是无法劫持和监听的；</li>
<li>所以在 Vue2.x 的时候，不得不提供一些特殊的API，比如 <code>$set</code> 或 <code>$delete</code> ，事实上都是一些 hack 方法，也增加了 开发者学习新的API的成本；</li>
<li>而在 Vue3.x 开始，Vue 使用 Proxy 来实现数据的劫持</li>
</ul>
</li>
<li>删除了一些不必要的API：
<ul>
<li>移除了实例上的 <code>$on</code> , <code>$off</code>  和  <code>$once</code>；</li>
<li>移除了一些特性：如filter、内联模板等；</li>
</ul>
</li>
<li>包括编译方面的优化：
<ul>
<li>生成Block Tree、Slot编译优化、diff算法优化；</li>
</ul>
</li>
</ul>
<h4> 新的API</h4>
<ul>
<li>由Options API 到 Composition API：
<ul>
<li>在 Vue2.x 的时候，我们会通过 Options API 来描述组件对象；</li>
<li>Options API 包括data、props、methods、computed、生命周期等等这些选项；</li>
<li>存在比较大的问题是多个逻辑可能是在不同的地方：
<ul>
<li>比如created中会使用某一个method来修改data的数据，代码的内聚性非常差；</li>
</ul>
</li>
<li>Composition API可以将 相关联的代码 放到同一处 进行处理，而不需要在多个Options之间寻找；</li>
</ul>
</li>
<li>Hooks函数增加代码的复用性：
<ul>
<li>在Vue2.x的时候，我们通常通过mixins在多个组件之间共享逻辑；但是有一个很大的缺陷就是 mixins也是由一大堆的Options组成的，并且多个mixins会存在命名冲突的问题；</li>
<li>在Vue3.x中，我们可以通过Hook函数，来将一部分独立的逻辑抽取出去，并且它们还可以做到是响应式的；</li>
</ul>
</li>
</ul>
<h2> 如何使用 Vue</h2>
<ol>
<li>方式一：在页面中通过CDN的方式来引入；</li>
<li>方式二：下载Vue的JavaScript文件，并且自己手动引入；</li>
<li>方式三：通过npm包管理工具安装使用它；</li>
<li>方式四：直接通过Vue CLI创建项目，并且使用它；</li>
</ol>
<h3> CDN 引入</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 下载和引入</h3>
<ul>
<li>下载Vue的源码，可以直接打开CDN的链接：
<ul>
<li>打开链接，复制其中所有的代码；</li>
<li>创建一个新的文件，比如vue.js，将代码复制到其中；</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 声明式编程和命令式编程</h2>
<ul>
<li>原生开发和Vue开发的模式和特点,我们会发现是完全不同的,这里其实涉及到两种不同的编程范式命令式编程和声明式编程</li>
<li>命令式编程关注的是“ how to do”,声明式编程关注的是" what to do",由框架(机器)完成"how"的过程</li>
</ul>
<h2> MVVM模型</h2>
<ul>
<li>MVC和MVVM都是一种软件的体系结构
<ul>
<li>MVC是 Model-View-Controller的简称,是在前期被使用非常框架的架构模式,比如iS、前端</li>
<li>MVVM是 Model-View- ViewMode的简称,是目前非常流行的架构模式</li>
</ul>
</li>
<li>通常情况下,我们也经常称vue是一个MVVM的框架
<ul>
<li>vue官方其实有说明,vue虽然并没有完全遵守MVVM的模型,但是整个设计是受到它的启发的</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310161331268.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> template属性</h2>
<ul>
<li>在使用 createApp的时候,我们传入了一个对象,接下来我们详细解析一下之前传入的属性分别代表什么含义。
<ul>
<li>template属性:表示的是Vue需要帮助我们渲染的模板信息</li>
<li>目前我们看到它里面有很多的HTML标签,这些标签会替换掉我们挂载到的元素(比如id为app的dⅳv)的innerHTML</li>
<li>模板中有一些奇怪的语法,比如{},比如@ )click,这些都是模板特有的语法</li>
</ul>
</li>
<li>但是这个模板的写法有点过于别扭了,并且IDE很有可能没有任何提示,阻碍我们编程的效率</li>
<li>vue提供了两种方式:</li>
<li>方式一:使用 script标签,并且标记它的类型为 X-template;</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>方式二:使用任意标签(通常使用 template标签,因为不会被浏览器渲染),设置id;v template元素是一种用于保存客户端内容的机制,该内容再加载页面时不会被呈现,但随后可以在运行时使用 JavaScript 实例化</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> data属性</h2>
<ul>
<li>
<p>data属性是传入一个函数,并且该函数需要返回一个对象</p>
<ul>
<li>在Vue2x的时候,也可以传入一个对象(虽然官方推荐是一个函数);</li>
<li>在Vue3x的时候,必须传入一个函数,否则就会直接在浏览器中报错</li>
</ul>
</li>
<li>
<p>data中返回的对象会被vue的响应式系统劫持,之后对该对象的修改或者访问都会在劫持中被处理</p>
<ul>
<li>所以我们在 template中通过{ counter} 访问 counter,可以从对象中获取到数据</li>
<li>所以我们修改 counter的值时, template中的{ counter)也会发生改变;</li>
</ul>
</li>
</ul>
<h2> methods属性（重点）</h2>
<ul>
<li>
<p>methods属性是一个对象,通常我们会在这个对象中定义很多的方法</p>
<ul>
<li>这些方法可以被绑定到 template模板中;</li>
<li>在该方法中,我们可以使用this关键字来直接访问到data中返回的对象的属性;</li>
</ul>
</li>
<li>
<p>问题：官方文档有这个描述，即不能使用箭头函数</p>
</li>
<li>
<p>为什么不能使用箭头函数(VUE3.0)？</p>
</li>
<li>
<p>我们在methods中要使用data返回对象中的数据：</p>
<ul>
<li>那么这个this是必须有值的，并且应该可以通过this获取到data返回对象中的数据。</li>
</ul>
</li>
<li>
<p>那么我们这个this能不能是window呢？</p>
<ul>
<li>不可以是window，因为window中我们无法获取到data返回对象中的数据；</li>
<li>但是如果我们使用箭头函数，那么这个this就会是window了；</li>
</ul>
</li>
<li>
<p>为什么是window呢？</p>
<ul>
<li>这里涉及到箭头函数使用this的查找规则，它会在自己的上层作用于中来查找this；</li>
<li>最终刚好找到的是script作用于中的this，所以就是window；</li>
</ul>
</li>
<li>
<p>this到底是如何查找和绑定的呢？</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA" target="_blank" rel="noopener noreferrer">前端面试之彻底搞懂this指向</a></li>
</ul>
</li>
<li>
<p><strong>不使用箭头函数的情况下，this到底指向什么</strong></p>
<ul>
<li>事实上Vue的源码当中就是对methods中的所有函数进行了遍历，并且通过 bind 绑定了 this</li>
</ul>
</li>
</ul>
<blockquote>
<p>具体看 https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 如何阅读Vue源码</h2>
<ul>
<li>需要的环境 npm，yarn</li>
<li>操作步骤
<ol>
<li>安装yarn npm install yarn -g</li>
<li>在项目中配置yarn yarn install</li>
<li>在package.json中的dev后加上--sourcemap</li>
<li>打包项目 yarn dev （在vue/dist文件夹下有两个文件，vue.global.js和vue.global.js.map）</li>
<li>在vue/examplex新建自己的文件夹以及测试demo</li>
<li>在demo中打下断点—debugger</li>
<li>在浏览器中打开调试面板，选择其中的source面板，查看执行对应的源码</li>
</ol>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310161331268.png" type="image/png"/>
    </item>
  </channel>
</rss>