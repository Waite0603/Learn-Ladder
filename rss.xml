<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://brain.sunguoqi.com/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://brain.sunguoqi.com/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Waite Wang</title>
    <link>https://brain.sunguoqi.com/</link>
    <description>热爱可抵漫长岁月！</description>
    <language>zh-CN</language>
    <pubDate>Tue, 23 Jan 2024 14:06:41 GMT</pubDate>
    <lastBuildDate>Tue, 23 Jan 2024 14:06:41 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <item>
      <title>微信小程序框架</title>
      <link>https://brain.sunguoqi.com/web/weChat/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.html</link>
      <guid>https://brain.sunguoqi.com/web/weChat/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">微信小程序框架</source>
      <description>​	小程序依赖于微信客户端提供的环境--宿主环境，小程序借助这个宿注环境提供的功能，可以实现网页无法实现的功能。让小程序更接近原生的app体验。 小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。 ​	首先，我们来简单了解下小程序的运行环境。整个小程序框架系统分为两部分：逻辑层（App Service）和 视图层（View）。小程序提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。</description>
      <pubDate>Tue, 23 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>​	小程序依赖于微信客户端提供的环境--宿主环境，小程序借助这个宿注环境提供的功能，可以实现网页无法实现的功能。让小程序更接近原生的app体验。</p>
<p>小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。</p>
<figure><img src="https://qiniu.waite.wang/202401222127287.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>​	首先，我们来简单了解下小程序的运行环境。整个小程序框架系统分为两部分：<strong><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/" target="_blank" rel="noopener noreferrer">逻辑层</a></strong>（App Service）和 <strong><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/" target="_blank" rel="noopener noreferrer">视图层</a></strong>（View）。小程序提供了自己的视图层描述语言 <code>WXML</code> 和 <code>WXSS</code>，以及基于 <code>JavaScript</code> 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。</p>
<p>​	小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端（下文中也会采用Native来代指微信客户端）做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。</p>
<figure><img src="https://qiniu.waite.wang/202401222127418.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 响应的数据绑定</h2>
<p>框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>开发者通过框架将逻辑层数据中的 <code>name</code> 与视图层的 <code>name</code> 进行了绑定，所以在页面一打开的时候会显示 <code>Hello Weixin!</code>；</li>
<li>当点击按钮的时候，视图层会发送 <code>changeName</code> 的事件给逻辑层，逻辑层找到并执行对应的事件处理函数；</li>
<li>回调函数触发后，逻辑层执行 <code>setData</code> 的操作，将 <code>data</code> 中的 <code>name</code> 从 <code>Weixin</code> 变为 <code>MINA</code>，因为该数据和视图层已经绑定了，从而视图层会自动改变为 <code>Hello MINA!</code>。</li>
</ul>
<h2> 逻辑层</h2>
<p>小程序开发框架的逻辑层使用 <code>JavaScript</code> 引擎为小程序提供开发 <code>JavaScript</code> 代码的运行环境以及微信小程序的特有功能。</p>
<p>逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。</p>
<p>开发者写的所有代码最终将会打包成一份 <code>JavaScript</code> 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener noreferrer">ServiceWorker</a>，所以逻辑层也称之为 App Service。</p>
<p>在 <code>JavaScript</code> 的基础上，我们增加了一些功能，以方便小程序的开发：</p>
<ul>
<li>增加 <code>App</code> 和 <code>Page</code> 方法，进行<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html" target="_blank" rel="noopener noreferrer">程序注册</a>和<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html" target="_blank" rel="noopener noreferrer">页面注册</a>。</li>
<li>增加 <code>getApp</code> 和 <code>getCurrentPages</code> 方法，分别用来获取 <code>App</code> 实例和当前页面栈。</li>
<li>提供丰富的 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html" target="_blank" rel="noopener noreferrer">API</a>，如微信用户数据，扫一扫，支付等微信特有能力。</li>
<li>提供<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#%E6%A8%A1%E5%9D%97%E5%8C%96" target="_blank" rel="noopener noreferrer">模块化</a>能力，每个页面有独立的<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F" target="_blank" rel="noopener noreferrer">作用域</a>。</li>
</ul>
<p><strong>注意：小程序框架的逻辑层并非运行在浏览器中，因此 <code>JavaScript</code> 在 web 中一些能力都无法使用，如 <code>window</code>，<code>document</code> 等。</strong></p>
<h3> 注册小程序</h3>
<p>每个小程序都需要在 <code>app.js</code> 中调用 <code>App</code> 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">必填</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">最低版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object" target="_blank" rel="noopener noreferrer">onLaunch</a></td>
<td style="text-align:left">function</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">生命周期回调——监听小程序初始化。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onShow-Object-object" target="_blank" rel="noopener noreferrer">onShow</a></td>
<td style="text-align:left">function</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">生命周期回调——监听小程序启动或切前台。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onHide" target="_blank" rel="noopener noreferrer">onHide</a></td>
<td style="text-align:left">function</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">生命周期回调——监听小程序切后台。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onError-String-error" target="_blank" rel="noopener noreferrer">onError</a></td>
<td style="text-align:left">function</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">错误监听函数。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onPageNotFound-Object-object" target="_blank" rel="noopener noreferrer">onPageNotFound</a></td>
<td style="text-align:left">function</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">页面不存在监听函数。</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.9.90</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onUnhandledRejection-Object-object" target="_blank" rel="noopener noreferrer">onUnhandledRejection</a></td>
<td style="text-align:left">function</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">未处理的 Promise 拒绝事件监听函数。</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.10.0</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onThemeChange-Object-object" target="_blank" rel="noopener noreferrer">onThemeChange</a></td>
<td style="text-align:left">function</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">监听系统主题变化</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.11.0</a></td>
</tr>
<tr>
<td style="text-align:left">其他</td>
<td style="text-align:left">any</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">开发者可以添加任意的函数或数据变量到 <code>Object</code> 参数中，用 <code>this</code> 可以访问</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 <code>getApp</code> 方法获取到全局唯一的 App 实例，获取App上的数据或调用开发者注册在 <code>App</code> 上的函数。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 注册页面</h3>
<p>对于小程序中的每个页面，都需要在页面对应的 <code>js</code> 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。</p>
<h4> 使用 Page 构造器注册页</h4>
<p>简单的页面可以使用 <code>Page()</code> 进行构造。</p>
<p><strong>代码示例：</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>详细的参数含义和使用请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html" target="_blank" rel="noopener noreferrer">Page 参考文档</a></p>
<h3> 页面生命周期</h3>
<figure><img src="https://qiniu.waite.wang/202401222133494.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h3> 模块化</h3>
<p>可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/module.html" target="_blank" rel="noopener noreferrer"><code>module.exports</code></a> 或者 <code>exports</code> 才能对外暴露接口。</p>
<p>注意：</p>
<ul>
<li><code>exports</code> 是 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/module.html" target="_blank" rel="noopener noreferrer"><code>module.exports</code></a> 的一个引用，因此在模块里边随意更改 <code>exports</code> 的指向会造成未知的错误。所以更推荐开发者采用 <code>module.exports</code> 来暴露模块接口，除非你已经清晰知道这两者的关系。</li>
<li>小程序目前不支持直接引入 <code>node_modules</code> , 开发者需要使用到 <code>node_modules</code> 时候建议拷贝出相关的代码到小程序的目录中，或者使用小程序支持的 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/npm.html" target="_blank" rel="noopener noreferrer">npm</a> 功能。</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在需要使用这些模块的文件中，使用 <code>require</code> 将公共代码引入</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 文件作用域</h3>
<p>在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。</p>
<p>通过全局函数 <code>getApp</code> 可以获取全局的应用实例，如果需要全局的数据可以在 <code>App()</code> 中设置，如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> API</h3>
<blockquote>
<p>详细见 https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html#API</p>
</blockquote>
<h2> 视图层</h2>
<h3> WXML</h3>
<h4> 数据绑定</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 列表渲染</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 条件渲染</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 模板</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 三目运算符</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>具体的能力以及使用方式在以下章节查看：</p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/data.html" target="_blank" rel="noopener noreferrer">数据绑定</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/list.html" target="_blank" rel="noopener noreferrer">列表渲染</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html" target="_blank" rel="noopener noreferrer">条件渲染</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/template.html" target="_blank" rel="noopener noreferrer">模板</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/import.html" target="_blank" rel="noopener noreferrer">引用</a></p>
</blockquote>
<h3> WXS</h3>
<p>WXS（WeiXin Script）是内联在 WXML 中的脚本段。通过 WXS 可以在模版中内联少量处理脚本，丰富模板的数据预处理能力。另外， WXS 还可以用来编写简单的 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html" target="_blank" rel="noopener noreferrer">WXS 事件响应函数</a>。</p>
<p>从语法上看， WXS 类似于有少量限制的 JavaScript 。要完整了解 WXS 语法，请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/" target="_blank" rel="noopener noreferrer">WXS 语法参考</a>。</p>
<p>以下是一些使用 WXS 的简单示例。</p>
<h4> 页面渲染</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 数据处理</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 简易双向绑定</h3>
<p>在 WXML 中，普通的属性的绑定是单向的。例如：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果使用 <code>this.setData({ value: 'leaf' })</code> 来更新 <code>value</code> ，<code>this.data.value</code> 和输入框的中显示的值都会被更新为 <code>leaf</code> ；但如果用户修改了输入框里的值，却不会同时改变 <code>this.data.value</code> 。</p>
<p>如果需要在用户输入的同时改变 <code>this.data.value</code> ，需要借助简易双向绑定机制。此时，可以在对应项目之前加入 <code>model:</code> 前缀：</p>
<p>如果使用 <code>this.setData({ value: 'leaf' })</code> 来更新 <code>value</code> ，<code>this.data.value</code> 和输入框的中显示的值都会被更新为 <code>leaf</code> ；但如果用户修改了输入框里的值，却不会同时改变 <code>this.data.value</code> 。</p>
<p>如果需要在用户输入的同时改变 <code>this.data.value</code> ，需要借助简易双向绑定机制。此时，可以在对应项目之前加入 <code>model:</code> 前缀：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样，如果输入框的值被改变了， <code>this.data.value</code> 也会同时改变。同时， WXML 中所有绑定了 <code>value</code> 的位置也会被一同更新， <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html" target="_blank" rel="noopener noreferrer">数据监听器</a> 也会被正常触发。</p>
<p><a href="https://developers.weixin.qq.com/s/8jXvobmV7vcj" target="_blank" rel="noopener noreferrer">在开发者工具中预览效果</a></p>
<p>用于双向绑定的表达式有如下限制：</p>
<ol>
<li>只能是一个单一字段的绑定，如</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>都是非法的；</p>
<ol>
<li>目前，尚不能 data 路径，如</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样的表达式目前暂不支持。</p>
<blockquote>
<p>关于微信小程序警告“Do not have handler in component: pages/xxx/xxx. “的解决方法</p>
</blockquote>
<p>通过资料查询和微信开发者社区询问，原因是没有绑定bindinput方法，因此我们可以为表单绑定一个空的方法，来解决这个警告</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 在自定义组件中传递双向绑定</h4>
<p>双向绑定同样可以使用在自定义组件上。如下的自定义组件：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个自定义组件将自身的 <code>myValue</code> 属性双向绑定到了组件内输入框的 <code>value</code> 属性上。这样，如果页面这样使用这个组件：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当输入框的值变更时，自定义组件的 <code>myValue</code> 属性会同时变更，这样，页面的 <code>this.data.pageValue</code> 也会同时变更，页面 WXML 中所有绑定了 <code>pageValue</code> 的位置也会被一同更新。</p>
<h4> 在自定义组件中触发双向绑定更新</h4>
<p>自定义组件还可以自己触发双向绑定更新，做法就是：使用 setData 设置自身的属性。例如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果页面这样使用这个组件：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当组件使用 <code>setData</code> 更新 <code>myValue</code> 时，页面的 <code>this.data.pageValue</code> 也会同时变更，页面 WXML 中所有绑定了 <code>pageValue</code> 的位置也会被一同更新。</p>
<h3> 响应显示区域变化</h3>
<blockquote>
<p>具体看 https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html</p>
</blockquote>
<p>从小程序基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.4.0</a> 开始，小程序在手机上支持屏幕旋转。使小程序中的页面支持屏幕旋转的方法是：在 <code>app.json</code> 的 <code>window</code> 段中设置 <code>"pageOrientation": "auto"</code> ，或在页面 json 文件中配置 <code>"pageOrientation": "auto"</code> 。</p>
<p>以下是在单个页面 json 文件中启用屏幕旋转的示例。</p>
<p><strong>代码示例：</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果页面添加了上述声明，则在屏幕旋转时，这个页面将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。</p>
<p>从小程序基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.5.0</a> 开始， <code>pageOrientation</code> 还可以被设置为 <code>landscape</code> ，表示固定为横屏显示。</p>
<h3> 动画</h3>
<blockquote>
<p>https://developers.weixin.qq.com/miniprogram/dev/framework/view/animation.html</p>
</blockquote>
<h3> 初始渲染缓存</h3>
<p>小程序页面的初始化分为两个部分。</p>
<ul>
<li>逻辑层初始化：载入必需的小程序代码、初始化页面 this 对象（也包括它涉及到的所有自定义组件的 this 对象）、将相关数据发送给视图层。</li>
<li>视图层初始化：载入必需的小程序代码，然后等待逻辑层初始化完毕并接收逻辑层发送的数据，最后渲染页面。</li>
</ul>
<p>在启动页面时，尤其是小程序冷启动、进入第一个页面时，逻辑层初始化的时间较长。在页面初始化过程中，用户将看到小程序的标准载入画面（冷启动时）或可能看到轻微的白屏现象（页面跳转过程中）。</p>
<p>启用初始渲染缓存，可以使视图层不需要等待逻辑层初始化完毕，而直接提前将页面初始 data 的渲染结果展示给用户，这可以使得页面对用户可见的时间大大提前。它的工作原理如下：</p>
<ul>
<li>在小程序页面第一次被打开后，将页面初始数据渲染结果记录下来，写入一个持久化的缓存区域（缓存可长时间保留，但可能因为小程序更新、基础库更新、储存空间回收等原因被清除）；</li>
<li>在这个页面被第二次打开时，检查缓存中是否还存有这个页面上一次初始数据的渲染结果，如果有，就直接将渲染结果展示出来；</li>
<li>如果展示了缓存中的渲染结果，这个页面暂时还不能响应用户事件，等到逻辑层初始化完毕后才能响应用户事件。</li>
</ul>
<p>利用初始渲染缓存，可以：</p>
<ul>
<li>快速展示出页面中永远不会变的部分，如导航栏；</li>
<li>预先展示一个骨架页，提升用户体验；</li>
<li>展示自定义的加载提示；</li>
<li>提前展示广告，等等。</li>
</ul>
<h4> 支持的组件</h4>
<p>在初始渲染缓存阶段中，复杂组件不能被展示或不能响应交互。</p>
<p>目前支持的内置组件：</p>
<ul>
<li><code>&lt;view /&gt;</code></li>
<li><code>&lt;text /&gt;</code></li>
<li><code>&lt;button /&gt;</code></li>
<li><code>&lt;image /&gt;</code></li>
<li><code>&lt;scroll-view /&gt;</code></li>
<li><code>&lt;rich-text /&gt;</code></li>
</ul>
<p>自定义组件本身可以被展示（但它们里面用到的内置组件也遵循上述限制）。</p>
<h4> 静态初始渲染缓存</h4>
<p>若想启用初始渲染缓存，最简单的方法是在页面的 <code>json</code> 文件中添加配置项 <code>"initialRenderingCache": "static"</code> ：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想要对所有页面启用，可以在 <code>app.json</code> 的 <code>window</code> 配置段中添加这个配置：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加这个配置项之后，在手机中预览小程序首页，然后杀死小程序再次进入，就会通过初始渲染缓存来渲染首页。</p>
<p>注意：这种情况下，初始渲染缓存记录的是页面 data 应用在页面 WXML 上的结果，不包含任何 setData 的结果。</p>
<p>例如，如果想要在页面中展示出“正在加载”几个字，这几个字受到 <code>loading</code> 数据字段控制：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种情况下， <code>loading</code> 应当在 <code>data</code> 中指定为 <code>true</code> ，如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而不能通过 <code>setData</code> 将 <code>loading</code> 置为 <code>true</code> ：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>换而言之，这种做法只包含页面 <code>data</code> 的渲染结果，即页面的纯静态成分。</p>
<h4> 在初始渲染缓存中添加动态内容</h4>
<p>有些场景中，只是页面 <code>data</code> 的渲染结果会比较局限。有时会想要额外展示一些可变的内容，如展示的广告图片 URL 等。</p>
<p>这种情况下可以使用“动态”初始渲染缓存的方式。首先，配置 <code>"initialRenderingCache": "dynamic"</code> ：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时，初始渲染缓存不会被自动启用，还需要在页面中调用 <code>this.setInitialRenderingCache(dynamicData)</code> 才能启用。其中， <code>dynamicData</code> 是一组数据，与 <code>data</code> 一起参与页面 WXML 渲染。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从原理上说，在动态生成初始渲染缓存的方式下，页面会在后台使用动态数据重新渲染一次，因而开销相对较大。因而要尽量避免频繁调用 <code>this.setInitialRenderingCache</code> ，如果在一个页面内多次调用，仅最后一次调用生效。</p>
<p>注意：</p>
<ul>
<li><code>this.setInitialRenderingCache</code> 调用时机不能早于 <code>Page</code> 的 <code>onReady</code> 或 <code>Component</code> 的 <code>ready</code> 生命周期，否则可能对性能有负面影响。</li>
<li>如果想禁用初始渲染缓存，调用 <code>this.setInitialRenderingCache(null)</code> 。</li>
</ul>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202401222127287.png" type="image/png"/>
    </item>
    <item>
      <title>微信小程序组件</title>
      <link>https://brain.sunguoqi.com/web/weChat/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6.html</link>
      <guid>https://brain.sunguoqi.com/web/weChat/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">微信小程序组件</source>
      <description>https://developers.weixin.qq.com/miniprogram/dev/component/ html 中有 div、span、ul、li 、img, 而小程序上面所有的标签都没有，只有组件, 微信小程序中的组件就相当于之前HTML中的标签。但是小程序中的组件除了包裹功能，还具有样式和 js 功能。 image-20240120161419501</description>
      <pubDate>Sun, 21 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>https://developers.weixin.qq.com/miniprogram/dev/component/</p>
</blockquote>
<p>html 中有 <code>div、span、ul、li 、img</code>,  而小程序上面所有的标签都没有，只有组件,  微信小程序中的组件就相当于之前HTML中的标签。但是小程序中的组件除了包裹功能，还具有样式和 js 功能。</p>
<figure><img src="https://qiniu.waite.wang/202401201614793.png" alt="image-20240120161419501" tabindex="0" loading="lazy"><figcaption>image-20240120161419501</figcaption></figure>
<blockquote>
<p>以下会介绍一些常用的标签, 剩下的可以在官方文档中查看</p>
</blockquote>
<h2> 视图/基础组件</h2>
<h3> View</h3>
<p>​	视图容器，view组件就相当于之前HTML中的div标签。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">必填</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">最低版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">hover-class</td>
<td style="text-align:left">string</td>
<td style="text-align:left">none</td>
<td style="text-align:left">否</td>
<td style="text-align:left">指定按下去的样式类。当 <code>hover-class="none"</code> 时，没有点击态效果</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left">hover-stop-propagation</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">否</td>
<td style="text-align:left">指定是否阻止本节点的祖先节点出现点击态</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.5.0</a></td>
</tr>
<tr>
<td style="text-align:left">hover-start-time</td>
<td style="text-align:left">number</td>
<td style="text-align:left">50</td>
<td style="text-align:left">否</td>
<td style="text-align:left">按住后多久出现点击态，单位毫秒</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left">hover-stay-time</td>
<td style="text-align:left">number</td>
<td style="text-align:left">400</td>
<td style="text-align:left">否</td>
<td style="text-align:left">手指松开后点击态保留时间，单位毫秒</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>以下是一个 Flex 布局的例子</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202401201623482.png" alt="image-20240120162353536" tabindex="0" loading="lazy"><figcaption>image-20240120162353536</figcaption></figure>
<h3> text</h3>
<p>​	文本组件，相当于HTML中的span标签。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> swiper</h3>
<blockquote>
<p>https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html#%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA</p>
</blockquote>
<p>滑块视图容器。其中只可放置<code>swiper-item</code>组件，否则会导致未定义的行为。也就是说swiper内部只能放swiper-item组件，而swiper-item组件中就可以随便放其它组件及内容了。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到swiper组件有轮播图的效果。而且它有默认的高度(150px)。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">必填</th>
<th style="text-align:left">说明</th>
<th>最低版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">indicator-dots</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是否显示面板指示点</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">indicator-color</td>
<td style="text-align:left">color</td>
<td style="text-align:left">rgba(0, 0, 0, .3)</td>
<td style="text-align:left">否</td>
<td style="text-align:left">指示点颜色</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.1.0</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">indicator-active-color</td>
<td style="text-align:left">color</td>
<td style="text-align:left">#000000</td>
<td style="text-align:left">否</td>
<td style="text-align:left">当前选中的指示点颜色</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.1.0</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">autoplay</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是否自动切换</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">current</td>
<td style="text-align:left">number</td>
<td style="text-align:left">0</td>
<td style="text-align:left">否</td>
<td style="text-align:left">当前所在滑块的 index</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">interval</td>
<td style="text-align:left">number</td>
<td style="text-align:left">5000</td>
<td style="text-align:left">否</td>
<td style="text-align:left">自动切换时间间隔</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">duration</td>
<td style="text-align:left">number</td>
<td style="text-align:left">500</td>
<td style="text-align:left">否</td>
<td style="text-align:left">滑动动画时长</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">circular</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是否采用衔接滑动</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">vertical</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">否</td>
<td style="text-align:left">滑动方向是否为纵向</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">display-multiple-items</td>
<td style="text-align:left">number</td>
<td style="text-align:left">1</td>
<td style="text-align:left">否</td>
<td style="text-align:left">同时显示的滑块数量</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.9.0</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">previous-margin</td>
<td style="text-align:left">string</td>
<td style="text-align:left">"0px"</td>
<td style="text-align:left">否</td>
<td style="text-align:left">前边距，可用于露出前一项的一小部分，接受 px 和 rpx 值</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.9.0</a></td>
</tr>
</tbody>
</table>
<blockquote>
<p>以下是一个简单的轮播图效果</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>当然, 在 Skyline 渲染模式下, 他也会有不同的表现, 具体可以看</p>
<p>https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html#%E6%8C%87%E7%A4%BA%E5%99%A8%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA</p>
</blockquote>
<h3> scroll-view</h3>
<blockquote>
<p>https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html</p>
</blockquote>
<p>可滚动视图区域。使用竖向滚动时，需要给<a href="https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html" target="_blank" rel="noopener noreferrer">scroll-view</a>一个固定高度，通过 WXSS 设置 height。组件属性的长度单位默认为px，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.4.0</a>起支持传入单位(rpx/px)。</p>
<ol>
<li>横向滚动需打开 enable-flex 以兼容 WebView，如 </li>
<li>滚动条的长度是预估的，若直接子节点的高度差别较大，则滚动条长度可能会不准确</li>
<li>使用 <code>worklet</code> 函数需要开启开发者工具 "将 JS 编译成 ES5" 或 "编译 worklet 函数" 选项。</li>
</ol>
<blockquote>
<p>以下我会给出 纵向滚动 以及 横向滚动 两个效果, 具体属性可以在官方文档中查看</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html#scroll-view-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E7%A4%BA%E4%BE%8B</p>
</blockquote>
<blockquote>
<p>以下是横向滚动案例</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> icon</h3>
<p>​	icon组件就是在页面可以显示一个图标。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">必填</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">最低版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">type</td>
<td style="text-align:left">string</td>
<td style="text-align:left"></td>
<td style="text-align:left">是</td>
<td style="text-align:left">icon的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left">size</td>
<td style="text-align:left">number/string</td>
<td style="text-align:left">23</td>
<td style="text-align:left">否</td>
<td style="text-align:left">icon的大小，单位默认为px，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.4.0</a>起支持传入单位(rpx/px)，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.21.3</a>起支持传入其余单位(rem 等)。</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left">color</td>
<td style="text-align:left">string</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">icon的颜色，同css的color</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
</tbody>
</table>
<h3> progress 进度条</h3>
<p>进度条。组件属性的长度单位默认为px，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.4.0</a>起支持传入单位(rpx/px)。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">必填</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">最低版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">percent</td>
<td style="text-align:left">number</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">百分比0~100</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left">show-info</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">否</td>
<td style="text-align:left">在进度条右侧显示百分比</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left">border-radius</td>
<td style="text-align:left">number/string</td>
<td style="text-align:left">0</td>
<td style="text-align:left">否</td>
<td style="text-align:left">圆角大小</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.3.1</a></td>
</tr>
<tr>
<td style="text-align:left">font-size</td>
<td style="text-align:left">number/string</td>
<td style="text-align:left">16</td>
<td style="text-align:left">否</td>
<td style="text-align:left">右侧百分比字体大小</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.3.1</a></td>
</tr>
<tr>
<td style="text-align:left">stroke-width</td>
<td style="text-align:left">number/string</td>
<td style="text-align:left">6</td>
<td style="text-align:left">否</td>
<td style="text-align:left">进度条线的宽度</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left">color</td>
<td style="text-align:left">string</td>
<td style="text-align:left">#09BB07</td>
<td style="text-align:left">否</td>
<td style="text-align:left">进度条颜色（请使用activeColor）</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left">activeColor</td>
<td style="text-align:left">string</td>
<td style="text-align:left">#09BB07</td>
<td style="text-align:left">否</td>
<td style="text-align:left">已选择的进度条的颜色</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left">backgroundColor</td>
<td style="text-align:left">string</td>
<td style="text-align:left">#EBEBEB</td>
<td style="text-align:left">否</td>
<td style="text-align:left">未选择的进度条的颜色</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left">active</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">否</td>
<td style="text-align:left">进度条从左往右的动画</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
<tr>
<td style="text-align:left">active-mode</td>
<td style="text-align:left">string</td>
<td style="text-align:left">backwards</td>
<td style="text-align:left">否</td>
<td style="text-align:left">backwards: 动画从头播；forwards：动画从上次结束点接着播</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.7.0</a></td>
</tr>
<tr>
<td style="text-align:left">duration</td>
<td style="text-align:left">number</td>
<td style="text-align:left">30</td>
<td style="text-align:left">否</td>
<td style="text-align:left">进度增加1%所需毫秒数</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.8.2</a></td>
</tr>
<tr>
<td style="text-align:left">bindactiveend</td>
<td style="text-align:left">eventhandle</td>
<td style="text-align:left"></td>
<td style="text-align:left">否</td>
<td style="text-align:left">动画完成事件</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.4.1</a></td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202401210046684.png" alt="image-20240121004604493" tabindex="0" loading="lazy"><figcaption>image-20240121004604493</figcaption></figure>
<h2> 表单组件</h2>
<blockquote>
<p>具体可以在官方文档查看</p>
</blockquote>
<h3> Button</h3>
<blockquote>
<p>https://developers.weixin.qq.com/miniprogram/dev/component/button.html</p>
<p>具体属性看官方文档, 可以通过 <code>open-type</code> 配置分享, 打开交流窗口等等功能</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202401212153960.png" alt="image-20240121215332766" tabindex="0" loading="lazy"><figcaption>image-20240121215332766</figcaption></figure>
<h2> 导航组件</h2>
<h3> navigator</h3>
<blockquote>
<p>https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html</p>
<p>navigator组件相当于HTML的超链接标签。</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 媒体组件</h2>
<h3> image</h3>
<blockquote>
<p>https://developers.weixin.qq.com/miniprogram/dev/component/image.html</p>
</blockquote>
<p>为了保证大小, 可以使用裁剪或者缩放调整大小</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">必填</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">最低版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">show-menu-by-longpress</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">否</td>
<td style="text-align:left">长按图片显示发送给朋友、收藏、保存图片、搜一搜、打开名片/前往群聊/打开小程序（若图片中包含对应二维码或小程序码）的菜单。</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.7.0</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">mode</td>
<td style="text-align:left">string</td>
<td style="text-align:left">scaleToFill</td>
<td style="text-align:left">否</td>
<td style="text-align:left">图片裁剪、缩放的模式</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.0.0</a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">合法值</td>
<td style="text-align:left">说明</td>
<td style="text-align:left">最低版本</td>
</tr>
<tr>
<td style="text-align:left">scaleToFill</td>
<td style="text-align:left">缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">aspectFit</td>
<td style="text-align:left">缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">aspectFill</td>
<td style="text-align:left">缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">widthFix</td>
<td style="text-align:left">缩放模式，宽度不变，高度自动变化，保持原图宽高比不变</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">heightFix</td>
<td style="text-align:left">缩放模式，高度不变，宽度自动变化，保持原图宽高比不变</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.10.3</a></td>
</tr>
<tr>
<td style="text-align:left">top</td>
<td style="text-align:left">裁剪模式，不缩放图片，只显示图片的顶部区域。仅 Webview 支持。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">bottom</td>
<td style="text-align:left">裁剪模式，不缩放图片，只显示图片的底部区域。仅 Webview 支持。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">center</td>
<td style="text-align:left">裁剪模式，不缩放图片，只显示图片的中间区域。仅 Webview 支持。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">left</td>
<td style="text-align:left">裁剪模式，不缩放图片，只显示图片的左边区域。仅 Webview 支持。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">right</td>
<td style="text-align:left">裁剪模式，不缩放图片，只显示图片的右边区域。仅 Webview 支持。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">top left</td>
<td style="text-align:left">裁剪模式，不缩放图片，只显示图片的左上边区域。仅 Webview 支持。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">top right</td>
<td style="text-align:left">裁剪模式，不缩放图片，只显示图片的右上边区域。仅 Webview 支持。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">bottom left</td>
<td style="text-align:left">裁剪模式，不缩放图片，只显示图片的左下边区域。仅 Webview 支持。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">bottom right</td>
<td style="text-align:left">裁剪模式，不缩放图片，只显示图片的右下边区域。仅 Webview 支持。</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>可以在 https://developers.weixin.qq.com/miniprogram/dev/component/image.html#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81 查看示例代码</p>
</blockquote>
<h2> 地图组件</h2>
<blockquote>
<p>https://developers.weixin.qq.com/miniprogram/dev/component/map.html</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202401201614793.png" type="image/png"/>
    </item>
    <item>
      <title>微信小程序介绍</title>
      <link>https://brain.sunguoqi.com/web/weChat/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://brain.sunguoqi.com/web/weChat/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">微信小程序介绍</source>
      <description>微信小程序介绍 微信小程序介绍 ​	微信小程序，简称小程序，是一种不需要下载安装即可使用的应用，它实现了应用”触手可及”的梦想，用户扫一扫或搜一下即可打开应用。 ​	说明： 小程序是需要下载的，小程序的占用大小很小，感觉不到下载 目前大小限制2M （最终开发的小程序打包压缩后的大小），如果超过2M,就得做分包上传.之后再合并 进入小程序后继续网络请求数据 小程序特点 微信小程序的特点： 免安装 接近原生（IOS，Android ）的app操作基于微信开发。使用wx提供的api开发 必须在微信里面使用</description>
      <pubDate>Fri, 19 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 微信小程序介绍</h2>
<h3> 微信小程序介绍</h3>
<p>​	微信小程序，简称小程序，是一种不需要下载安装即可使用的应用，它实现了应用”触手可及”的梦想，用户扫一扫或搜一下即可打开应用。</p>
<p>​	说明：</p>
<ul>
<li>小程序是需要下载的，小程序的占用大小很小，感觉不到下载</li>
<li>目前大小限制2M （最终开发的小程序打包压缩后的大小），如果超过2M,就得做分包上传.之后再合并</li>
<li>进入小程序后继续网络请求数据</li>
</ul>
<h3> 小程序特点</h3>
<p>微信小程序的特点：</p>
<ul>
<li>免安装</li>
<li>接近原生（IOS，Android ）的app操作基于微信开发。使用wx提供的api开发</li>
<li>必须在微信里面使用</li>
</ul>
<h3> 小程序的优缺点</h3>
<ul>
<li><mark>方便快捷，即用即走</mark></li>
<li><mark>速度快、不占内存</mark></li>
<li>安全稳定、保密性强</li>
<li>功能丰富，场景丰富</li>
<li><mark>开发成本低、维护简便</mark></li>
<li><mark>开发周期比较短</mark></li>
<li>体验好</li>
</ul>
<h3> 小程序开发需求</h3>
<ul>
<li>不注册可以开发小程序(不能发布)</li>
<li>注册小程序
<ul>
<li>企业注册(公司内部人员注册好了，给一个APPID)</li>
<li>个人注册</li>
</ul>
</li>
</ul>
<h3> 微信小程序的注册</h3>
<p>微信公众平台：https://mp.weixin.qq.com/</p>
<h2> 开发工具</h2>
<p>开发工具下载地址：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</p>
<figure><img src="https://qiniu.waite.wang/202401192149328.png" alt="image-20220122170116175" tabindex="0" loading="lazy"><figcaption>image-20220122170116175</figcaption></figure>
<h3> 开发者工具的使用</h3>
<figure><img src="https://qiniu.waite.wang/202401192150079.png" alt="image-20220122201456358" tabindex="0" loading="lazy"><figcaption>image-20220122201456358</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202401192150318.png" alt="image-20220608183526635" tabindex="0" loading="lazy"><figcaption>image-20220608183526635</figcaption></figure>
<blockquote>
<p>以下就是微信小程序开发工具的界面，主要有：微信小程序模拟器、项目目录、代码编写区域、控制台。</p>
</blockquote>
<h2> 项目目录结构介绍</h2>
<figure><img src="https://qiniu.waite.wang/202401192154095.png" alt="image-20240119215440525" tabindex="0" loading="lazy"><figcaption>image-20240119215440525</figcaption></figure>
<h3> pages目录</h3>
<p>​	pages目录下放的就是小程序中的各个页面。</p>
<p>​	在pages中创建页面的时候，会出现4个文件：</p>
<ul>
<li>xxx.js：页面相关的js代码可以写在这里</li>
<li>xxx.wxml：这个就是页面文件，相当于我们之前的HTML，所以页面结构内容写在这里</li>
<li>xxx.wxss：页面的样式内容，相当于之前的css，所以页面相关的样式可以写在这里</li>
<li>xxx.json：页面有关的配置，比如页面导航栏的背景色、内容等等</li>
</ul>
<p>比如：	<img src="https://qiniu.waite.wang/202401192151123.png" alt="10" loading="lazy"></p>
<h3> app.js文件</h3>
<p>​	app.js文件是整个项目的一个<mark>总体配置</mark>。里面包含了项目运行<mark>生命周期的回调函数</mark>。</p>
<h3> app.json文件</h3>
<p>​	小程序根目录下的 <code>app.json</code> 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。</p>
<p>小程序根目录下的 <code>app.json</code> 文件用来对微信小程序进行全局配置。文件内容为一个 JSON 对象，有以下属性：</p>
<p>https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html</p>
<figure><img src="https://qiniu.waite.wang/202401192155179.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> app.wxss文件</h3>
<ul>
<li>app.wxss 文件是微信小程序项目的<mark>全局样式表</mark>，它可以应用到所有的wxml文件中。</li>
<li>微信小程序中使用 rpx 作为长度单位。1rpx = 1/750 屏幕宽度。也就是屏幕宽度等于 750rpx。</li>
<li>px 也可以使用，表示的是设备独立像素。</li>
<li>建议使用长度单位 rpx。它自动做了适配。</li>
</ul>
<h3> project.config.json文件</h3>
<p>​	<code>project.config.json</code>文件是小程序项目的配置文件（如开发工具的外观配置），一般不需要修改，我们目前就改一个地方：</p>
<figure><img src="https://qiniu.waite.wang/202401192153939.png" alt="11" tabindex="0" loading="lazy"><figcaption>11</figcaption></figure>
<p><code>"checkSiteMap":false</code> 作用是<mark>控制台不要有一些没用的警告</mark>。</p>
<h3> Sitemap.json</h3>
<p>https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html</p>
<p>搜索功能文件，指定哪些页面可以被搜索，可被配置。是在搜索小程序的时候，指定哪些页面允许被搜索到。</p>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202401192149328.png" type="image/png"/>
    </item>
    <item>
      <title>微信小程序配置项</title>
      <link>https://brain.sunguoqi.com/web/weChat/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE.html</link>
      <guid>https://brain.sunguoqi.com/web/weChat/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">微信小程序配置项</source>
      <description>全局配置 https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#entryPagePath 小程序根目录下的 app.json 文件用来对微信小程序进行全局配置。文件内容为一个 JSON 对象，有以下属性： 属性 类型 必填 描述 最低版本 entryPagePath string 否 小程序默认启动首页 pages string[] 是 页面路径列表 window Object 否 全局的默认窗口表现 tabBar Object 否 底部 tab 栏的表现 networkTimeout Object 否 网络超时时间 debug boolean 否 是否开启 debug 模式，默认关闭 functionalPages boolean 否 是否启用插件功能页，默认关闭 2.1.0 subpackages Object[] 否 分包结构配置 1.7.3 workers string 否 Worker 代码放置的目录 1.9.90 requiredBackgroundModes string[] 否 需要在后台使用的能力，如「音乐播放」 requiredPrivateInfos string[] 否 调用的地理位置相关隐私接口 plugins Object 否 使用到的插件 1.9.6 preloadRule Object 否 分包预下载规则 2.3.0 resizable boolean 否 PC 小程序是否支持用户任意改变窗口大小（包括最大化窗口）；iPad 小程序是否支持屏幕旋转。默认关闭 2.3.0 usingComponents Object 否 全局自定义组件配置 开发者工具 1.02.1810190 permission Object 否 小程序接口权限相关设置 微信客户端 7.0.0 sitemapLocation string 是 指明 sitemap.json 的位置 style string 否 指定使用升级后的weui样式 2.8.0 useExtendedLib Object 否 指定需要引用的扩展库 2.2.1 entranceDeclare Object 否 微信消息用小程序打开 微信客户端 7.0.9 darkmode boolean 否 小程序支持 DarkMode 2.11.0 themeLocation string 否 指明 theme.json 的位置，darkmode为true为必填 开发者工具 1.03.2004271 lazyCodeLoading string 否 配置自定义组件代码按需注入 2.11.1 singlePage Object 否 单页模式相关配置 2.12.0 supportedMaterials Object 否 聊天素材小程序打开相关配置 2.14.3 serviceProviderTicket string 否 定制化型服务商票据 embeddedAppIdList string[] 否 半屏小程序 appId 2.20.1 halfPage Object 否 视频号直播半屏场景设置 2.18.0 debugOptions Object 否 调试相关配置 2.22.1 enablePassiveEvent Object或boolean 否 touch 事件监听是否为 passive 2.24.1 resolveAlias Object 否 自定义模块映射规则 renderer string 否 全局默认的渲染后端 2.30.4 rendererOptions Object 否 渲染后端选项 2.31.1 componentFramework string 否 组件框架，详见相关文档 2.30.4 miniApp Object 否 多端模式场景接入身份管理服务时开启小程序授权页相关配置，详见相关文档 static Object 否 正常情况下默认所有资源文件都被打包发布到所有平台，可以通过 static 字段配置特定每个目录/文件只能发布到特定的平台(多端场景) 相关文档 convertRpxToVw boolean 否 配置是否将 rpx 单位转换为 vw 单位，开启后能修复某些 rpx 下的精度问题 3.3.0</description>
      <pubDate>Sat, 20 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 全局配置</h2>
<blockquote>
<p>https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#entryPagePath</p>
</blockquote>
<p>小程序根目录下的 <code>app.json</code> 文件用来对微信小程序进行全局配置。文件内容为一个 JSON 对象，有以下属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">必填</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">最低版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#entryPagePath" target="_blank" rel="noopener noreferrer">entryPagePath</a></td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left">小程序默认启动首页</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#pages" target="_blank" rel="noopener noreferrer">pages</a></td>
<td style="text-align:left">string[]</td>
<td style="text-align:left">是</td>
<td style="text-align:left">页面路径列表</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#window" target="_blank" rel="noopener noreferrer">window</a></td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">全局的默认窗口表现</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar" target="_blank" rel="noopener noreferrer">tabBar</a></td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">底部 <code>tab</code> 栏的表现</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#networkTimeout" target="_blank" rel="noopener noreferrer">networkTimeout</a></td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">网络超时时间</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#debug" target="_blank" rel="noopener noreferrer">debug</a></td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是否开启 debug 模式，默认关闭</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#functionalPages" target="_blank" rel="noopener noreferrer">functionalPages</a></td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是否启用插件功能页，默认关闭</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.1.0</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#subpackages" target="_blank" rel="noopener noreferrer">subpackages</a></td>
<td style="text-align:left">Object[]</td>
<td style="text-align:left">否</td>
<td style="text-align:left">分包结构配置</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.7.3</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#workers" target="_blank" rel="noopener noreferrer">workers</a></td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><code>Worker</code> 代码放置的目录</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.9.90</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#requiredBackgroundModes" target="_blank" rel="noopener noreferrer">requiredBackgroundModes</a></td>
<td style="text-align:left">string[]</td>
<td style="text-align:left">否</td>
<td style="text-align:left">需要在后台使用的能力，如「音乐播放」</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#requiredPrivateInfos" target="_blank" rel="noopener noreferrer">requiredPrivateInfos</a></td>
<td style="text-align:left">string[]</td>
<td style="text-align:left">否</td>
<td style="text-align:left">调用的地理位置相关隐私接口</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#plugins" target="_blank" rel="noopener noreferrer">plugins</a></td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">使用到的插件</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.9.6</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#preloadRule" target="_blank" rel="noopener noreferrer">preloadRule</a></td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">分包预下载规则</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.3.0</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#resizable" target="_blank" rel="noopener noreferrer">resizable</a></td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">否</td>
<td style="text-align:left">PC 小程序是否支持用户任意改变窗口大小（包括最大化窗口）；iPad 小程序是否支持屏幕旋转。默认关闭</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.3.0</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#usingComponents" target="_blank" rel="noopener noreferrer">usingComponents</a></td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">全局<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/" target="_blank" rel="noopener noreferrer">自定义组件</a>配置</td>
<td style="text-align:left">开发者工具 1.02.1810190</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#permission" target="_blank" rel="noopener noreferrer">permission</a></td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">小程序接口权限相关设置</td>
<td style="text-align:left">微信客户端 7.0.0</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#sitemapLocation" target="_blank" rel="noopener noreferrer">sitemapLocation</a></td>
<td style="text-align:left">string</td>
<td style="text-align:left">是</td>
<td style="text-align:left">指明 sitemap.json 的位置</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#style" target="_blank" rel="noopener noreferrer">style</a></td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left">指定使用升级后的weui样式</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.8.0</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#useextendedlib" target="_blank" rel="noopener noreferrer">useExtendedLib</a></td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">指定需要引用的扩展库</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.2.1</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#entranceDeclare" target="_blank" rel="noopener noreferrer">entranceDeclare</a></td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">微信消息用小程序打开</td>
<td style="text-align:left">微信客户端 7.0.9</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#darkmode" target="_blank" rel="noopener noreferrer">darkmode</a></td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">否</td>
<td style="text-align:left">小程序支持 DarkMode</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.11.0</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#themeLocation" target="_blank" rel="noopener noreferrer">themeLocation</a></td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left">指明 theme.json 的位置，darkmode为true为必填</td>
<td style="text-align:left">开发者工具 1.03.2004271</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#lazyCodeLoading" target="_blank" rel="noopener noreferrer">lazyCodeLoading</a></td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left">配置自定义组件代码按需注入</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.11.1</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#singlePage" target="_blank" rel="noopener noreferrer">singlePage</a></td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">单页模式相关配置</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.12.0</a></td>
</tr>
<tr>
<td style="text-align:left">supportedMaterials</td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/material/support_material.html" target="_blank" rel="noopener noreferrer">聊天素材小程序打开</a>相关配置</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.14.3</a></td>
</tr>
<tr>
<td style="text-align:left">serviceProviderTicket</td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/operation/thirdparty/customized_service_platform_guidelines.html" target="_blank" rel="noopener noreferrer">定制化型服务商</a>票据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#embeddedAppIdList" target="_blank" rel="noopener noreferrer">embeddedAppIdList</a></td>
<td style="text-align:left">string[]</td>
<td style="text-align:left">否</td>
<td style="text-align:left">半屏小程序 appId</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.20.1</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#halfPage" target="_blank" rel="noopener noreferrer">halfPage</a></td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">视频号直播半屏场景设置</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.18.0</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#debugOptions" target="_blank" rel="noopener noreferrer">debugOptions</a></td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">调试相关配置</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.22.1</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#enablePassiveEvent" target="_blank" rel="noopener noreferrer">enablePassiveEvent</a></td>
<td style="text-align:left">Object或boolean</td>
<td style="text-align:left">否</td>
<td style="text-align:left">touch 事件监听是否为 passive</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.24.1</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#resolveAlias" target="_blank" rel="noopener noreferrer">resolveAlias</a></td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">自定义模块映射规则</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#renderer" target="_blank" rel="noopener noreferrer">renderer</a></td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left">全局默认的渲染后端</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.30.4</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#rendererOptions" target="_blank" rel="noopener noreferrer">rendererOptions</a></td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">渲染后端选项</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.31.1</a></td>
</tr>
<tr>
<td style="text-align:left">componentFramework</td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left">组件框架，详见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/glass-easel/migration.html" target="_blank" rel="noopener noreferrer">相关文档</a></td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.30.4</a></td>
</tr>
<tr>
<td style="text-align:left">miniApp</td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">多端模式场景接入身份管理服务时开启小程序授权页相关配置，详见<a href="https://dev.weixin.qq.com/docs/framework/getting_started/auth.html#_4%E3%80%81%E5%BC%80%E5%90%AF%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%88%E6%9D%83%E9%A1%B5" target="_blank" rel="noopener noreferrer">相关文档</a></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">static</td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">正常情况下默认所有资源文件都被打包发布到所有平台，可以通过 static 字段配置特定每个目录/文件只能发布到特定的平台(多端场景) <a href="https://dev.weixin.qq.com/docs/framework/guideline/devtools/condition-compile.html#%E8%B5%84%E6%BA%90" target="_blank" rel="noopener noreferrer">相关文档</a></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">convertRpxToVw</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">否</td>
<td style="text-align:left">配置是否将 rpx 单位转换为 vw 单位，开启后能修复某些 rpx 下的精度问题</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">3.3.0</a></td>
</tr>
</tbody>
</table>
<blockquote>
<p>以下简单列举了一部分, 其他未列举可以在官方文档中查看</p>
</blockquote>
<h3> entryPagePath</h3>
<p>指定小程序的默认启动路径（首页），常见情景是从微信聊天列表页下拉启动、小程序列表启动等。如果不填，将默认为 <code>pages</code> 列表的第一项。不支持带页面路径参数。</p>
<h3> pages</h3>
<p>用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的 <code>.json</code>, <code>.js</code>, <code>.wxml</code>, <code>.wxss</code> 四个文件进行处理。</p>
<p>未指定 <code>entryPagePath</code> 时，数组的第一项代表小程序的初始页面（首页）。</p>
<p><strong>小程序中新增/减少页面，都需要对 pages 数组进行修改。</strong></p>
<p>则需要在 app.json 中写</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> window</h3>
<p>用于设置小程序的状态栏、导航条、标题、窗口背景色。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">最低版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">navigationBarBackgroundColor</td>
<td style="text-align:left">HexColor</td>
<td style="text-align:left">#000000</td>
<td style="text-align:left">导航栏背景颜色，如 <code>#000000</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">navigationBarTextStyle</td>
<td style="text-align:left">string</td>
<td style="text-align:left">white</td>
<td style="text-align:left">导航栏标题、状态栏颜色，仅支持 <code>black</code> / <code>white</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">navigationBarTitleText</td>
<td style="text-align:left">string</td>
<td style="text-align:left"></td>
<td style="text-align:left">导航栏标题文字内容</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">navigationStyle</td>
<td style="text-align:left">string</td>
<td style="text-align:left">default</td>
<td style="text-align:left">导航栏样式，仅支持以下值： <code>default</code> 默认样式 <code>custom</code> 自定义导航栏，只保留右上角胶囊按钮。参见注 2。</td>
<td style="text-align:left">iOS/Android 微信客户端 6.6.0，Windows 微信客户端不支持</td>
</tr>
<tr>
<td style="text-align:left">homeButton</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">default</td>
<td style="text-align:left">在非首页、非页面栈最底层页面或非tabbar内页面中的导航栏展示home键</td>
<td style="text-align:left">微信客户端 8.0.24</td>
</tr>
<tr>
<td style="text-align:left">backgroundColor</td>
<td style="text-align:left">HexColor</td>
<td style="text-align:left">#ffffff</td>
<td style="text-align:left">窗口的背景色</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">backgroundTextStyle</td>
<td style="text-align:left">string</td>
<td style="text-align:left">dark</td>
<td style="text-align:left">下拉 loading 的样式，仅支持 <code>dark</code> / <code>light</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">backgroundColorTop</td>
<td style="text-align:left">string</td>
<td style="text-align:left">#ffffff</td>
<td style="text-align:left">顶部窗口的背景色，仅 iOS 支持</td>
<td style="text-align:left">微信客户端 6.5.16</td>
</tr>
<tr>
<td style="text-align:left">backgroundColorBottom</td>
<td style="text-align:left">string</td>
<td style="text-align:left">#ffffff</td>
<td style="text-align:left">底部窗口的背景色，仅 iOS 支持</td>
<td style="text-align:left">微信客户端 6.5.16</td>
</tr>
<tr>
<td style="text-align:left">enablePullDownRefresh</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">是否开启全局的下拉刷新。 详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onpulldownrefresh" target="_blank" rel="noopener noreferrer">Page.onPullDownRefresh</a></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">onReachBottomDistance</td>
<td style="text-align:left">number</td>
<td style="text-align:left">50</td>
<td style="text-align:left">页面上拉触底事件触发时距页面底部距离，单位为 px。 详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onreachbottom" target="_blank" rel="noopener noreferrer">Page.onReachBottom</a></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">pageOrientation</td>
<td style="text-align:left">string</td>
<td style="text-align:left">portrait</td>
<td style="text-align:left">屏幕旋转设置，支持 <code>auto</code> / <code>portrait</code> / <code>landscape</code> 详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html" target="_blank" rel="noopener noreferrer">响应显示区域变化</a></td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.4.0</a> (auto) / <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.5.0</a> (landscape)</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#restartStrategy" target="_blank" rel="noopener noreferrer">restartStrategy</a></td>
<td style="text-align:left">string</td>
<td style="text-align:left">homePage</td>
<td style="text-align:left">重新启动策略配置</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.8.0</a></td>
</tr>
<tr>
<td style="text-align:left">initialRenderingCache</td>
<td style="text-align:left">string</td>
<td style="text-align:left"></td>
<td style="text-align:left">页面<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html" target="_blank" rel="noopener noreferrer">初始渲染缓存</a>配置，支持 <code>static</code> / <code>dynamic</code></td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.11.1</a></td>
</tr>
<tr>
<td style="text-align:left">visualEffectInBackground</td>
<td style="text-align:left">string</td>
<td style="text-align:left">none</td>
<td style="text-align:left">切入系统后台时，隐藏页面内容，保护用户隐私。支持 <code>hidden</code> / <code>none</code></td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.15.0</a></td>
</tr>
<tr>
<td style="text-align:left">handleWebviewPreload</td>
<td style="text-align:left">string</td>
<td style="text-align:left">static</td>
<td style="text-align:left">控制<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/runtime_nav.html#_2-4-%E6%8E%A7%E5%88%B6%E9%A2%84%E5%8A%A0%E8%BD%BD%E4%B8%8B%E4%B8%AA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA" target="_blank" rel="noopener noreferrer">预加载下个页面的时机</a>。支持 <code>static</code> / <code>manual</code> / <code>auto</code></td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.15.0</a></td>
</tr>
</tbody>
</table>
<p>如：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202401201548556.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h3> tabBar</h3>
<p>如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">必填</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">最低版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">color</td>
<td style="text-align:left">HexColor</td>
<td style="text-align:left">是</td>
<td style="text-align:left"></td>
<td style="text-align:left">tab 上的文字默认颜色，仅支持十六进制颜色</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">selectedColor</td>
<td style="text-align:left">HexColor</td>
<td style="text-align:left">是</td>
<td style="text-align:left"></td>
<td style="text-align:left">tab 上的文字选中时的颜色，仅支持十六进制颜色</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">backgroundColor</td>
<td style="text-align:left">HexColor</td>
<td style="text-align:left">是</td>
<td style="text-align:left"></td>
<td style="text-align:left">tab 的背景色，仅支持十六进制颜色</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">borderStyle</td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left">black</td>
<td style="text-align:left">tabbar 上边框的颜色， 仅支持 <code>black</code> / <code>white</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">list</td>
<td style="text-align:left">Array</td>
<td style="text-align:left">是</td>
<td style="text-align:left"></td>
<td style="text-align:left">tab 的列表，详见 <code>list</code> 属性说明，最少 2 个、最多 5 个 tab</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">position</td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left">bottom</td>
<td style="text-align:left">tabBar 的位置，仅支持 <code>bottom</code> / <code>top</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">custom</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">否</td>
<td style="text-align:left">false</td>
<td style="text-align:left">自定义 tabBar，见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html" target="_blank" rel="noopener noreferrer">详情</a></td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.5.0</a></td>
</tr>
</tbody>
</table>
<p>其中 list 接受一个数组，<strong>只能配置最少 2 个、最多 5 个 tab</strong>。tab 按数组的顺序排序，每个项都是一个对象，其属性值如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">必填</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">pagePath</td>
<td style="text-align:left">string</td>
<td style="text-align:left">是</td>
<td style="text-align:left">页面路径，必须在 pages 中先定义</td>
</tr>
<tr>
<td style="text-align:left">text</td>
<td style="text-align:left">string</td>
<td style="text-align:left">是</td>
<td style="text-align:left">tab 上按钮文字</td>
</tr>
<tr>
<td style="text-align:left">iconPath</td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left">图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。 <strong>当 <code>position</code> 为 <code>top</code> 时，不显示 icon。</strong></td>
</tr>
<tr>
<td style="text-align:left">selectedIconPath</td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left">选中时的图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。 <strong>当 <code>position</code> 为 <code>top</code> 时，不显示 icon。</strong></td>
</tr>
</tbody>
</table>
<figure><img src="https://qiniu.waite.wang/202401201556765.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<blockquote>
<p>以下是一个简单示例</p>
</blockquote>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202401201601641.png" alt="image-20240120160151572" tabindex="0" loading="lazy"><figcaption>image-20240120160151572</figcaption></figure>
<h3> networkTimeout</h3>
<p>各类网络请求的超时时间，单位均为毫秒。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">必填</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">request</td>
<td style="text-align:left">number</td>
<td style="text-align:left">否</td>
<td style="text-align:left">60000</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html" target="_blank" rel="noopener noreferrer">wx.request</a> 的超时时间，单位：毫秒。</td>
</tr>
<tr>
<td style="text-align:left">connectSocket</td>
<td style="text-align:left">number</td>
<td style="text-align:left">否</td>
<td style="text-align:left">60000</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/websocket/wx.connectSocket.html" target="_blank" rel="noopener noreferrer">wx.connectSocket</a> 的超时时间，单位：毫秒。</td>
</tr>
<tr>
<td style="text-align:left">uploadFile</td>
<td style="text-align:left">number</td>
<td style="text-align:left">否</td>
<td style="text-align:left">60000</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/upload/wx.uploadFile.html" target="_blank" rel="noopener noreferrer">wx.uploadFile</a> 的超时时间，单位：毫秒。</td>
</tr>
<tr>
<td style="text-align:left">downloadFile</td>
<td style="text-align:left">number</td>
<td style="text-align:left">否</td>
<td style="text-align:left">60000</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/download/wx.downloadFile.html" target="_blank" rel="noopener noreferrer">wx.downloadFile</a> 的超时时间，单位：毫秒</td>
</tr>
</tbody>
</table>
<h3> debug</h3>
<p>可以在开发者工具中开启 <code>debug</code> 模式，在开发者工具的控制台面板，调试信息以 <code>info</code> 的形式给出，其信息有 Page 的注册，页面路由，数据更新，事件触发等。可以帮助开发者快速定位一些常见的问题。</p>
<h2> 页面配置</h2>
<p>app.json 中的部分配置，也支持对单个页面进行配置，可以在页面对应的 <code>.json</code> 文件来对本页面的表现进行配置。</p>
<p>页面中配置项在当前页面会覆盖 <code>app.json</code> 中相同的配置项（样式相关的配置项属于 <code>app.json</code> 中的 <code>window</code> 属性，但这里不需要额外指定 <code>window</code> 字段），具体的取值和含义可参考<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html" target="_blank" rel="noopener noreferrer">全局配置文档</a>中说明。</p>
<p>文件内容为一个 JSON 对象，有以下属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">最低版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">navigationBarBackgroundColor</td>
<td style="text-align:left">HexColor</td>
<td style="text-align:left">#000000</td>
<td style="text-align:left">导航栏背景颜色，如 <code>#000000</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">navigationBarTextStyle</td>
<td style="text-align:left">string</td>
<td style="text-align:left">white</td>
<td style="text-align:left">导航栏标题、状态栏颜色，仅支持 <code>black</code> / <code>white</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">navigationBarTitleText</td>
<td style="text-align:left">string</td>
<td style="text-align:left"></td>
<td style="text-align:left">导航栏标题文字内容</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">navigationStyle</td>
<td style="text-align:left">string</td>
<td style="text-align:left">default</td>
<td style="text-align:left">导航栏样式，仅支持以下值： <code>default</code> 默认样式 <code>custom</code> 自定义导航栏，只保留右上角胶囊按钮。</td>
<td style="text-align:left">iOS/Android 微信客户端 7.0.0，Windows 微信客户端不支持</td>
</tr>
<tr>
<td style="text-align:left">homeButton</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">在非首页、非页面栈最底层页面或非tabbar内页面中的导航栏展示home键</td>
<td style="text-align:left">微信客户端 8.0.24</td>
</tr>
<tr>
<td style="text-align:left">backgroundColor</td>
<td style="text-align:left">HexColor</td>
<td style="text-align:left">#ffffff</td>
<td style="text-align:left">窗口的背景色</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">backgroundColorContent</td>
<td style="text-align:left">HexColor</td>
<td style="text-align:left">#RRGGBBAA</td>
<td style="text-align:left">页面容器背景色，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/custom-route.html#%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E9%80%8F%E6%98%8E" target="_blank" rel="noopener noreferrer">点击查看设置背景色详情</a></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">backgroundTextStyle</td>
<td style="text-align:left">string</td>
<td style="text-align:left">dark</td>
<td style="text-align:left">下拉 loading 的样式，仅支持 <code>dark</code> / <code>light</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">backgroundColorTop</td>
<td style="text-align:left">string</td>
<td style="text-align:left">#ffffff</td>
<td style="text-align:left">顶部窗口的背景色，仅 iOS 支持</td>
<td style="text-align:left">微信客户端 6.5.16</td>
</tr>
<tr>
<td style="text-align:left">backgroundColorBottom</td>
<td style="text-align:left">string</td>
<td style="text-align:left">#ffffff</td>
<td style="text-align:left">底部窗口的背景色，仅 iOS 支持</td>
<td style="text-align:left">微信客户端 6.5.16</td>
</tr>
<tr>
<td style="text-align:left">enablePullDownRefresh</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">是否开启当前页面下拉刷新。 详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onpulldownrefresh" target="_blank" rel="noopener noreferrer">Page.onPullDownRefresh</a></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">onReachBottomDistance</td>
<td style="text-align:left">number</td>
<td style="text-align:left">50</td>
<td style="text-align:left">页面上拉触底事件触发时距页面底部距离，单位为px。 详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onreachbottom" target="_blank" rel="noopener noreferrer">Page.onReachBottom</a></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">pageOrientation</td>
<td style="text-align:left">string</td>
<td style="text-align:left">portrait</td>
<td style="text-align:left">屏幕旋转设置，支持 <code>auto</code> / <code>portrait</code> / <code>landscape</code> 详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html" target="_blank" rel="noopener noreferrer">响应显示区域变化</a></td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.4.0</a> (auto) / <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.5.0</a> (landscape)</td>
</tr>
<tr>
<td style="text-align:left">disableScroll</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
<td style="text-align:left">设置为 <code>true</code> 则页面整体不能上下滚动。 只在页面配置中有效，无法在 <code>app.json</code> 中设置</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">usingComponents</td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">页面<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/" target="_blank" rel="noopener noreferrer">自定义组件</a>配置</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">1.6.3</a></td>
</tr>
<tr>
<td style="text-align:left">initialRenderingCache</td>
<td style="text-align:left">string</td>
<td style="text-align:left"></td>
<td style="text-align:left">页面<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html" target="_blank" rel="noopener noreferrer">初始渲染缓存</a>配置，支持 <code>static</code> / <code>dynamic</code></td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.11.1</a></td>
</tr>
<tr>
<td style="text-align:left">style</td>
<td style="text-align:left">string</td>
<td style="text-align:left">default</td>
<td style="text-align:left">启用新版的组件样式</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.10.2</a></td>
</tr>
<tr>
<td style="text-align:left">singlePage</td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">单页模式相关配置</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.12.0</a></td>
</tr>
<tr>
<td style="text-align:left">restartStrategy</td>
<td style="text-align:left">string</td>
<td style="text-align:left">homePage</td>
<td style="text-align:left">重新启动策略配置</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.8.0</a></td>
</tr>
<tr>
<td style="text-align:left">handleWebviewPreload</td>
<td style="text-align:left">string</td>
<td style="text-align:left">static</td>
<td style="text-align:left">控制<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/runtime_nav.html#_2-4-%E6%8E%A7%E5%88%B6%E9%A2%84%E5%8A%A0%E8%BD%BD%E4%B8%8B%E4%B8%AA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA" target="_blank" rel="noopener noreferrer">预加载下个页面的时机</a>。支持 <code>static</code> / <code>manual</code> / <code>auto</code></td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.15.0</a></td>
</tr>
<tr>
<td style="text-align:left">visualEffectInBackground</td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left">切入系统后台时，隐藏页面内容，保护用户隐私。支持 <code>hidden</code> / <code>none</code>，若对页面单独设置则会覆盖全局的配置，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html" target="_blank" rel="noopener noreferrer">全局配置</a></td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.15.0</a></td>
</tr>
<tr>
<td style="text-align:left">enablePassiveEvent</td>
<td style="text-align:left">Object或boolean</td>
<td style="text-align:left">否</td>
<td style="text-align:left">事件监听是否为 passive，若对页面单独设置则会覆盖全局的配置，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html" target="_blank" rel="noopener noreferrer">全局配置</a></td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.24.1</a></td>
</tr>
<tr>
<td style="text-align:left">renderer</td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left">渲染后端</td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.30.4</a></td>
</tr>
<tr>
<td style="text-align:left">rendererOptions</td>
<td style="text-align:left">Object</td>
<td style="text-align:left">否</td>
<td style="text-align:left">渲染后端选项，详情<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html" target="_blank" rel="noopener noreferrer">相关文档</a></td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">3.1.0</a></td>
</tr>
<tr>
<td style="text-align:left">componentFramework</td>
<td style="text-align:left">string</td>
<td style="text-align:left">否</td>
<td style="text-align:left">组件框架，详情<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/glass-easel/migration.html" target="_blank" rel="noopener noreferrer">相关文档</a></td>
<td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.30.4</a></td>
</tr>
</tbody>
</table>
<ul>
<li>注：并不是所有 <code>app.json</code> 中的配置都可以在页面覆盖或单独指定，仅限于本文档包含的选项。</li>
<li>注：iOS/Android 客户端 7.0.0 以下版本，<code>navigationStyle</code> 只在 <code>app.json</code> 中生效。</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202401201608866.png" alt="image-20240120160819935" tabindex="0" loading="lazy"><figcaption>image-20240120160819935</figcaption></figure>
<h2> WXSS</h2>
<p>WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。</p>
<p>WXSS 用来决定 WXML 的组件应该怎么显示。</p>
<p>为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。</p>
<p>与 CSS 相比，WXSS 扩展的特性有：</p>
<ul>
<li>尺寸单位</li>
<li>样式导入</li>
</ul>
<h3> 尺寸单位</h3>
<ul>
<li>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">设备</th>
<th style="text-align:left">rpx换算px (屏幕宽度/750)</th>
<th style="text-align:left">px换算rpx (750/屏幕宽度)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">iPhone5</td>
<td style="text-align:left">1rpx = 0.42px</td>
<td style="text-align:left">1px = 2.34rpx</td>
</tr>
<tr>
<td style="text-align:left">iPhone6</td>
<td style="text-align:left">1rpx = 0.5px</td>
<td style="text-align:left">1px = 2rpx</td>
</tr>
<tr>
<td style="text-align:left">iPhone6 Plus</td>
<td style="text-align:left">1rpx = 0.552px</td>
<td style="text-align:left">1px = 1.81rpx</td>
</tr>
</tbody>
</table>
<p><strong>建议：</strong> 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。</p>
<p><strong>注意：</strong> 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。</p>
<h3> 样式导入</h3>
<p>使用<code>@import</code>语句可以导入外联样式表，<code>@import</code>后跟需要导入的外联样式表的相对路径，用<code>;</code>表示语句结束。</p>
<p><strong>示例代码：</strong></p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 内联样式</h3>
<p>框架组件上支持使用 style、class 属性来控制组件的样式。</p>
<ul>
<li>style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上<code>.</code>，样式类名之间用空格分隔。</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 选择器</h3>
<p>目前支持的选择器有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">样例</th>
<th style="text-align:left">样例描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">.class</td>
<td style="text-align:left"><code>.intro</code></td>
<td style="text-align:left">选择所有拥有 class="intro" 的组件</td>
</tr>
<tr>
<td style="text-align:left">#id</td>
<td style="text-align:left"><code>#firstname</code></td>
<td style="text-align:left">选择拥有 id="firstname" 的组件</td>
</tr>
<tr>
<td style="text-align:left">element</td>
<td style="text-align:left"><code>view</code></td>
<td style="text-align:left">选择所有 view 组件</td>
</tr>
<tr>
<td style="text-align:left">element, element</td>
<td style="text-align:left"><code>view, checkbox</code></td>
<td style="text-align:left">选择所有文档的 view 组件和所有的 checkbox 组件</td>
</tr>
<tr>
<td style="text-align:left">::after</td>
<td style="text-align:left"><code>view::after</code></td>
<td style="text-align:left">在 view 组件后边插入内容</td>
</tr>
<tr>
<td style="text-align:left">::before</td>
<td style="text-align:left"><code>view::before</code></td>
<td style="text-align:left">在 view 组件前边插入内容</td>
</tr>
</tbody>
</table>
<h3> 全局样式与局部样式</h3>
<p>定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。</p>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202401201548556.jpeg" type="image/jpeg"/>
    </item>
    <item>
      <title>Pinia</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/store/pinia.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/store/pinia.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Pinia</source>
      <description>为什么使用 Pinia? https://pinia.vuejs.org/zh/ Pinia 是 Vue 的专属状态管理库，它允许你跨组件或页面共享状态。如果你熟悉组合式 API 的话，你可能会认为可以通过一行简单的 export const state = reactive({}) 来共享一个全局状态。对于单页应用来说确实可以，但如果应用在服务器端渲染，这可能会使你的应用暴露出一些安全漏洞。 而如果使用 Pinia，即使在小型单页应用中，你也可以获得如下功能： Devtools 支持 追踪 actions、mutations 的时间线 在组件中展示它们所用到的 Store 让调试更容易的 Time travel 热更新 不必重载页面即可修改 Store 开发时可保持当前的 State 插件：可通过插件扩展 Pinia 功能 为 JS 开发者提供适当的 TypeScript 支持以及自动补全功能。 支持服务端渲染</description>
      <pubDate>Wed, 27 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 为什么使用 Pinia?</h2>
<blockquote>
<p>https://pinia.vuejs.org/zh/</p>
</blockquote>
<p>Pinia 是 Vue 的专属状态管理库，它允许你跨组件或页面共享状态。如果你熟悉组合式 API 的话，你可能会认为可以通过一行简单的 <code>export const state = reactive({})</code> 来共享一个全局状态。对于单页应用来说确实可以，但如果应用在服务器端渲染，这可能会使你的应用暴露出一些安全漏洞。 而如果使用 Pinia，即使在小型单页应用中，你也可以获得如下功能：</p>
<ul>
<li>Devtools 支持
<ul>
<li>追踪 actions、mutations 的时间线</li>
<li>在组件中展示它们所用到的 Store</li>
<li>让调试更容易的 Time travel</li>
</ul>
</li>
<li>热更新
<ul>
<li>不必重载页面即可修改 Store</li>
<li>开发时可保持当前的 State</li>
</ul>
</li>
<li>插件：可通过插件扩展 Pinia 功能</li>
<li>为 JS 开发者提供适当的 TypeScript 支持以及<strong>自动补全</strong>功能。</li>
<li>支持服务端渲染</li>
</ul>
<h2> 简单使用</h2>
<ol>
<li>安装</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在mian.js中，创建根存储</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>创建store</li>
</ol>
<p><code>store</code>实例相当于一个容器，里面存放的有类似于<code>data</code>，计算属性，方法之类的东西。通过<code>defineStore()</code>方法定义</p>
<p>在<code>src</code>下面创建一个<code>store</code>文件夹，再创建与之对应的<code>js</code>文件，比如``counter.js`</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>使用store</li>
</ol>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> State</h2>
<ol>
<li>读取state</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>修改state</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="3">
<li>重置 state</li>
</ol>
<p>使用<a href="https://pinia.vuejs.org/zh/core-concepts/#option-stores" target="_blank" rel="noopener noreferrer">选项式 API</a> 时，你可以通过调用 store 的 <code>$reset()</code> 方法将 state 重置为初始值。</p>
<p>在 <code>$reset()</code> 内部，会调用 <code>state()</code> 函数来创建一个新的状态对象，并用它替换当前状态。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>变更 state</li>
</ol>
<p>除了用 <code>store.count++</code> 直接改变 store，你还可以调用 <code>$patch</code> 方法。它允许你用一个 <code>state</code> 的补丁对象在同一时间更改多个属性：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过，用这种语法的话，有些变更真的很难实现或者很耗时：任何集合的修改（例如，向数组中添加、移除一个元素或是做 <code>splice</code> 操作）都需要你创建一个新的集合。因此，<code>$patch</code> 方法也接受一个函数来组合这种难以用补丁对象实现的变更。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两种变更 store 方法的主要区别是，<code>$patch()</code> 允许你将多个变更归入 <code>devtools</code> 的同一个条目中</p>
<blockquote>
<p>你可以在 <code>pinia</code> 实例上使用 <code>watch()</code> 函数侦听整个 state。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote>
<h2> getters</h2>
<ol>
<li>基础使用</li>
</ol>
<p>类似计算属性。推荐里面传递一个形参的写法，不容易出错。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>调用本模块其他 getters</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>getters传参</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="4">
<li>调用其他store里面的getter</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> actions</h2>
<p>Action 相当于组件中的 <a href="https://v3.vuejs.org/guide/data-methods.html#methods" target="_blank" rel="noopener noreferrer">method</a>。它们可以通过 <code>defineStore()</code> 中的 <code>actions</code> 属性来定义，<strong>并且它们也是定义业务逻辑的完美选择。</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类似 <a href="https://pinia.vuejs.org/zh/core-concepts/getters.html" target="_blank" rel="noopener noreferrer">getter</a>，action 也可通过 <code>this</code> 访问<strong>整个 store 实例</strong>，并支持<strong>完整的类型标注(以及自动补全✨)</strong>。<strong>不同的是，<code>action</code> 可以是异步的</strong>，你可以在它们里面 <code>await</code> 调用任何 API，以及其他 action！下面是一个使用 <a href="https://github.com/posva/mande" target="_blank" rel="noopener noreferrer">Mande</a> 的例子。请注意，你使用什么库并不重要，只要你得到的是一个<code>Promise</code>，你甚至可以 (在浏览器中) 使用原生 <code>fetch</code> 函数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你也完全可以自由地设置任何你想要的参数以及返回任何结果。当调用 action 时，一切类型也都是可以被自动推断出来的。</p>
<p>Action 可以像函数或者通常意义上的方法一样被调用：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>想要使用另一个 store 的话，那你直接在 <em>action</em> 中调用就好了：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 模块化</h2>
<p>在实际开发中，不可能把多个模块的数据都定义到一个store中，而是一个模块对应一个store，最后通过一个根store进行整合</p>
<p>1.随便建立两个store，并导出</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>新建store/index.js</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>组件中使用</li>
</ol>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Vue2-Vuex</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/store/vue2_vux.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/store/vue2_vux.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Vue2-Vuex</source>
      <description>Day01_vuex 今日学习目标(边讲边练) 跨组件通信能力 vuex的基础使用 购物车案例-改装 1.vuex介绍 目标 什么是vuex 为什么学习vuex 通信方案</description>
      <pubDate>Sun, 24 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Day01_vuex</h1>
<h2> 今日学习目标(边讲边练)</h2>
<ul>
<li>跨组件通信能力</li>
<li>vuex的基础使用</li>
<li>购物车案例-改装</li>
</ul>
<h2> 1.vuex介绍</h2>
<h3> 目标</h3>
<ul>
<li>什么是vuex</li>
<li>为什么学习vuex</li>
</ul>
<h3> 通信方案</h3>
<figure><img src="https://qiniu.waite.wang/202312242346950.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<table>
<thead>
<tr>
<th>组件关系</th>
<th>数据通信</th>
</tr>
</thead>
<tbody>
<tr>
<td>父子关系</td>
<td>父传子：props ； 子传父：$emit</td>
</tr>
<tr>
<td>非父子关系</td>
<td>vuex (一种组件通信方案)</td>
</tr>
</tbody>
</table>
<h3> vuex是什么</h3>
<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用<strong>集中式</strong>存储管理数据，以相应的规则保证状态以一种可预测的方式发生变化</p>
<figure><img src="https://qiniu.waite.wang/202312242347862.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> vuex为何学</h3>
<p>程序页面多, 数据变量多</p>
<ol>
<li>不同组件数据<strong>保持同步</strong></li>
<li>数据的修改都是<strong>可追踪</strong></li>
</ol>
<p>一个户外商店有两名员工，张三和李四</p>
<p>一天的早上，他们分别对<strong>帐篷的数量</strong>做了一次盘点，发现一共有三个帐篷</p>
<p>张三卖出去俩个，他以为库存里还有<strong>一个</strong></p>
<p>李四卖出去一个，他以为库存里还有<strong>两个</strong></p>
<p>而事实上是，库存现在已经为<strong>零</strong></p>
<p>如果他们再接受客户的预订，就会出现库存<strong>不足</strong>的情况</p>
<blockquote>
<p>张三和李四因为没有保持库存的数量的同步导致了尴尬，这个就是所谓的<code>数据保持同步 </code></p>
<p>店长需要知道, 谁卖出了多少个帐篷，这个行为我们称之为<code>数据修改是可追踪的</code></p>
</blockquote>
<p>图示:</p>
<figure><img src="https://qiniu.waite.wang/202312242348361.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> vuex中存什么</h3>
<p><strong>多个组件共享状态</strong>，才存储在vuex中</p>
<p>某个组件中的私有数据，依旧存储在data中</p>
<p>例如：</p>
<ul>
<li>
<p>登陆的用户名需要在<strong>首页</strong>, <strong>个人中心</strong>, <strong>结算</strong>页面使用, 用户名存在vuex中</p>
</li>
<li>
<p>文章详情数据, 只有在文章详情页查看, 在自身data中声明</p>
</li>
</ul>
<h3> 小结</h3>
<ol>
<li>什么是vuex
<ul>
<li>vuex是Vue官方推荐的集中式状态管理机制</li>
</ul>
</li>
<li>为何学vuex
<ul>
<li>数据同步, 集中管理</li>
</ul>
</li>
<li>vuex中存什么
<ul>
<li>多个组件共享的值</li>
</ul>
</li>
</ol>
<h2> 2.vuex学习内容</h2>
<h3> 目标</h3>
<ul>
<li>知道vuex要学习什么</li>
</ul>
<h3> 核心概念</h3>
<ol>
<li>
<p>官网地址: https://vuex.vuejs.org/zh/</p>
</li>
<li>
<p>安装(固定)</p>
</li>
<li>
<p>配置项(固定)</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>含义</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>state</strong></td>
<td>单一状态树</td>
<td>类似data</td>
</tr>
<tr>
<td><strong>mutations</strong></td>
<td>数据管家(同步)</td>
<td>唯一修改state地方</td>
</tr>
<tr>
<td>actions</td>
<td>异步请求</td>
<td>要改state需要提交给mutations</td>
</tr>
<tr>
<td>getters</td>
<td>vuex计算属性</td>
<td>类似computed</td>
</tr>
<tr>
<td>modules</td>
<td>模块拆分</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ol>
<h3> 图示关系</h3>
<p>单一定义store对象, 里面5个配置项, 在任意组件可以使用</p>
<figure><img src="https://qiniu.waite.wang/202312242348351.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 小结</h3>
<ol>
<li>vuex五个核心概念是?
<ul>
<li>state / mutations / actions / getters / modules</li>
</ul>
</li>
</ol>
<h2> 3.vuex例子准备</h2>
<h3> 目标</h3>
<ul>
<li>创建项目, 为学习准备
<ul>
<li>
<p>需求1: App.vue(作为根组件)</p>
</li>
<li>
<p>需求2: 子组件Add和子组件Sub, 嵌入在App.vue里</p>
</li>
<li>
<p>需求3: 三个组件共享库存数据(<strong>保持同步</strong>)</p>
<figure><img src="https://qiniu.waite.wang/202312242348672.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ul>
</li>
</ul>
<h3> 工程准备</h3>
<ol>
<li>
<p>初始化新的工程 vuex-demo</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>清空欢迎界面</p>
</li>
<li>
<p>并设置如下三个组件, 目录如下：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> App.vue</h3>
<blockquote>
<p>复制标签和样式, 引入AddItem和SubItem2个子组件显示</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> AddItem.vue</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> SubItem.vue</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 小结</h3>
<ol>
<li>App下套用了AddItem和SubItem, 要在3个组件共享一个数据</li>
</ol>
<h2> 4.vuex-store准备</h2>
<h3> 目标</h3>
<ul>
<li>创建store仓库</li>
<li>注入到Vue项目中</li>
</ul>
<h3> store概念</h3>
<p>每个 Vuex 应用的核心 store（仓库）, 包含5个核心概念</p>
<figure><img src="https://qiniu.waite.wang/202312242351180.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> vuex目录</h3>
<p>和路由模块router/index.js - 类似, 维护项目目录的整洁，新建src/store/index.js文件</p>
<blockquote>
<p>当然， 这个步骤并不是必需的</p>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202312242353021.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 使用步骤</h3>
<ol>
<li>
<p>工程中 - 下载vuex</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>store/index.js - 创建定义导出store对象</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>main.js - 导入注入到Vue中</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<p>请再次回忆一下vue-router的用法，是不是很像？</p>
<h3> 小结</h3>
<ol>
<li>
<p>vuex的核心是什么?</p>
<ul>
<li>store对象(包含5个核心属性)</li>
</ul>
</li>
<li>
<p>如何创建store对象?</p>
<ul>
<li>工程下载vuex模块</li>
<li>store/index.js
<ul>
<li>引入注册</li>
<li>生成store对象导出</li>
<li>main.js - 导入注入</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2> 5.vuex-state数据源</h2>
<h3> 目标</h3>
<ul>
<li>定义state</li>
<li>直接使用state</li>
<li>辅助函数mapState</li>
</ul>
<blockquote>
<p>state是唯一的公共数据源，统一存储</p>
</blockquote>
<h3> 定义state</h3>
<p>在store/index.js定义state</p>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体代码:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 使用state2种方式</h3>
<ul>
<li>
<p>方式1: 组件内 - <strong>直接</strong>使用</p>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>方式2: 组件内 - <strong>映射</strong>使用 (推荐)</p>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> AddItem直接用</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> App.vue直接用</h3>
<p>计算属性count, 和输入框的v-model双向绑定</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> SubItem映射用</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整个过程的示意图如下</p>
<figure><img src="https://qiniu.waite.wang/202312242355459.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 注意</h3>
<p>state是响应式的, 只要state值变化, 页面上使用的地方会自动更新同步</p>
<h3> 小结</h3>
<ol>
<li>
<p>state作用?</p>
<p>定义全局状态数据源</p>
</li>
<li 变量名:="" 初始值="">
<p>state如何定义?</p>
<p>在store内, state:</p>
</li>
<li>
<p>state的值如何用到具体vue组件内?</p>
<ul>
<li>直接使用 this.$store.state.变量名</li>
<li>映射使用 ...mapState(['state的变量名'])</li>
</ul>
</li>
</ol>
<h2> 6.vuex-mutations定义-同步修改</h2>
<h3> 目标</h3>
<ul>
<li>定义mutations</li>
</ul>
<h3> 定义mutations</h3>
<blockquote>
<p>mutations类似数据管家, 操作state里的数据</p>
</blockquote>
<p>在store/index.js定义mutations</p>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体代码</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 注意</h3>
<blockquote>
<ol>
<li>mutations是<strong>唯一</strong>能修改state的地方, 确保<strong>调试工具</strong>可以追踪变化</li>
<li>mutations函数内, 只能写同步代码, 调试工具可追踪变化过程
<ul>
<li>因为调试工具要<strong>立刻</strong>产生一次记录, 所以必须是同步的</li>
</ul>
</li>
</ol>
</blockquote>
<h3> 小结</h3>
<ol>
<li>
<p>mutations里函数作用?</p>
<ul>
<li>负责修改state里的数据</li>
</ul>
</li>
<li>
<p>mutations只能写什么样的代码?</p>
<ul>
<li>同步流程的代码</li>
</ul>
</li>
</ol>
<h2> 7.vuex-mutations使用</h2>
<h3> 目标</h3>
<ul>
<li>使用mutations2种方式</li>
<li>mutations注意事项</li>
</ul>
<h3> 使用mutations的2种方式</h3>
<ul>
<li>
<p>方式1: 组件内 - <strong>直接</strong>使用</p>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>方式2: 组件内 - <strong>映射</strong>使用</p>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> AddItem直接用</h3>
<ul>
<li>点击事件绑定</li>
<li>提交mutations传入值</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> App.vue直接用</h3>
<ul>
<li>触发计算属性的set方法</li>
<li>提交mutations传入值</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> SubItem映射用</h3>
<ul>
<li>点击事件</li>
<li>映射mutations的方法</li>
<li>调用mutations方法传值</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 注意</h3>
<blockquote>
<p>mutations函数上, 只能接收<strong>一个参数值</strong>, 如果传对个, 请传一个对象</p>
</blockquote>
<h3> 小结</h3>
<ol>
<li>
<p>mutations有哪2种使用方式?</p>
<p>直接使用 this.$store.commit()</p>
<p>映射使用 mapMutations把方法映射到组件内直接调用</p>
</li>
<li>
<p>state, mutations, 视图组件, 3个关系是什么?</p>
</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202312242355165.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 8.vuex-actions定义-异步修改</h2>
<h3> 目标</h3>
<ul>
<li>定义actions</li>
</ul>
<h3> 定义actions</h3>
<p>在store/index.js定义actions</p>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体代码:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 小结</h3>
<ol>
<li>
<p>actions和mutations区别?</p>
<p>mutations里同步修改state</p>
<p>actions里放入异步操作</p>
</li>
<li>
<p>actions是否能操作state?</p>
<p>不建议, 要commit给mutations(为调试工具可追踪)</p>
</li>
<li>
<p>actions和mutations里函数, 第一个形参分别是什么?</p>
<p>mutations的是state</p>
<p>actions的是store</p>
</li>
</ol>
<h2> 9.vuex-actions使用</h2>
<h3> 目标</h3>
<ul>
<li>使用actions</li>
</ul>
<h3> 使用actions的2种方式</h3>
<ul>
<li>
<p>方式1: 组件内 - <strong>直接</strong>使用</p>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>方式2: 组件内 - <strong>映射</strong>使用</p>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> AddItem直接用</h3>
<ul>
<li>点击事件</li>
<li>dispatch触发action</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> SubItem映射用</h3>
<ul>
<li>点击事件</li>
<li>映射actions的方法</li>
<li>调用actions的方法传值</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 小结</h3>
<ol>
<li>
<p>actions使用方式?</p>
<p>方式1: this.$store.dispatch('actions方法名字', 值)</p>
<p>方式2: ...mapActions(['actions里的方法名']) 映射到原地使用</p>
</li>
<li>
<p>视图组件, state, mutations, actions的关系是?</p>
</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202312242356106.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 10.vuex-重构购物车-准备Store</h2>
<h3> 目标</h3>
<ul>
<li>在现有项目如何集成vuex</li>
</ul>
<h3> store准备</h3>
<ol>
<li>复制预习资料&lt;shopcar-模板&gt;到自己今天文件夹下</li>
<li>下载vuex</li>
<li>store/index.js创建导出store对象</li>
<li>main.js把store引入, 然后注入到Vue实例</li>
</ol>
<h3> 小结</h3>
<ol>
<li>
<p>现有项目如何集成vuex</p>
<p>下载vuex</p>
<p>创建store对象并注入到Vue实例中</p>
</li>
</ol>
<h2> 11.vuex-重构购物车-配置项(上午结束)</h2>
<h3> 目标</h3>
<ul>
<li>准备state和mutations还有actions</li>
</ul>
<h3> 配置项准备</h3>
<ol>
<li>定义state - 保存商品列表数组</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>定义mutations - 给state里变量赋值</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>定义actions - 异步请求数据提交给mutations</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> App.vue使用vuex</h3>
<ul>
<li>把vuex商品数组映射回来使用</li>
<li>网络请求调用actions方法</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 小结</h3>
<ol>
<li>
<p>mapState可以改变映射到原地的计算属性名吗?</p>
<p>可以的, 格式...mapState({''计算属性名', 'state里要映射的变量名'})</p>
</li>
</ol>
<h2> 12.vuex-getters定义-计算属性</h2>
<h3> 目标</h3>
<ul>
<li>getters概念</li>
<li>定义getters</li>
</ul>
<h3> getters概念</h3>
<p>vuex身上的全局状态-计算属性, 类似于computed</p>
<p>getters 依赖于 state中原始数据的变化，并返回计算后的新数据</p>
<h3> 定义getters</h3>
<p>在store/index.js定义getters</p>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体代码</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 小结</h3>
<ol>
<li>
<p>getters有什么用?</p>
<p>vuex里的计算属性, 属于全局计算属性, 类似computed</p>
</li>
</ol>
<h2> 13.vuex-getters使用</h2>
<h3> 目标</h3>
<ul>
<li>组件内使用getters</li>
</ul>
<h3> 使用getters的2种方式</h3>
<ul>
<li>
<p>方式1: 组件内 - <strong>直接</strong>使用</p>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>方式2: 组件内 - <strong>映射</strong>使用</p>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> MyFooter.vue里使用</h3>
<ul>
<li>使用2种方式给计算属性值</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 小结</h3>
<ol>
<li>
<p>getters如何使用?</p>
<p>方式1: this.$store.getters.计算属性名</p>
<p>方式2: ...mapGetters(['getters里计算属性名'])</p>
</li>
</ol>
<h2> 14.vuex-modules定义-分模块</h2>
<h3> 目标</h3>
<ul>
<li>为何要分模块</li>
<li>modules定义</li>
</ul>
<h3> 为何分模块</h3>
<figure><img src="https://qiniu.waite.wang/202312242359431.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 代码上的对比</h3>
<figure><img src="https://qiniu.waite.wang/202312242357170.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 创建modules模块对象</h3>
<ul>
<li>新建store/modules/user.js</li>
<li>新建store/modules/cart.js</li>
</ul>
<p>语法: 对象里包含5个核心概念, 只有state变成函数形式</p>
<p>user.js - 用户模块对象</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>cart.js - 购物车模块对象</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 定义modules</h3>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>把2个模块对象, 引回到store里注册</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 小结</h3>
<ol>
<li>
<p>为什么分模块?</p>
<p>集中式管理项目过大, 变量过多, 会导致state臃肿, 难以维护</p>
</li>
<li>
<p>如何分模块?</p>
<p>定义<strong>模块对象</strong>, state变成函数返回对象形式, 每个模块都有state/mutations/actions/getters/modules</p>
</li>
<li>
<p>根store如何注册?</p>
<p>modules里 { 模块名: <strong>模块对象</strong> }</p>
</li>
</ol>
<h2> 15.分模块-影响state取值方式</h2>
<h3> 目的</h3>
<ul>
<li>只要分模块, state取值方式改变, 其他暂时不变</li>
</ul>
<h3> state使用方式修改</h3>
<ul>
<li>
<p>方式1: 组件内 - <strong>直接</strong>使用</p>
<p>原语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>分模块后语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>方式2: 组件内 - <strong>映射</strong>使用</p>
<p>原语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>分模块后语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> App.vue-修改</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 小结</h3>
<ol>
<li>
<p>分模块对什么有影响?</p>
<p>对state的取值方式有影响, 对其他暂无影响</p>
</li>
<li>
<p>state如何取值?</p>
<p>在组件使用的时候, 要state.模块名.变量名</p>
</li>
</ol>
<h2> 16.分模块-命名空间</h2>
<h3> 目标</h3>
<ul>
<li>防止多个模块之间, mutations/actions/getters的名字冲突</li>
</ul>
<h3> 开启命名空间</h3>
<p>在模块对象内设置<code>namespaced: true</code></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> state使用方式修改</h3>
<ul>
<li>
<p>直接使用无变化: this.$store.state.模块名.变量名</p>
</li>
<li>
<p>辅助函数需要遵守格式</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<h3> mutations使用方式修改</h3>
<ul>
<li>
<p>方式1: 组件内 - <strong>直接</strong>使用</p>
<ul>
<li>
<p>原语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>开命名空间后语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p>方式2: 组件内 - <strong>映射</strong>使用</p>
<ul>
<li>
<p>原语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>开命名空间后语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
</ul>
<h3> actions使用方式修改</h3>
<ul>
<li>
<p>方式1: 组件内 - <strong>直接</strong>使用</p>
<ul>
<li>
<p>原语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>开命名空间后语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p>方式2: 组件内 - <strong>映射</strong>使用</p>
<ul>
<li>
<p>原语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>开命名空间后语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
</ul>
<h3> getters使用方式修改</h3>
<ul>
<li>
<p>方式1: 组件内 - <strong>直接</strong>使用</p>
<ul>
<li>
<p>原语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>开命名空间后语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p>方式2: 组件内 - <strong>映射</strong>使用</p>
<ul>
<li>
<p>原语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>开命名空间后语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
</ul>
<h3> 小结</h3>
<ol>
<li>state和mutations, 在根store和开启命名空间里的区别?</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202312250000713.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="2">
<li>整个vuex的体系是?</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202312250000731.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 扩展: 使用Devtools调试vuex数据</h2>
<blockquote>
<p>优秀的调试工具可以使我们写程序事半功倍，最后我们再学习一下如果使用dev-tools来调试vuex中的数据，这也是数据可预测特性里不可缺少的一环</p>
</blockquote>
<h3> 目标</h3>
<ul>
<li>掌握dev-tools调试vuex</li>
<li>理解什么是数据状态是可追踪的</li>
</ul>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202312242346950.png" type="image/png"/>
    </item>
    <item>
      <title>Vue3-Vuex</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/store/vue3_vuex.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/store/vue3_vuex.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Vue3-Vuex</source>
      <description>Vue3 中推荐使用 pinia, 更具体可以看 https://gitee.com/lidongxuwork/bilibili-matching-code/blob/master/Web%E5%89%8D%E7%AB%AF/5-%E6%A1%86%E6%9E%B6/V2.x/%E6%A6%82%E5%BF%B5/1-vuex%E4%BD%BF%E7%94%A8/0_%E7%AC%94%E8%AE%B0/vuex%E4%BD%BF%E7%94%A8.md#day01_vuex Vuex介绍 Vuex是什么</description>
      <pubDate>Sun, 24 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Vue3 中推荐使用 pinia, 更具体可以看 https://gitee.com/lidongxuwork/bilibili-matching-code/blob/master/Web%E5%89%8D%E7%AB%AF/5-%E6%A1%86%E6%9E%B6/V2.x/%E6%A6%82%E5%BF%B5/1-vuex%E4%BD%BF%E7%94%A8/0_%E7%AC%94%E8%AE%B0/vuex%E4%BD%BF%E7%94%A8.md#day01_vuex</p>
</blockquote>
<h2> Vuex介绍</h2>
<h3> Vuex是什么</h3>
<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用<strong>集中式</strong>存储管理数据，以相应的规则保证状态以一种可预测的方式发生变化
<img src="https://qiniu.waite.wang/202312232248202.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>优点：</p>
<ol>
<li>能够在Vuex中集中管理共享的数居，易于开发和后期维护</li>
<li>能够高效地实现组件之间的数据共享，提高开发效率</li>
<li>存储在vuex中的数据都是响应式的，能够实时保持数据与页面的同步</li>
</ol>
<h3> vuex为何学</h3>
<p>程序页面多, 数据变量多</p>
<ol>
<li>不同组件数据<strong>保持同步</strong></li>
<li>数据的修改都是<strong>可追踪</strong></li>
</ol>
<p>一个户外商店有两名员工，张三和李四</p>
<p>一天的早上，他们分别对<strong>帐篷的数量</strong>做了一次盘点，发现一共有三个帐篷</p>
<p>张三卖出去俩个，他以为库存里还有<strong>一个</strong></p>
<p>李四卖出去一个，他以为库存里还有<strong>两个</strong></p>
<p>而事实上是，库存现在已经为<strong>零</strong></p>
<p>如果他们再接受客户的预订，就会出现库存<strong>不足</strong>的情况</p>
<blockquote>
<p>张三和李四因为没有保持库存的数量的同步导致了尴尬，这个就是所谓的<code>数据保持同步</code></p>
<p>店长需要知道, 谁卖出了多少个帐篷，这个行为我们称之为<code>数据修改是可追踪的</code></p>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202312241613856.png" alt="image-20210601212946879" tabindex="0" loading="lazy"><figcaption>image-20210601212946879</figcaption></figure>
<h3> vuex中存什么</h3>
<p><strong>多个组件共享状态</strong>，才存储在vuex中</p>
<p>某个组件中的私有数据，依旧存储在data中</p>
<p>例如：</p>
<ul>
<li>登陆的用户名需要在<strong>首页</strong>, <strong>个人中心</strong>, <strong>结算</strong>页面使用, 用户名存在vuex中</li>
<li>文章详情数据, 只有在文章详情页查看, 在自身data中声明</li>
</ul>
<h2> 基本使用</h2>
<ol>
<li>安装 vuex 依赖包</li>
</ol>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2">
<li>导入</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>创建 store 对象</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>将 store 对象挂载到 vue 实例中</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> state</h2>
<blockquote>
<p>state是唯一的公共数据源，统一存储</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 使用</h3>
<ul>
<li>方式1: 组件内 - <strong>直接</strong>使用</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>方式2: 组件内 - <strong>映射</strong>使用 (推荐)</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>state是响应式的, 只要state值变化, 页面上使用的地方会自动更新同步</p>
</blockquote>
<h2> mutations</h2>
<blockquote>
<p>Vuex Mutations 则是用于修改状态的函数。在 Vuex 中，状态是通过 store 对象进行管理的，而 Mutations 则是通过提交（commit）来执行的。每个 Mutation 都是一个纯函数，它接收 state 对象作为第一个参数，并且可以接收额外的参数作为载荷（payload）。Mutation 函数用于同步地改变状态，它们在开发过程中可以帮助我们跟踪状态的变化。</p>
</blockquote>
<p>在 Vue 3 中，Mutations 并不是唯一能修改 state 的地方。实际上，在 Vue 3 中，可以通过使用 Mutations、Actions 或直接操作 state 来修改状态。这是与 Vue 2 中的 Vuex 不同的地方。</p>
<p>在 Vue 3 中，可以使用 Mutations 来同步地改变状态，Actions 用于处理异步操作并提交 Mutations，而直接操作 state 则是为了简单的状态变化。这种方式使得状态管理更加灵活，并且能够更好地处理异步操作。</p>
<p>因此，在 Vue 3 中，Mutations 并不是唯一能修改 state 的地方，而是状态管理中的一部分，开发者可以根据具体情况选择合适的方式来修改状态。</p>
<blockquote>
<p>以下是一个 mutations 与 store 结合的例子</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> actions</h2>
<p>在 Vue 3 中，使用 Vuex 的 Actions 是一种处理异步操作并提交 Mutations 的方式。Actions 允许您在应用程序中执行异步操作，例如从服务器获取数据，然后再提交 Mutations 来修改状态。以下是在 Vue 3 中使用 Vuex Actions 的基本方法：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> getters</h2>
<p>Vuex Getters 是用于从 store 中获取状态的函数。Getters 允许您在 store 中计算状态或过滤数据，并且可以在组件中像计算属性一样使用。以下是在 Vue 3 中定义和使用 Vuex Getters 的基本方法：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 用getters的2种方式</h3>
<ul>
<li>
<p>方式1: 组件内 - <strong>直接</strong>使用</p>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>方式2: 组件内 - <strong>映射</strong>使用</p>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> MyFooter.vue里使用</h3>
<ul>
<li>使用2种方式给计算属性值</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202312232248202.png" type="image/png"/>
    </item>
    <item>
      <title>路由使用</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/router/%E8%B7%AF%E7%94%B1%E8%BF%9B%E9%98%B6.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/router/%E8%B7%AF%E7%94%B1%E8%BF%9B%E9%98%B6.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">路由使用</source>
      <description>路由嵌套 一些应用程序的 UI 由多层嵌套的组件组成。在这种情况下，URL 的片段通常对应于特定的嵌套组件结构，例如： /user/johnny/profile /user/johnny/posts +------------------+ +-----------------+ | User | | User | | +--------------+ | | +-------------+ | | | Profile | | +------------&amp;gt; | | Posts | | | | | | | | | | | +--------------+ | | +-------------+ | +------------------+ +-----------------+</description>
      <pubDate>Sun, 24 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 路由嵌套</h2>
<p>一些应用程序的 UI 由多层嵌套的组件组成。在这种情况下，URL 的片段通常对应于特定的嵌套组件结构，例如：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 Vue Router，你可以使用嵌套路由配置来表达这种关系。</p>
<p>接着上节创建的 app ：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的 <code>&lt;router-view&gt;</code> 是一个顶层的 <code>router-view</code>。它渲染顶层路由匹配的组件。同样地，一个被渲染的组件也可以包含自己嵌套的 <code>&lt;router-view&gt;</code>。例如，如果我们在 <code>User</code> 组件的模板内添加一个 <code>&lt;router-view&gt;</code>：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要将组件渲染到这个嵌套的 <code>router-view</code> 中，我们需要在路由中配置 <code>children</code>：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意，以 <code>/</code> 开头的嵌套路径将被视为根路径。这允许你利用组件嵌套，而不必使用嵌套的 URL。</strong></p>
<p>如你所见，<code>children</code> 配置只是另一个路由数组，就像 <code>routes</code> 本身一样。因此，你可以根据自己的需要，不断地嵌套视图。</p>
<p>此时，按照上面的配置，当你访问 <code>/user/eduardo</code> 时，在 <code>User</code> 的 <code>router-view</code> 里面什么都不会呈现，因为没有匹配到嵌套路由。也许你确实想在那里渲染一些东西。在这种情况下，你可以提供一个空的嵌套路径：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 导航守卫</h2>
<blockquote>
<p>https://router.vuejs.org/zh/guide/advanced/navigation-guards.html</p>
</blockquote>
<p>正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。这里有很多方式植入路由导航中：全局的，单个路由独享的，或者组件级的。</p>
<h3> 全局前置守卫</h3>
<p>你可以使用 <code>router.beforeEach</code> 注册一个全局前置守卫：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于<strong>等待中</strong>。</p>
<p>每个守卫方法接收两个参数：</p>
<ul>
<li><strong><code>to</code></strong>: 即将要进入的目标 <a href="https://router.vuejs.org/zh/api/#routelocationnormalized" target="_blank" rel="noopener noreferrer">用一种标准化的方式</a></li>
<li><strong><code>from</code></strong>: 当前导航正要离开的路由 <a href="https://router.vuejs.org/zh/api/#routelocationnormalized" target="_blank" rel="noopener noreferrer">用一种标准化的方式</a></li>
</ul>
<p>可以返回的值如下:</p>
<ul>
<li><code>false</code>: 取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li>
<li>一个<a href="https://router.vuejs.org/zh/api/#routelocationraw" target="_blank" rel="noopener noreferrer">路由地址</a>: 通过一个路由地址重定向到一个不同的地址，如同调用 <code>router.push()</code>，且可以传入诸如 <code>replace: true</code> 或 <code>name: 'home'</code> 之类的选项。它会中断当前的导航，同时用相同的 <code>from</code> 创建一个新导航。</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果遇到了意料之外的情况，可能会抛出一个 <code>Error</code>。这会取消导航并且调用 <a href="https://router.vuejs.org/zh/api/interfaces/router#onError" target="_blank" rel="noopener noreferrer"><code>router.onError()</code></a> 注册过的回调。</p>
<p>如果什么都没有，<code>undefined</code> 或返回 <code>true</code>，<strong>则导航是有效的</strong>，并调用下一个导航守卫</p>
<p>以上所有都同 <strong><code>async</code> 函数</strong> 和 Promise 工作方式一样：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在之前的 Vue Router 版本中，还可以使用 <em>第三个参数</em> <code>next</code> 。这是一个常见的错误来源，我们经过 <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0037-router-return-guards.md#motivation" target="_blank" rel="noopener noreferrer">RFC</a> 讨论将其移除。然而，它仍然是被支持的，这意味着你可以向任何导航守卫传递第三个参数。在这种情况下，<strong>确保 <code>next</code></strong> 在任何给定的导航守卫中都被<strong>严格调用一次</strong>。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。这里有一个在用户未能验证身份时重定向到<code>/login</code>的<strong>错误用例</strong>：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是正确的版本:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 全局后置钩子</h3>
<p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。</p>
<p>它们也反映了 <a href="https://router.vuejs.org/zh/guide/advanced/navigation-failures.html" target="_blank" rel="noopener noreferrer">navigation failures</a> 作为第三个参数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更多关于 navigation failures 的信息在<a href="https://router.vuejs.org/zh/guide/advanced/navigation-failures.html" target="_blank" rel="noopener noreferrer">它的指南</a> 中。</p>
<h3> 路由独享的守卫</h3>
<p>你可以直接在路由配置上定义 <code>beforeEnter</code> 守卫：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>beforeEnter</code> 守卫 <strong>只在进入路由时触发</strong>，不会在 <code>params</code>、<code>query</code> 或 <code>hash</code> 改变时触发。例如，从 <code>/users/2</code> 进入到 <code>/users/3</code> 或者从 <code>/users/2#info</code> 进入到 <code>/users/2#projects</code>。它们只有在 <strong>从一个不同的</strong> 路由导航时，才会被触发。</p>
<p>你也可以将一个函数数组传递给 <code>beforeEnter</code>，这在为不同的路由重用守卫时很有用：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，你也可以通过使用<a href="https://router.vuejs.org/zh/guide/advanced/meta" target="_blank" rel="noopener noreferrer">路径 meta 字段</a>和全局导航守卫来实现类似的行为。</p>
<h3> 组件内的守卫</h3>
<p>最后，你可以在路由组件内直接定义路由导航守卫(传递给路由配置的)</p>
<h3> 可用的配置 API</h3>
<p>你可以为路由组件添加以下配置：</p>
<ul>
<li><code>beforeRouteEnter</code></li>
<li><code>beforeRouteUpdate</code></li>
<li><code>beforeRouteLeave</code></li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>beforeRouteEnter</code> 守卫 <strong>不能</strong> 访问 <code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p>
<p>不过，你可以通过传一个回调给 <code>next</code> 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以<em>不支持</em> 传递回调，因为没有必要了：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 <strong>离开守卫</strong> 通常用来预防用户在还未保存修改前突然离开。该导航可以通过返回 <code>false</code> 来取消。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 使用组合 AP</h4>
<p>如果你正在使用<a href="https://cn.vuejs.org/api/composition-api-setup.html" target="_blank" rel="noopener noreferrer">组合 API 和 <code>setup</code> 函数</a>来编写组件，你可以通过 <code>onBeforeRouteUpdate</code> 和 <code>onBeforeRouteLeave</code> 分别添加 update 和 leave 守卫。 请参考<a href="https://router.vuejs.org/zh/guide/advanced/composition-api.html#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener noreferrer">组合 API 部分</a>以获得更多细节。</p>
<h3> 完整的导航解析流程</h3>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫(2.2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫(2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 DOM 更新。</li>
<li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>
</ol>
<h2> 路由案例</h2>
<p>目标: 路由跳转之前, 先执行一次前置守卫函数, 判断是否可以正常跳转</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个守卫方法接收三个参数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 登录拦截</h3>
<p>使用例子: 在跳转路由前, 判断用户登陆了才能去 <code>&lt;我的音乐&gt;</code> 页面, 未登录弹窗提示回到发现音乐页面</p>
<p>在路由对象上使用固定方法 beforeEach</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>总结: next()放行, next(false)留在原地不跳转路由, next(path路径)强制换成对应path路径跳转</p>
</blockquote>
<h3> 权限判断</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 路由原信息</h2>
<p>有时，你可能希望将任意信息附加到路由上，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的<code>meta</code>属性来实现，并且它可以在路由地址和导航守卫上都被访问到。定义路由的时候你可以这样配置 <code>meta</code> 字段：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么如何访问这个 <code>meta</code> 字段呢？</p>
<p>首先，我们称呼 <code>routes</code> 配置中的每个路由对象为 <strong>路由记录</strong>。路由记录可以是嵌套的，因此，当一个路由匹配成功后，它可能匹配多个路由记录。</p>
<p>例如，根据上面的路由配置，<code>/posts/new</code> 这个 URL 将会匹配父路由记录 (<code>path: '/posts'</code>) 以及子路由记录 (<code>path: 'new'</code>)。</p>
<p>一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象(还有在导航守卫中的路由对象)的<code>$route.matched</code> 数组。我们需要遍历这个数组来检查路由记录中的 <code>meta</code> 字段，但是 Vue Router 还为你提供了一个 <code>$route.meta</code> 方法，它是一个非递归合并<strong>所有 <code>meta</code></strong> 字段（从父字段到子字段）的方法。这意味着你可以简单地写</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 过渡动效</h2>
<p>想要在你的路径组件上使用转场，并对导航进行动画处理，你需要使用 <a href="https://router.vuejs.org/zh/api/#router-view-s-v-slot" target="_blank" rel="noopener noreferrer">v-slot API</a>：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的用法会对所有的路由使用相同的过渡。如果你想让每个路由的组件有不同的过渡，你可以将<a href="https://router.vuejs.org/zh/guide/advanced/meta.html" target="_blank" rel="noopener noreferrer">元信息</a>和动态的 <code>name</code> 结合在一起，放在<code>&lt;transition&gt;</code> 上：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以根据目标路由和当前路由之间的关系，动态地确定使用的过渡。使用和刚才非常相似的片段：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以添加一个 <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%90%8E%E7%BD%AE%E9%92%A9%E5%AD%90" target="_blank" rel="noopener noreferrer">after navigation hook</a>，根据路径的深度动态添加信息到 <code>meta</code> 字段。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Vue 可能会自动复用看起来相似的组件，从而忽略了任何过渡。幸运的是，可以<a href="https://cn.vuejs.org/api/built-in-special-attributes.html#key" target="_blank" rel="noopener noreferrer">添加一个 <code>key</code> 属性</a>来强制过渡。这也允许你在相同路由上使用不同的参数触发过渡：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 滚动行为</h2>
<p>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p>
<p><strong>注意: 这个功能只在支持 history.pushState 的浏览器中可用。</strong></p>
<p>当创建一个 Router 实例，你可以提供一个 <code>scrollBehavior</code> 方法：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>scrollBehavior</code> 函数接收 <code>to</code>和<code> from</code> 路由对象，如 <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener noreferrer">Navigation Guards</a>。第三个参数 <code>savedPosition</code>，只有当这是一个 <code>popstate</code> 导航时才可用（由浏览器的后退/前进按钮触发）。</p>
<p>该函数可以返回一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ScrollToOptions" target="_blank" rel="noopener noreferrer"><code>ScrollToOptions</code></a> 位置对象:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你也可以通过 <code>el</code> 传递一个 CSS 选择器或一个 DOM 元素。在这种情况下，<code>top</code> 和 <code>left</code> 将被视为该元素的相对偏移量。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果返回一个 falsy 的值，或者是一个空对象，那么不会发生滚动。</p>
<p>返回 <code>savedPosition</code>，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你要模拟 “滚动到锚点” 的行为：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你的浏览器支持<a href="https://developer.mozilla.org/en-US/docs/Web/API/ScrollToOptions/behavior" target="_blank" rel="noopener noreferrer">滚动行为</a>，你可以让它变得更流畅：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有时候，我们需要在页面中滚动之前稍作等待。例如，当处理过渡时，我们希望等待过渡结束后再滚动。要做到这一点，你可以返回一个 Promise，它可以返回所需的位置描述符。下面是一个例子，我们在滚动前等待 500ms：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以将其与页面级过渡组件的事件挂钩，以使滚动行为与你的页面过渡很好地结合起来，但由于使用场景可能存在的差异和复杂性，我们只是提供了这个基础来实现特定的用户场景。</p>
<h2> 动态路由</h2>
<p>对路由的添加通常是通过 <code>routes</code> 选项来完成的，但是在某些情况下，你可能想在应用程序已经运行的时候添加或删除路由。具有可扩展接口(如 <a href="https://cli.vuejs.org/dev-guide/ui-api.html" target="_blank" rel="noopener noreferrer">Vue CLI UI</a> )这样的应用程序可以使用它来扩展应用程序。</p>
<h3> 添加路由</h3>
<p>动态路由主要通过两个函数实现。<code>router.addRoute()</code> 和 <code>router.removeRoute()</code>。它们<strong>只</strong>注册一个新的路由，也就是说，如果新增加的路由与当前位置相匹配，就需要你用 <code>router.push()</code> 或 <code>router.replace()</code> 来<strong>手动导航</strong>，才能显示该新路由。我们来看一个例子：</p>
<p>想象一下，只有一个路由的以下路由：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>进入任何页面，<code>/about</code>，<code>/store</code>，或者 <code>/3-tricks-to-improve-your-routing-code</code> 最终都会呈现 <code>Article</code> 组件。如果我们在 <code>/about</code> 上添加一个新的路由：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>页面仍然会显示 <code>Article</code> 组件，我们需要手动调用 <code>router.replace()</code> 来改变当前的位置，并覆盖我们原来的位置（而不是添加一个新的路由，最后在我们的历史中两次出现在同一个位置）：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>记住，如果你需要等待新的路由显示，可以使用 <code>await router.replace()</code>。</p>
<h3> 删除路由</h3>
<p>有几个不同的方法来删除现有的路由：</p>
<ul>
<li>
<p>通过添加一个名称冲突的路由。如果添加与现有途径名称相同的途径，会先删除路由，再添加路由：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>通过调用 <code>router.addRoute()</code> 返回的回调：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当路由没有名称时，这很有用。</p>
</li>
<li>
<p>通过使用 <code>router.removeRoute()</code> 按名称删除路由：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是，如果你想使用这个功能，但又想避免名字的冲突，可以在路由中使用 <code>Symbol</code> 作为名字。</p>
</li>
</ul>
<p>当路由被删除时，<strong>所有的别名和子路由也会被同时删除</strong></p>
<h3> 查看现有路由</h3>
<p>Vue Router 提供了两个功能来查看现有的路由：</p>
<ul>
<li><a href="https://router.vuejs.org/zh/api/interfaces/Router.html#Methods-hasRoute" target="_blank" rel="noopener noreferrer"><code>router.hasRoute()</code></a>：检查路由是否存在。</li>
<li><a href="https://router.vuejs.org/zh/api/interfaces/Router.html#Methods-getRoutes" target="_blank" rel="noopener noreferrer"><code>router.getRoutes()</code></a>：获取一个包含所有路由记录的数组。</li>
</ul>
<h2> 动态路由案例</h2>
<h3> 后端代码 -&gt; Python Flask</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 前端代码</h3>
<ul>
<li>App.vue</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>router.js</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>login.vue</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>main.js</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>路由使用</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/router/%E8%B7%AF%E7%94%B1%E4%BD%BF%E7%94%A8.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/router/%E8%B7%AF%E7%94%B1%E4%BD%BF%E7%94%A8.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">路由使用</source>
      <description>关于路由 认识前端路由 路由其实是网络工程中的一个术语： 在架构一个网络时，非常重要的两个设备就是路由器和交换机。 当然，目前在我们生活中路由器也是越来越被大家所熟知，因为我们生活中都会用到路由器： 路由器的主要功能是维护一个映射表，这个映射表决定了数据的流向。在网络中，路由器通过这个映射表来确定数据包的传输路径，使得数据能够按照设定的规则正确地传输到目的地。 路由的概念在软件工程中出现，最早是在后端路由中实现的，原因是web的发展主要经历了这样一些阶段： 后端路由阶段； 前后端分离阶段； 单页面富应用（SPA）；</description>
      <pubDate>Sat, 23 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 关于路由</h2>
<h3> 认识前端路由</h3>
<ul>
<li>路由其实是网络工程中的一个术语：
<ul>
<li>在架构一个网络时，非常重要的两个设备就是路由器和交换机。</li>
<li>当然，目前在我们生活中路由器也是越来越被大家所熟知，因为我们生活中都会用到路由器：</li>
<li>路由器的主要功能是维护一个映射表，这个映射表决定了数据的流向。在网络中，路由器通过这个映射表来确定数据包的传输路径，使得数据能够按照设定的规则正确地传输到目的地。</li>
</ul>
</li>
<li>路由的概念在软件工程中出现，最早是在后端路由中实现的，原因是web的发展主要经历了这样一些阶段：
<ul>
<li>后端路由阶段；</li>
<li>前后端分离阶段；</li>
<li>单页面富应用（SPA）；</li>
</ul>
</li>
</ul>
<h3> 后端路由阶段</h3>
<ul>
<li>早期的网站开发整个HTML页面是由服务器来渲染的.
<ul>
<li>服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示.</li>
</ul>
</li>
<li>一个页面有自己对应的网址, 也就是URL；</li>
<li>URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller(控制器)进行处理；</li>
<li>Controller进行各种处理, 最终生成HTML或者数据, 返回给前端.</li>
<li>上面的这种操作, 就是后端路由：
<ul>
<li>当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户端.</li>
<li>这种情况下渲染好的页面, 不需要单独加载任何的<code>js</code>和<code>css</code>, 可以直接交给浏览器展示, 这样也有利于SEO的优化.</li>
</ul>
</li>
<li>后端路由的缺点:
<ul>
<li>一种情况是整个页面的模块由后端人员来编写和维护的；</li>
<li>另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码；</li>
<li>而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情；</li>
</ul>
</li>
</ul>
<h3> 前后端分离阶段</h3>
<ul>
<li>前端渲染的理解：
<ul>
<li>每次请求涉及到的静态资源都会从静态资源服务器获取，这些资源包括HTML+CSS+JS，然后在前端对这些请求回来的资源进行渲染；</li>
<li>需要注意的是，客户端的每一次请求，都会从静态资源服务器请求文件；</li>
<li>同时可以看到，和之前的后端路由不同，这时后端只是负责提供API了；</li>
</ul>
</li>
<li>前后端分离阶段：
<ul>
<li>随着Ajax的出现, 有了前后端分离的开发模式；</li>
<li>后端只提供API来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中；</li>
<li>这样做最大的优点就是前后端责任的清晰，后端专注于数据上，前端专注于交互和可视化上；</li>
<li>并且当移动端(iOS/Android)出现后，后端不需要进行任何处理，依然使用之前的一套API即可；</li>
<li>目前比较少的网站采用这种模式开发（jQuery开发模式）；</li>
</ul>
</li>
</ul>
<h3> 单页面富应用（SPA）</h3>
<p>随着前端框架（如AngularJS、React、Vue等）的兴起，单页面富应用成为主流。单页面富应用（SPA）是一种Web应用程序的架构模式，它通过动态加载页面内容，实现在单个HTML页面上切换视图和更新内容，而无需每次都从服务器请求新的页面。这种方式提高了用户体验和应用性能，因为页面只在初始化时加载一次，之后的页面切换和内容更新都是通过异步加载数据和更新页面内容来实现的。常见的前端框架如AngularJS、React和Vue等都支持SPA的开发模式。</p>
<h2> Vue-router 简介</h2>
<blockquote>
<p>官网: https://router.vuejs.org/zh/</p>
</blockquote>
<p>Vue Router 是 <a href="https://vuejs.org/" target="_blank" rel="noopener noreferrer">Vue.js</a> 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举。功能包括：</p>
<ul>
<li>嵌套路由映射</li>
<li>动态路由选择</li>
<li>模块化、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>展示由 Vue.js 的过渡系统提供的过渡效果</li>
<li>细致的导航控制</li>
<li>自动激活 CSS 类的链接</li>
<li>HTML5 history 模式或 hash 模式</li>
<li>可定制的滚动行为</li>
<li>URL 的正确编码</li>
</ul>
<p><strong>具体使用示例：</strong></p>
<p>网易云音乐 https://music.163.com/</p>
<p>单页面应用(SPA): 所有功能在一个 html 页面上实现</p>
<p>前端路由作用: 实现业务场景切换</p>
<ul>
<li>优点：
<ul>
<li>简单易用</li>
<li>支持嵌套路由</li>
<li>支持路由参数、查询、动态路由等</li>
</ul>
</li>
<li>缺点：
<ul>
<li>对于大型单页应用可能不够灵活</li>
<li>在处理复杂路由时可能需要额外的插件或工具</li>
</ul>
</li>
</ul>
<h2> 路由初体验</h2>
<p>Vue Router 支持两种路由模式：</p>
<ul>
<li>Hash 模式：
<ul>
<li>使用 URL 中的 <code># </code>来管理路由，适用于不需要服务端支持的单页应用。<code>createWebHashHistory </code>是 Vue Router 提供的一种路由模式，它基于 URL 中的 hash（#）来管理路由。这种模式在不需要服务器端支持的情况下可以工作</li>
</ul>
</li>
<li>History 模式：
<ul>
<li>使用 HTML5 History API 来管理路由，可以去掉 URL 中的 <code>#</code>，需要服务器端支持来处理路由<code>createWebHistory</code> 是 Vue Router 提供的基于 HTML5 History API 的路由模式。这种模式需要服务器端支持来处理路由，但可以去掉 URL 中的 #，看起来更加干净。</li>
</ul>
</li>
</ul>
<p>用 Vue + Vue Router 创建单页应用非常简单：通过 Vue.js，我们已经用组件组成了我们的应用。当加入 Vue Router 时，我们需要做的就是将我们的组件映射到路由上，让 Vue Router 知道在哪里渲染它们。下面是一个基本的例子：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> router-link</h3>
<p>请注意，我们没有使用常规的 <code>a</code> 标签，而是使用一个自定义组件 <code>router-link</code> 来创建链接。这使得 Vue Router 可以在不重新加载页面的情况下更改 URL，处理 URL 的生成以及编码。我们将在后面看到如何从这些功能中获益。</p>
<h3> router-view</h3>
<p><code>router-view</code> 将显示与 URL 对应的组件。你可以把它放在任何地方，以适应你的布局。</p>
<h2> 安装以及使用</h2>
<ul>
<li>
<p>安装</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>创建 <code>router/index.js</code> 并在其中编辑基本配置(默认你已经注册了 <code>components</code> 中的两个文件)</p>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>在 <code>src/App.vue</code> 中引入</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>当然, 我们需要一个 <code>router-view</code> 显示与 URL 对应的组件, 一般会在 <code>src/App.vue</code> 中做如下配置, 当然你可以把它放在任何地方，以适应你的布局。</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>我们也可以在其中使用 <code>router-link</code></li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 带参数的动态路由匹配</h2>
<p>很多时候，我们需要将给定匹配模式的路由映射到同一个组件。例如，我们可能有一个 <code>User</code> 组件，它应该对所有用户进行渲染，但用户 ID 不同。在 Vue Router 中，我们可以在路径中使用一个动态字段来实现，我们称之为 <em>路径参数</em> ：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在像 <code>/users/johnny</code> 和 <code>/users/jolyne</code> 这样的 URL 都会映射到同一个路由。</p>
<p><em>路径参数</em> 用冒号 <code>:</code> 表示。当一个路由被匹配时，它的 <em>params</em> 的值将在每个组件中以 <code>this.$route.params</code> 的形式暴露出来。因此，我们可以通过更新 <code>User</code> 的模板来呈现当前的用户 ID：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以在同一个路由中设置有多个 <em>路径参数</em>，它们会映射到 <code>$route.params</code> 上的相应字段。例如：</p>
<table>
<thead>
<tr>
<th style="text-align:left">匹配模式</th>
<th style="text-align:left">匹配路径</th>
<th style="text-align:left">$route.params</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/users/:username</td>
<td style="text-align:left">/users/eduardo</td>
<td style="text-align:left"><code>{ username: 'eduardo' }</code></td>
</tr>
<tr>
<td style="text-align:left">/users/:username/posts/:postId</td>
<td style="text-align:left">/users/eduardo/posts/123</td>
<td style="text-align:left"><code>{ username: 'eduardo', postId: '123' }</code></td>
</tr>
</tbody>
</table>
<p>除了 <code>$route.params</code> 之外，<code>$route</code> 对象还公开了其他有用的信息，如 <code>$route.query</code>（如果 URL 中存在参数）、<code>$route.hash</code> 等。你可以在 <a href="https://router.vuejs.org/zh/api/#routelocationnormalized" target="_blank" rel="noopener noreferrer">API 参考</a>中查看完整的细节。</p>
<blockquote>
<p>以下是一个小 Demo</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312230002394.png" alt="image-20231223000208274" tabindex="0" loading="lazy"><figcaption>image-20231223000208274</figcaption></figure>
<p>##声明式/ 编程式导航</p>
<h3> 声明式导航</h3>
<h4> 基础使用/ 命名路由</h4>
<p>除了 <code>path</code> 之外，你还可以为任何路由提供 <code>name</code>。这有以下优点：</p>
<ul>
<li>https://router.vuejs.org/zh/guide/essentials/named-routes.html</li>
</ul>
<ul>
<li>没有硬编码的 URL</li>
<li><code>params</code> 的自动编码/解码。</li>
<li>防止你在 <code>url</code>中出现打字错误。</li>
<li>绕过路径排序（如显示一个）</li>
<li>这跟代码调用 <code>router.push()</code> 是一回事：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>跳转方式需要改变 变为对象并且有对应name</p>
<p>两种跳转方式有区别, a 标签有新的网络请求, 会刷新整个页面</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 跳转传参</h4>
<p>目标: 在跳转路由时, 可以给路由对应的组件内传值</p>
<p>在 <code>router-link</code> 上的 <code>to</code> 属性传值, 语法格式如下</p>
<ul>
<li><code>/path?参数名=值</code></li>
<li><code>/path/值</code> – 需要路由对象提前配置 <code>path: "/path/参数名"</code></li>
</ul>
<p>对应页面组件接收传递过来的值</p>
<ul>
<li><code>route.query.参数名</code></li>
<li><code>route.params.参数名</code></li>
</ul>
<p>1、新建 <code>views/Part2.vue</code> - 接收路由上传递的参数和值</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、修改路由定义</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、修改 <code>App.vue</code> 进行跳转</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结:</p>
<ul>
<li><code>?key=value</code> 用 <code>$route.query.key</code> 取值</li>
<li><code>/值</code> 提前在路由规则 <code>/path/:key</code> 用 <code>$route.params.key</code> 取值</li>
<li><code>query</code> 是查询参数, <code>params</code> 是 <code>path</code> 路径</li>
<li>有:的路径代表要接收具体的值, 不然会报警告</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312230023125.png" alt="image-20231223002327799" tabindex="0" loading="lazy"><figcaption>image-20231223002327799</figcaption></figure>
<p>在这个特定的场景中，我们在括号之间使用了<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#%E5%9C%A8%E5%8F%82%E6%95%B0%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AD%A3%E5%88%99" target="_blank" rel="noopener noreferrer">自定义正则表达式</a>，并将<code>pathMatch</code> 参数标记为<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0" target="_blank" rel="noopener noreferrer">可选可重复</a>。这样做是为了让我们在需要的时候，可以通过将 <code>path</code> 拆分成一个数组，直接导航到路由</p>
<h4> 捕获所有路由或 404 Not found 路由</h4>
<p>常规参数只匹配 url 片段之间的字符，用 <code>/</code> 分隔。如果我们想匹配<strong>任意路径</strong>，我们可以使用自定义的 <em>路径参数</em> 正则表达式，在 <em>路径参数</em> 后面的括号中加入 正则表达式 :</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个特定的场景中，我们在括号之间使用了<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#%E5%9C%A8%E5%8F%82%E6%95%B0%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AD%A3%E5%88%99" target="_blank" rel="noopener noreferrer">自定义正则表达式</a>，并将<code>pathMatch</code> 参数标记为<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0" target="_blank" rel="noopener noreferrer">可选可重复</a>。这样做是为了让我们在需要的时候，可以通过将 <code>path</code> 拆分成一个数组，直接导航到路由：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更多内容请参见<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#%E5%8F%AF%E9%87%8D%E5%A4%8D%E7%9A%84%E5%8F%82%E6%95%B0" target="_blank" rel="noopener noreferrer">重复参数</a>部分。</p>
<blockquote>
<p>一般使用如下</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 编程式导航</h3>
<p>除了使用 <code>&lt;router-link&gt;</code> 创建 <code>a</code> 标签来定义导航链接，我们还可以借助 <code>router</code> 的实例方法，通过编写代码来实现。</p>
<h4> 导航到不同的位置</h4>
<p>注意：在 Vue 实例中，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>$router.push</code>。</p>
<p>想要导航到不同的 URL，可以使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，会回到之前的 URL。</p>
<p>当你点击 <code>&lt;router-link&gt;</code> 时，内部会调用这个方法，所以点击 <code>&lt;router-link :to="..."&gt;</code> 相当于调用 <code>router.push(...)</code> ：</p>
<table>
<thead>
<tr>
<th style="text-align:left">声明式</th>
<th style="text-align:left">编程式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&lt;router-link :to="..."&gt;</code></td>
<td style="text-align:left"><code>router.push(...)</code></td>
</tr>
</tbody>
</table>
<p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong>：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code> ：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当指定 <code>params</code> 时，可提供 <code>string</code> 或 <code>number</code> 参数（或者对于<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#repeatable-params" target="_blank" rel="noopener noreferrer">可重复的参数</a> 可提供一个数组）。<strong>任何其他类型（如 <code>undefined</code>、<code>false</code> 等）都将被自动字符串化</strong> 。对于<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#repeatable-params" target="_blank" rel="noopener noreferrer">可选参数</a> ，你可以提供一个空字符串（<code>""</code>）来跳过它。</p>
<p>由于属性 <code>to</code> 与 <code>router.push</code> 接受的对象种类相同，所以两者的规则完全相同。</p>
<h4> 基础使用</h4>
<p>语法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li><code>src/router/index.js</code> - 路由数组里, 给路由起名字</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>App.vue - 换成 span 配合js的编程式导航跳转</li>
</ol>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 横跨历史</h2>
<p>该方法采用一个整数作为参数，表示在历史堆栈中前进或后退多少步，类似于 <code>window.history.go(n)</code>。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 替换当前位置</h2>
<p>它的作用类似于 <code>router.push</code>，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。</p>
<table>
<thead>
<tr>
<th style="text-align:left">声明式</th>
<th style="text-align:left">编程式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&lt;router-link :to="..." replace&gt;</code></td>
<td style="text-align:left"><code>router.replace(...)</code></td>
</tr>
</tbody>
</table>
<p>也可以直接在传递给 <code>router.push</code> 的 <code>routeLocation</code> 中增加一个属性 <code>replace: true</code> ：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 重定向</h2>
<p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从 <code>/home</code> 重定向到 <code>/</code>：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>重定向的目标也可以是一个命名的路由：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>甚至是一个方法，动态返回重定向目标：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例如: 网页默认打开, 匹配路由 <code>"/"</code>, 强制切换到 <code>"/find"</code> 上</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结: 强制重定向后, 还会重新来数组里匹配一次规则</p>
<h2> 别名</h2>
<p>有时候，同一个路径可能需要多个路由，此时可以使用 <code>alias</code> 创建别名。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>有个通用的场景是，你可能要把 <code>src</code> 目录下的 <code>@</code> 指向 <code>src</code> 目录，这时候就可以使用别名：</p>
</blockquote>
<p>在 <code>vue.config.js</code> 中配置别名</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202312230002394.png" type="image/png"/>
    </item>
    <item>
      <title>Composition API</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/Composition%20API.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/Composition%20API.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Composition API</source>
      <description>Options API的弊端 在Vue2中，我们编写组件的方式是Options API： Options API的一大特点就是在对应的属性中编写对应的功能模块； 比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子； 但是这种代码有一个很大的弊端： 当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中； 当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散； 尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）； 下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分： 这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题； 并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中；</description>
      <pubDate>Sat, 16 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Options API的弊端</h2>
<ul>
<li>
<p>在Vue2中，我们编写组件的方式是Options API：</p>
<ul>
<li>Options API的一大特点就是在对应的属性中编写对应的功能模块；</li>
<li>比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子；</li>
</ul>
</li>
<li>
<p>但是这种代码有一个很大的弊端：</p>
<ul>
<li>当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中；</li>
<li>当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散；</li>
<li>尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）；</li>
</ul>
</li>
<li>
<p>下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分：</p>
<ul>
<li>这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题；</li>
<li>并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中；</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312160000793.png" alt="image-20231216000029755" tabindex="0" loading="lazy"><figcaption>image-20231216000029755</figcaption></figure>
<ul>
<li>如果我们能将同一个逻辑关注 点相关的代码收集在一起会更 好。</li>
<li>这就是Composition API想 要做的事情，以及可以帮助我 们完成的事情。</li>
<li>也有人把Vue Composition API简称为VCA。</li>
<li>我们无需再为了一个逻辑关注点在不同的选项块间来回滚动切换。此外，我们现在可以很轻松地将这一组代码移动到一个外部文件中，不再需要为了抽象而重新组织代码，大大降低了重构成本，这在长期维护的大型项目中非常关键。</li>
</ul>
<h2> 认识 组合式 API (Composition API)</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/extras/composition-api-faq.html#what-is-composition-api</p>
</blockquote>
<p>组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。它是一个概括性的术语，涵盖了以下方面的 API：</p>
<ul>
<li><a href="https://cn.vuejs.org/api/reactivity-core.html" target="_blank" rel="noopener noreferrer">响应式 API</a>：例如 <code>ref()</code> 和 <code>reactive()</code>，使我们可以直接创建响应式状态、计算属性和侦听器。</li>
<li><a href="https://cn.vuejs.org/api/composition-api-lifecycle.html" target="_blank" rel="noopener noreferrer">生命周期钩子</a>：例如 <code>onMounted()</code> 和 <code>onUnmounted()</code>，使我们可以在组件各个生命周期阶段添加逻辑。</li>
<li><a href="https://cn.vuejs.org/api/composition-api-dependency-injection.html" target="_blank" rel="noopener noreferrer">依赖注入</a>：例如 <code>provide()</code> 和 <code>inject()</code>，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统。</li>
</ul>
<p>组合式 API 是 Vue 3 及 <a href="https://blog.vuejs.org/posts/vue-2-7-naruto.html" target="_blank" rel="noopener noreferrer">Vue 2.7</a> 的内置功能。对于更老的 Vue 2 版本，可以使用官方维护的插件 <a href="https://github.com/vuejs/composition-api" target="_blank" rel="noopener noreferrer"><code>@vue/composition-api</code></a>。在 Vue 3 中，组合式 API 基本上都会配合 <a href="https://cn.vuejs.org/api/sfc-script-setup.html" target="_blank" rel="noopener noreferrer">``</a> 语法在单文件组件中使用。下面是一个使用组合式 API 的组件示例：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然这套 API 的风格是基于函数的组合，但<strong>组合式 API 并不是函数式编程</strong>。组合式 API 是以 Vue 中数据可变的、细粒度的响应性系统为基础的，而函数式编程通常强调数据不可变。</p>
<h2> setup()</h2>
<blockquote>
<p>以下的代码 均会采用选项式的写法, 组合式 Api 的写法可以参考官方文档, 但基本原理差不多, 而且 Vue3 选项式写法是基于组合式写法产生的!</p>
</blockquote>
<p><code>setup()</code> 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：</p>
<ol>
<li>需要在非单文件组件中使用组合式 API 时。</li>
<li>需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。</li>
</ol>
<h3> setup函数的参数</h3>
<ul>
<li>主要有两个参数:
<ul>
<li>第一个参数：props</li>
<li>第二个参数：context</li>
</ul>
</li>
<li><code>setup</code> 函数的第一个参数是组件的 <code>props</code>。和标准的组件一致，一个 <code>setup</code> 函数的 <code>props</code> 是响应式的，并且会在传入新的 props 时同步更新。：
<ul>
<li>对于定义props的类型，我们还是和之前的规则是一样的，在props选项中定义；</li>
<li>并且在template中依然是可以正常去使用props中的属性，比如message；</li>
<li>如果我们在setup函数中想要使用props，那么不可以通过 this 去获取</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>setup</code> 函数的第一个参数是组件的 <code>props</code>。和标准的组件一致，一个 <code>setup</code> 函数的 <code>props</code> 是响应式的，并且会在传入新的 props 时同步更新。</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意如果你解构了 <code>props</code> 对象，解构出的变量将会丢失响应性。因此我们推荐通过 <code>props.xxx</code> 的形式来使用其中的 props。</p>
<p>如果你确实需要解构 <code>props</code> 对象，或者需要将某个 prop 传到一个外部函数中并保持响应性，那么你可以使用 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#torefs" target="_blank" rel="noopener noreferrer">toRefs()</a> 和 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#toref" target="_blank" rel="noopener noreferrer">toRef()</a> 这两个工具函数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>另外一个参数是context，我们也称之为是一个SetupContext，它里面包含三个属性：
<ul>
<li>attrs：所有的非prop的attribute；</li>
<li>slots：父组件传递过来的插槽（这个在以渲染函数返回时会有作用，后面会讲到）；</li>
<li>emit：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可以通过 this.$emit发出事件）；</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>attrs</code> 和 <code>slots</code> 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 <code>attrs.x</code> 或 <code>slots.x</code> 的形式使用其中的属性。此外还需注意，和 <code>props</code> 不同，<code>attrs</code> 和 <code>slots</code> 的属性都<strong>不是</strong>响应式的。如果你想要基于 <code>attrs</code> 或 <code>slots</code> 的改变来执行副作用，那么你应该在 <code>onBeforeUpdate</code> 生命周期钩子中编写相关逻辑。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> setup函数的返回值</h3>
<p><code>setup</code> 也可以返回一个<a href="https://cn.vuejs.org/guide/extras/render-function.html" target="_blank" rel="noopener noreferrer">渲染函数</a>，此时在渲染函数中可以直接使用在同一作用域下声明的响应式状态：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回一个渲染函数将会阻止我们返回其他东西。对于组件内部来说，这样没有问题，但如果我们想通过模板引用将这个组件的方法暴露给父组件，那就有问题了。</p>
<p>我们可以通过调用 <a href="https://cn.vuejs.org/api/composition-api-setup.html#exposing-public-properties" target="_blank" rel="noopener noreferrer"><code>expose()</code></a> 解决这个问题：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时父组件可以通过模板引用来访问这个 <code>increment</code> 方法。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>setup的返回值可以在模板template中被使用</li>
<li>也就是说可以通过setup的返回值来替代data选项</li>
</ul>
<blockquote>
<p><strong>最后导出的一定要是个对象</strong></p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312162228196.gif" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<blockquote>
<p><strong>因为只是定义了个变量，然后导出了，并没有使它响应式</strong></p>
</blockquote>
<h3> 补充: 为什么 setup 不能使用 this</h3>
<p>在Vue 3中，<code>setup </code>函数是用来替代以前的 <code>data</code>, <code>computed</code>, <code>methods </code>等选项的。<code>setup()</code> 自身并不含对组件实例的访问权，即在 <code>setup()</code> 中访问 <code>this</code> 会是 <code>undefined</code>。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。</p>
<h2> 定义响应式数据的两种方式</h2>
<h3> Reactive API</h3>
<blockquote>
<p>如果想为在setup中定义的数据提供响应式的特性，那么可以使用reactive的函数</p>
<p>ps : 如果传入一个基本数据类型（String、Number、Boolean）会报一个警告</p>
<p>应用场景 : reactive API对传入的类型是有限制的，它要求我们必须传入的是一个对象或者数组类型，最好相互有关联的数据时使用</p>
</blockquote>
<p>比如说想要上面的例子实现响应式, 我们可以做如下操作</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Reactive判断的API</h4>
<ul>
<li>isProxy : 检查对象是否是由 reactive 或 readonly创建的 proxy</li>
<li>isReactive : 检查对象是否是由 reactive创建的响应式代理，如果该代理是 readonly 建的，但包裹了由 reactive 创建的另一个代理，它也会返回 true</li>
<li>isReadonly : 检查对象是否是由 readonly 创建的只读代理</li>
<li>toRaw : 返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）</li>
<li>shallowReactive : 创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)，只响应第一层</li>
<li>shallowReadonly : 创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）只检查第一层</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>以下是一些名词解释:</p>
<ul>
<li>代理对象：在Vue 3中，代理对象是由 reactive 或 readonly 创建的对象的代理，用于跟踪对象的属性的变化。</li>
<li>readonly：readonly 是一个函数，用于创建一个只读的代理对象，该代理对象只能读取属性值，不能修改属性值。</li>
<li>浅层响应式：浅层响应式是指只有对象的第一层属性会被设置为响应式，而嵌套对象的属性不会被设置为响应式。</li>
<li>浅层只读代理：浅层只读代理是指只有对象的第一层属性会被设置为只读，而嵌套对象的属性不会被设置为只读。</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote>
<h3> Ref API</h3>
<blockquote>
<p><strong>Ref函数 : 定义简单类型的数据，也可以定义复杂类型的数据</strong></p>
<p><strong>应用场景 : 定义一些简单的数据，或者从接口中获得的数据</strong></p>
</blockquote>
<ul>
<li>ref 会返回一个可变的响应式对象，该对象作为一个 响应式的引用 维护着它内部的值，这就是ref名称的来源</li>
<li>它内部的值是在<code>ref</code>的 <code>value</code> 属性中被维护的</li>
<li>不管传入的是基本类型还是引用类型，都放在<code>.value</code>中</li>
</ul>
<blockquote>
<p>使用的时候是用 .value，但是有两个注意事项:</p>
<ul>
<li>在模板中引入ref的值时，Vue会自动帮助我们进行解包操作，所以并不需要在模板中通过 ref.value 的方式，直接使用即可</li>
<li>在 setup 函数内部，它依然是一个 ref引用， 所以对其进行操作时，依然需要使用 ref.value的方式</li>
</ul>
</blockquote>
<h4> 基本使用</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Ref自动解包</h4>
<ul>
<li>模板中的解包是浅层的解包，如果我们的代码是下面的方式：</li>
<li>如果我们将<code>ref</code>放到一个<code>reactive</code>的属性当中，那么在模板中使用时，它会自动解包：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意当访问到某个响应式数组或 <code>Map</code> 这样的原生集合类型中的 ref 元素时，<strong>不会</strong>执行 ref 的解包：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Ref判断的API</h4>
<ul>
<li>isRef : 判断值是否是一个ref对象</li>
<li>unref : 如果我们想要获取一个ref引用中的value，那么也可以通过unref方法
<ul>
<li>如果参数是一个 ref，则返回内部值，否则返回参数本身</li>
<li>这是 val = isRef(val) ? val.value : val 的语法糖函数</li>
</ul>
</li>
<li>shallowRef：shallowRef 是用来创建一个浅层的 ref 对象的函数。浅层的意思是只有对象的第一层属性会被设置为响应式，而嵌套对象的属性不会被设置为响应式。这意味着对嵌套对象属性的修改不会触发响应。</li>
<li>triggerRef：triggerRef 用于手动触发与 shallowRef 相关联的副作用。当 shallowRef 关联的数据发生变化时，相关的副作用将被触发执行。</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 自定义Ref =&gt; <strong>customRef</strong></h4>
<ul>
<li>创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制：
<ul>
<li>它需要一个工厂函数，该函数接受 <code>track </code>和 <code>trigger </code>函数作为参数；</li>
<li>并且应该返回一个带有 <code>get </code>和 <code>set</code> 的对象；</li>
</ul>
</li>
<li>这里我们使用一个的案例：
<ul>
<li>对双向绑定的属性进行debounce(节流)的操作</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> readonly</h2>
<h3> 概念</h3>
<blockquote>
<p>在我们传递给其他组件数据时，往往希望其他组件使用我们传递的内容，但是不允许它们修改时，就可以使用 <code>readonly</code>了；</p>
</blockquote>
<ul>
<li>只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的 ref 解包行为与 <code>reactive()</code> 相同，但解包得到的值是只读的。</li>
<li>要避免深层级的转换行为，请使用 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreadonly" target="_blank" rel="noopener noreferrer">shallowReadonly()</a> 作替代。</li>
<li>在开发中常见的readonly方法会传入三个类型的参数：
<ul>
<li>类型一：普通对象</li>
<li>类型二：reactive返回的对象</li>
<li>类型三：ref的对象</li>
</ul>
</li>
<li>在readonly的使用过程中，有如下规则 :
<ul>
<li>readonly返回的对象都是不允许修改的</li>
<li>但是经过readonly处理的原来的对象是允许被修改的
<ul>
<li>比如 const info = readonly(obj)，info对象是不允许被修改的</li>
<li>当obj被修改时，readonly返回的info对象也会被修改</li>
<li>但是不能去修改readonly返回的对象info</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> toRefs &amp;&amp; toRef</h2>
<h3> <strong>toRefs</strong></h3>
<blockquote>
<p>如果使用ES6的解构语法，对reactive返回的对象进行解构获取值，那么之后无论是修改结构后的变量，还是修改reactive 返回的state对象，数据都不再是响应式的</p>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202312171700262.png" alt="image-20231217170024283" tabindex="0" loading="lazy"><figcaption>image-20231217170024283</figcaption></figure>
<ul>
<li>如何改成响应式呢，Vue提供了一个toRefs的函数</li>
<li>可以将reactive返回的对象中的属性都转成ref，这样解构出来的就是响应式的了</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>toRef</strong></h3>
<blockquote>
<p>如果只希望转换reactive对象中的其中某个属性为ref, 那么可以使用toRef的方法</p>
<p><strong>ps : 这个效率会更高点,  这种做法相当于已经在state.name和ref.value之间建立了 链接，任何一个修改都会引起另外一个变化</strong></p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> computed</h2>
<ul>
<li>在前面的Options API中，我们是使用computed选项来完成的；</li>
<li>在Composition API中，我们可以在 setup 函数中使用 computed 方法来编写一个计算属性；</li>
</ul>
<ul>
<li>如何使用computed呢？
<ul>
<li>方式一：接收一个getter函数，并为 getter 函数返回的值，返回一个不变的 ref 对象；</li>
<li>方式二：接收一个具有 get 和 set 的对象，返回一个可变的（可读写）ref 对象；</li>
</ul>
</li>
</ul>
<h3> 方式一</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 方式二</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312171732557.gif" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h2> 生命周期钩子</h2>
<blockquote>
<p>https://cn.vuejs.org/api/composition-api-lifecycle.html</p>
</blockquote>
<blockquote>
<p><strong>setup中可以直接使用导入的onX函数注册生命周期，并且同一个生命周期可以使用多次</strong></p>
<p><strong>所有罗列在本页的 API 都应该在组件的 <code>setup()</code> 阶段被同步调用。相关细节请看<a href="https://cn.vuejs.org/guide/essentials/lifecycle.html" target="_blank" rel="noopener noreferrer">指南 - 生命周期钩子</a>。</strong></p>
<ul>
<li>可以使用直接导入的 onX 函数注册生命周期钩子；</li>
<li>beforeCreate和create在setup中没有相对应的onX的函数
<ul>
<li>如果想要在beforeCreate和create中进行操作</li>
<li>可以把代码直接写入到setup中</li>
<li>setup的执行时序比beforeCreate和create还要早</li>
</ul>
</li>
</ul>
</blockquote>
<figure><img src="https://qiniu.waite.wang/image-20231218002757954.png" alt="image-20231218002757954" tabindex="0" loading="lazy"><figcaption>image-20231218002757954</figcaption></figure>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> setup中使用ref获取元素或组件</h2>
<blockquote>
<p><strong>要定义一个ref对象，绑定到元素或者组件的ref属性上即可</strong></p>
<p><strong>只有在挂载完成后才能拿到值, 所以需要在生命周期中调用拿值</strong></p>
</blockquote>
<h3> 获取元素</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 获取组件</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312172141785.png" alt="image-20231217214139261" tabindex="0" loading="lazy"><figcaption>image-20231217214139261</figcaption></figure>
<h2> 侦听数据的变化</h2>
<ul>
<li>
<p>在前面的Options API中，我们可以通过watch选项来侦听data或者props的数据变化，当数据变化时执行某一些 操作。</p>
</li>
<li>
<p>在Composition API中，我们可以使用watchEffect和watch来完成响应式数据的侦听；</p>
<ul>
<li>watchEffect用于自动收集响应式数据的依赖；</li>
<li>watch需要手动指定侦听的数据源；</li>
</ul>
</li>
</ul>
<h3> watchEffect</h3>
<h4> 基本使用</h4>
<ul>
<li>自动收集响应式数据的依赖</li>
<li>watchEffect传入的函数会被立即执行一次，并且在执行的过程中会收集依赖</li>
<li>只有收集的依赖发生变化时，watchEffect传入的函数才会再次执行</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312171743816.gif" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h4> 停止监听</h4>
<ul>
<li>如果在发生某些情况下，我们希望停止侦听，这个时候我们可以获取watchEffect的返回值函数，调用该函数即可。</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312171747594.gif" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h4> 清除副作用</h4>
<ul>
<li>什么是清除副作用呢？
<ul>
<li>比如在开发中我们需要在侦听函数中执行网络请求，但是在网络请求还没有达到的时候，我们停止了侦听器， 或者侦听器侦听函数被再次执行了</li>
<li>那么上一次的网络请求应该被取消掉，这个时候我们就可以清除上一次的副作用；</li>
</ul>
</li>
<li>在我们给watchEffect传入的函数被回调时，其实可以获取到一个参数：onInvalidate
<ul>
<li>当副作用即将重新执行 或者 侦听器被停止 时会执行该函数传入的回调函数；</li>
<li>我们可以在传入的回调函数中，执行一些清除工作；</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> watchEffect的执行时机</h4>
<ul>
<li>默认情况下，组件的更新会在副作用函数执行之前：
<ul>
<li>如果我们希望在副作用函数中获取到元素，是否可行呢？</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312172147749.png" alt="image-20231217214736939" tabindex="0" loading="lazy"><figcaption>image-20231217214736939</figcaption></figure>
<ul>
<li>我们会发现打印结果打印了两次：
<ul>
<li>这是因为setup函数在执行时就会立即执行传入的副作用函数，这个时候DOM并没有挂载，所以打印为null；</li>
<li>而当DOM挂载时，会给<code>title</code>的<code>ref</code>对象赋值新的值，副作用函数会再次执行，打印出来对应的元素；</li>
</ul>
</li>
<li>这个时候我们需要改变副作用函数的执行时机；
<ul>
<li>它的默认值是pre，它会在元素 挂载 或者 更新 之前执行；</li>
<li>所以我们会先打印出来一个空的，当依赖的title发生改变时，就会再次执行一次，打印出元素；</li>
</ul>
</li>
<li>我们可以设置副作用函数的执行时机：
<ul>
<li>pre : 默认值,它会在元素 挂载 或者 更新 之前执行</li>
<li>post : 元素 挂载 或者 更新 之后执行</li>
<li>sync : 强制同步一起执行，效率很低，不推荐</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Watch</h3>
<ul>
<li>watch的API完全等同于组件watch选项的Property：
<ul>
<li>watch需要侦听特定的数据源，并在回调函数中执行副作用；</li>
<li>默认情况下它是惰性的，只有当被侦听的源发 生变化时才会执行回调；</li>
</ul>
</li>
<li>与watchEffect的比较，watch允许我们：
<ul>
<li>懒执行副作用（第一次不会直接执行）；</li>
<li>更具体的说明当哪些状态发生变化时，触发侦听器的执行；</li>
<li>访问侦听状态变化前后的值；</li>
</ul>
</li>
</ul>
<h4> 侦听单个数据源</h4>
<p>watch侦听函数的数据源有两种类型：</p>
<ul>
<li>一个getter函数：但是该getter函数必须引用可响应式的对象（比如reactive或者ref）；</li>
<li>直接写入一个可响应式的对象，ref（如果是一个 reactive 的对象的侦听, 需要进行某些转换 ）；</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注意: <code>reactive </code>对象获取到的 <code>newValue </code>以及 <code>oldValue </code>本身都是 <code>reactive</code> 对象</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312172311755.png" alt="image-20231217231108219" tabindex="0" loading="lazy"><figcaption>image-20231217231108219</figcaption></figure>
<p>如果希望两者都是一个普通对象, 可以使用以下写法(JavaScript中的展开运算符):</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312172313342.png" alt="image-20231217231330425" tabindex="0" loading="lazy"><figcaption>image-20231217231330425</figcaption></figure>
<p>以下是完整代码:</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote>
<h4> 侦听多个数据源</h4>
<p>当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> watch的选项</h4>
<ul>
<li><strong>deep : 是否深度监听</strong></li>
<li><strong>immediate ： 是否立即执行</strong></li>
</ul>
<blockquote>
<p><code>watch</code> 侦听 <code>reactive</code>时默认是深度侦听的, 但是在使用 <code>{...info}</code>展开运算符时, 是不会深度监听的, 所以我们要设置 <code>deep: True</code></p>
<p>immediate: 第一次会执行</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 停止侦听</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 副作用清理</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> provide &amp;&amp; inject</h2>
<p><code>provide</code> 和 <a href="https://cn.vuejs.org/api/options-composition.html#inject" target="_blank" rel="noopener noreferrer"><code>inject</code></a> 通常成对一起使用，使一个祖先组件作为其后代组件的依赖注入方，无论这个组件的层级有多深都可以注入成功，只要他们处于同一条组件链上。</p>
<p><strong>provide可以传入两个参数 :</strong></p>
<ul>
<li><strong>name：提供的属性名称</strong></li>
<li><strong>value：提供的属性值</strong></li>
</ul>
<p><strong>inject可以传入两个参数 :</strong></p>
<ul>
<li><strong>对应provide传过来的name值</strong></li>
<li><strong>默认值</strong></li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312180036440.gif" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h2> h函数</h2>
<ul>
<li>Vue在生成真实的DOM之前，会将节点转换成VNode，而VNode组合在一起形成一颗树结构，就是虚拟DOM ( VDOM )</li>
<li>事实上，编写的 template 中的HTML 最终也是使用渲染函数生成对应的VNode</li>
<li>那么，如果想充分的利用JavaScript的编程能力，可以自己来编写 createVNode 函数，生成对应的VNode</li>
<li><strong>h() 函数是一个用于创建 vnode 的一个函数</strong></li>
<li><strong>其实更准备的命名是 createVNode() 函数，但是为了简便在Vue将之简化为 h() 函数</strong></li>
</ul>
<h3> 参数</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>第一个参数既可以是一个字符串 (用于原生元素) 也可以是一个 Vue 组件定义。第二个参数是要传递的 prop，第三个参数是子节点。</li>
<li>当创建一个组件的 vnode 时，子节点必须以插槽函数进行传递。如果组件只有默认槽，可以使用单个插槽函数进行传递。否则，必须以插槽函数的对象形式来传递。</li>
<li>为了方便阅读，当子节点不是插槽对象时，可以省略 prop 参数。</li>
</ul>
<h3> 基本使用</h3>
<p>h函数可以在两个地方使用：</p>
<ul>
<li>render函数选项中；</li>
<li>setup函数选项中（setup本身需要是一个函数类型，函数再返回h函数创建的VNode）；</li>
</ul>
<h4> 在render函数选项中</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 在setup函数选项中</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 在setup语法糖中</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 其他写法</h4>
<p>创建原生元素：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建组件：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 函数组件和插槽的使用</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312181955950.png" alt="image-20231218195545969" tabindex="0" loading="lazy"><figcaption>image-20231218195545969</figcaption></figure>
<h2> Jsx</h2>
<p><a href="https://facebook.github.io/jsx/" target="_blank" rel="noopener noreferrer">JSX</a> 是 JavaScript 的一个类似 XML 的扩展，有了它，我们可以用以下的方式来书写代码：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 JSX 表达式中，使用大括号来嵌入动态值：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 配置</h3>
<h4> vue-cli环境</h4>
<ul>
<li><code>npm install @vue/babel-plugin-jsx -D</code></li>
<li><code>babel.config.js</code> 中配置</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312182036029.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h4> vite环境</h4>
<ul>
<li><code>npm install @vitejs/plugin-vue-jsx -D</code></li>
<li><code>vite.config.js</code> 中配置</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 基本使用</h3>
<h4> 在render函数中</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 在setup函数中</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 在setup语法糖中</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> script setup语法糖</h2>
<blockquote>
<p><code>&lt;script setup&gt;</code>是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖，当同时使用 SFC 与组合式 API 时则推荐该语法</p>
</blockquote>
<ul>
<li><strong>更少的样板内容，更简洁的代码</strong></li>
<li><strong>能够使用纯 Typescript 声明 prop 和抛出事件</strong></li>
<li><strong>更好的运行时性能</strong></li>
<li><strong>更好的 IDE 类型推断性能</strong></li>
</ul>
<h3> 顶层的绑定会被暴露给模板</h3>
<blockquote>
<p>当使用<code> &lt;script setup&gt;</code> 的时候，任何在<code>&lt;script setup&gt;</code> 声明的顶层的绑定 (包括变量，函数声明，以及 import 引入的内容) 能在模板中直接使用, 导入的组件也可以直接使用</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> defineProps()</h3>
<blockquote>
<p>defineProps  =&gt;  用来接收从父组件传递过来的数据</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> defineEmits()</h3>
<blockquote>
<p>defineProps  =&gt;  用来发射事件给父组件</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> defineExpose()</h3>
<blockquote>
<p>defineExpose  =&gt;  用来暴露数据</p>
<p>ps : 使用 <code>&lt;script setup&gt; </code>的组件是默认关闭的</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 自定义组件</h2>
<h3> 指令的生命周期</h3>
<ul>
<li>一个指令定义的对象，Vue提供了如下的几个钩子函数：</li>
<li>created：在绑定元素的 attribute 或事件监听器被应用之前调用；</li>
<li>beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用；</li>
<li>mounted：在绑定元素的父组件被挂载后调用；</li>
<li>beforeUpdate：在更新包含组件的 VNode 之前调用；</li>
<li>updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用；</li>
<li>beforeUnmount：在卸载绑定元素的父组件之前调用；</li>
<li>unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次；</li>
</ul>
<h3> 指令钩子</h3>
<p>一个指令的定义对象可以提供几种钩子函数 (都是可选的)：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>指令的钩子会传递以下几种参数：</p>
<ul>
<li><code>el</code>：指令绑定到的元素。这可以用于直接操作 DOM。</li>
<li><code>binding</code>：一个对象，包含以下属性。
<ul>
<li><code>value</code>：传递给指令的值。例如在 <code>v-my-directive="1 + 1"</code> 中，值是 <code>2</code>。</li>
<li><code>oldValue</code>：之前的值，仅在 <code>beforeUpdate</code> 和 <code>updated</code> 中可用。无论值是否更改，它都可用。</li>
<li><code>arg</code>：传递给指令的参数 (如果有的话)。例如在 <code>v-my-directive:foo</code> 中，参数是 <code>"foo"</code>。</li>
<li><code>modifiers</code>：一个包含修饰符的对象 (如果有的话)。例如在 <code>v-my-directive.foo.bar</code> 中，修饰符对象是 <code>{ foo: true, bar: true }</code>。</li>
<li><code>instance</code>：使用该指令的组件实例。</li>
<li><code>dir</code>：指令的定义对象。</li>
</ul>
</li>
<li><code>vnode</code>：代表绑定元素的底层 VNode。</li>
<li><code>prevNode</code>：代表之前的渲染中指令所绑定元素的 VNode。仅在 <code>beforeUpdate</code> 和 <code>updated</code> 钩子中可用。</li>
</ul>
<p>举例来说，像下面这样使用指令：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>binding</code> 参数会是一个这样的对象：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和内置指令类似，自定义指令的参数也可以是动态的。举例来说：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里指令的参数会基于组件的 <code>arg</code> 数据属性响应式地更新。</p>
<blockquote>
<p>除了 <code>el</code> 外，其他参数都是只读的，不要更改它们。若你需要在不同的钩子间共享信息，推荐通过元素的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset" target="_blank" rel="noopener noreferrer">dataset</a> attribute 实现。</p>
</blockquote>
<h3> 简单使用</h3>
<blockquote>
<p><strong>Vue中自带的指令例如v-show、v-for、v-model等等，除了使用这些指令之外，Vue 也允许我们来自定义自己的指令</strong></p>
<p><strong>ps : 一般需要对dom元素进行底层操作时使用</strong></p>
</blockquote>
<ul>
<li>自定义指令分为两种：
<ul>
<li>自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用；</li>
<li>自定义全局指令：app的 directive 方法，可以在任意组件中被使用；</li>
</ul>
</li>
</ul>
<h4> 默认实现方式</h4>
<p>一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。钩子函数会接收到指令所绑定元素作为其参数。下面是一个自定义指令的例子，当一个 input 元素被 Vue 插入到 DOM 中后，它会被自动聚焦：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 使用局部指令</h4>
<p>在 <code>&lt;script setup&gt;</code> 中，任何以 <code>v</code> 开头的驼峰式命名的变量都可以被用作一个自定义指令。在上面的例子中，<code>vFocus</code> 即可以在模板中以 <code>v-focus</code> 的形式使用。</p>
<p>在没有使用 <code>&lt;script setup&gt;</code> 的情况下，自定义指令需要通过 <code>directives</code> 选项注册：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 自定义全局指令</h4>
<ul>
<li><code>main.js</code>中注册</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 进行抽取</h5>
<ul>
<li>注册directives文件夹</li>
<li>/directives/format-time.js</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>/directives/index.js</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>mian.js</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> setup</h4>
<h5> 函数</h5>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 语法糖</h5>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 内置组件</h2>
<h3> Teleport</h3>
<blockquote>
<p><code>&lt;Teleport&gt;</code> 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。</p>
</blockquote>
<ul>
<li>在某些情况下，希望组件不是挂载在当前组件树上的，可能是移动到Vue app之外的其他位置
<ul>
<li>比如移动到body元素上，或者我们有其他的div#app之外的元素上</li>
<li>可以通过teleport来完成</li>
</ul>
</li>
<li>teleport 翻译过来是心灵传输、远距离运输的意思，有两个属性
<ul>
<li>to : 指定将其中的内容移动到的目标元素，可以使用选择器</li>
<li>disabled : 是否禁用 teleport 的功能</li>
</ul>
</li>
</ul>
<h4> 基本使用</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312190008149.png" alt="image-20231219000840061" tabindex="0" loading="lazy"><figcaption>image-20231219000840061</figcaption></figure>
<h4> 挂载到#app之外的指定元素上</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312190013634.png" alt="image-20231219001340177" tabindex="0" loading="lazy"><figcaption>image-20231219001340177</figcaption></figure>
<h4> 多个Teleport</h4>
<blockquote>
<p><strong>会合并，谁先谁在前面</strong></p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312190016061.png" alt="image-20231219001638121" tabindex="0" loading="lazy"><figcaption>image-20231219001638121</figcaption></figure>
<h3> 其他</h3>
<blockquote>
<p><a href="https://ladder.waite.wang/web/vue/learn/components/%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6.html" target="_blank" rel="noopener noreferrer">异步组件 defineAsyncComponent/ Suspense : 实验特性 </a></p>
<p><a href="https://ladder.waite.wang/web/vue/learn/components/%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6.html" target="_blank" rel="noopener noreferrer">动态组件 : component</a></p>
</blockquote>
<h2> Vue插件</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/reusability/plugins.html#plugins</p>
</blockquote>
<ul>
<li>通常我们向Vue全局添加一些功能时，会采用插件的模式，它有两种编写方式：
<ul>
<li>对象类型：一个对象，但是必须包含一个 <code>install </code>的函数，该函数会在安装插件时执行；</li>
<li>函数类型：一个<code>function</code>，这个函数会在安装插件时自动执行；</li>
</ul>
</li>
<li>插件可以完成的功能没有限制，比如下面的几种都是可以的：
<ul>
<li>添加全局方法或者<code>property</code>，通过把它们添加到 <code>config.globalProperties</code> 上实现；</li>
<li>添加全局资源：指令/过滤器/过渡等；</li>
<li>通过全局 <code>mixin </code>来添加一些组件选项；</li>
<li>一个库，提供自己的 API，同时提供上面提到的一个或多个功能；</li>
</ul>
</li>
</ul>
<h3> 对象类型</h3>
<blockquote>
<p>对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 函数类型</h3>
<blockquote>
<p>函数类型：一个function，这个函数会在安装插件时自动执行</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 改写自定义指令</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202312160000793.png" type="image/png"/>
    </item>
    <item>
      <title>Mixins, extends 以及组合式函数</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Mixins, extends 以及组合式函数</source>
      <description>认识 Mixin 在 Vue 2 中，mixins 是创建可重用组件逻辑的主要方式。尽管在 Vue 3 中保留了 mixins 支持，但对于组件间的逻辑复用，使用组合式 API 的组合式函数是现在更推荐的方式。 目前我们是使用组件化的方式在开发整个Vue的应用程序，但是组件和组件之间有时候会存在相同的代码逻辑，我们希望对相同的代码逻辑进行抽取。 在Vue2和Vue3中都支持的一种方式就是使用Mixin来完成： Mixin提供了一种非常灵活的方式，来分发Vue组件中的可复用功能； 一个Mixin对象可以包含任何组件选项； 当组件使用Mixin对象时，所有Mixin对象的选项将被 混合 进入该组件本身的选项中；</description>
      <pubDate>Fri, 15 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 认识 Mixin</h2>
<blockquote>
<p>在 Vue 2 中，mixins 是创建可重用组件逻辑的主要方式。尽管在 Vue 3 中保留了 mixins 支持，但对于组件间的逻辑复用，<a href="https://cn.vuejs.org/guide/reusability/composables.html" target="_blank" rel="noopener noreferrer">使用组合式 API 的组合式函数</a>是现在更推荐的方式。</p>
</blockquote>
<ul>
<li>目前我们是使用组件化的方式在开发整个Vue的应用程序，但是组件和组件之间有时候会存在相同的代码逻辑，我们希望对相同的代码逻辑进行抽取。</li>
<li>在Vue2和Vue3中都支持的一种方式就是使用Mixin来完成：
<ul>
<li>Mixin提供了一种非常灵活的方式，来分发Vue组件中的可复用功能；</li>
<li>一个Mixin对象可以包含任何组件选项；</li>
<li>当组件使用Mixin对象时，所有Mixin对象的选项将被 混合 进入该组件本身的选项中；</li>
</ul>
</li>
</ul>
<h3> 基本使用</h3>
<p><code>mixins</code> 选项接受一个 mixin 对象数组。这些 mixin 对象可以像普通的实例对象一样包含实例选项，它们将使用一定的选项合并逻辑与最终的选项进行合并。举例来说，如果你的 mixin 包含了一个 <code>created</code> 钩子，而组件自身也有一个，那么这两个函数都会被调用。</p>
<p>Mixin 钩子的调用顺序与提供它们的选项顺序相同，且会在组件自身的钩子前被调用。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Mixin的合并规则</h3>
<ul>
<li>如果Mixin对象中的选项和组件对象中的选项发生了冲突，那么Vue会如何操作呢？
<ul>
<li>这里分成不同的情况来进行处理；</li>
</ul>
</li>
<li>情况一：如果是data函数的返回值对象
<ul>
<li>返回值对象默认情况下会进行合并；</li>
<li>如果data返回值对象的属性发生了冲突，那么会保留组件自身的数据；</li>
</ul>
</li>
<li>情况二：如何生命周期钩子函数
<ul>
<li>生命周期的钩子函数会被合并到数组中，都会被调用；</li>
</ul>
</li>
<li>情况三：值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。
<ul>
<li>比如都有methods选项，并且都定义了方法，那么它们都会生效；</li>
<li>但是如果对象的key相同，那么会取组件对象的键值对；</li>
</ul>
</li>
</ul>
<h3> 全局混入 Mixin</h3>
<p>如果组件中的某些选项，是所有的组件都需要拥有的，那么这个时候我们可以使用全局的mixin：</p>
<ul>
<li>全局的Mixin可以使用 应用app的方法 mixin 来完成注册；</li>
<li>一旦注册，那么全局混入的选项将会影响每一个组件；</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> externds</h2>
<ul>
<li>另外一个类似与Mixin的方式是通过extends属性
<ul>
<li>允许声明拓展另外一个组件，类似与Mixins；</li>
</ul>
</li>
</ul>
<p>使一个组件可以继承另一个组件的组件选项。</p>
<p>从实现角度来看，<code>extends</code> 几乎和 <code>mixins</code> 相同。通过 <code>extends</code> 指定的组件将会当作第一个 mixin 来处理。</p>
<p>然而，<code>extends</code> 和 <code>mixins</code> 表达的是不同的目标。<code>mixins</code> 选项基本用于组合功能，而 <code>extends</code> 则一般更关注继承关系。</p>
<p>同 <code>mixins</code> 一样，所有选项 (<code>setup()</code> 除外) 都将使用相关的策略进行合并。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><code>extends</code> 是为选项式 API 设计的，不会处理 <code>setup()</code> 钩子的合并。</p>
<p>在组合式 API 中，逻辑复用的首选模式是“组合”而不是“继承”。如果一个组件中的逻辑需要复用，考虑将相关逻辑提取到<a href="https://cn.vuejs.org/guide/reusability/composables.html#composables" target="_blank" rel="noopener noreferrer">组合式函数</a>中。</p>
<p>如果你仍然想要通过组合式 API 来“继承”一个组件，可以在继承组件的 <code>setup()</code> 中调用基类组件的 <code>setup()</code>：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote>
<h2> 组合式函数</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/reusability/composables.html</p>
</blockquote>
<h3> <a href="https://cn.vuejs.org/guide/reusability/composables.html#what-is-a-composable" target="_blank" rel="noopener noreferrer">什么是“组合式函数”？</a></h3>
<p>在 Vue 应用的概念中，“组合式函数”(Composables) 是一个利用 Vue 的组合式 API 来封装和复用<strong>有状态逻辑</strong>的函数。</p>
<p>当构建前端应用时，我们常常需要复用公共任务的逻辑。例如为了在不同地方格式化时间，我们可能会抽取一个可复用的日期格式化函数。这个函数封装了<strong>无状态的逻辑</strong>：它在接收一些输入后立刻返回所期望的输出。复用无状态逻辑的库有很多，比如你可能已经用过的 <a href="https://lodash.com/" target="_blank" rel="noopener noreferrer">lodash</a> 或是 <a href="https://date-fns.org/" target="_blank" rel="noopener noreferrer">date-fns</a>。</p>
<p>相比之下，有状态逻辑负责管理会随时间而变化的状态。一个简单的例子是跟踪当前鼠标在页面中的位置。在实际应用中，也可能是像触摸手势或与数据库的连接状态这样的更复杂的逻辑。</p>
<h3> 鼠标跟踪器示例</h3>
<p>如果我们要直接在组件中使用组合式 API 实现鼠标跟踪功能，它会是这样的：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，如果我们想在多个组件中复用这个相同的逻辑呢？我们可以把这个逻辑以一个组合式函数的形式提取到外部文件中：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是它在组件中使用的方式：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，核心逻辑完全一致，我们做的只是把它移到一个外部函数中去，并返回需要暴露的状态。和在组件中一样，你也可以在组合式函数中使用所有的<a href="https://cn.vuejs.org/api/#composition-api" target="_blank" rel="noopener noreferrer">组合式 API</a>。现在，<code>useMouse()</code> 的功能可以在任何组件中轻易复用了。</p>
<p>更酷的是，你还可以嵌套多个组合式函数：一个组合式函数可以调用一个或多个其他的组合式函数。这使得我们可以像使用多个组件组合成整个应用一样，用多个较小且逻辑独立的单元来组合形成复杂的逻辑。实际上，这正是为什么我们决定将实现了这一设计模式的 API 集合命名为组合式 API。</p>
<p>举例来说，我们可以将添加和清除 DOM 事件监听器的逻辑也封装进一个组合式函数中：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了它，之前的 <code>useMouse()</code> 组合式函数可以被简化为：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <a href="https://cn.vuejs.org/guide/reusability/composables.html#async-state-example" target="_blank" rel="noopener noreferrer">异步状态示例</a></h3>
<p><code>useMouse()</code> 组合式函数没有接收任何参数，因此让我们再来看一个需要接收一个参数的组合式函数示例。在做异步数据请求时，我们常常需要处理不同的状态：加载中、加载成功和加载失败。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在每个需要获取数据的组件中都要重复这种模式，那就太繁琐了。让我们把它抽取成一个组合式函数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们在组件里只需要：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <a href="https://cn.vuejs.org/guide/reusability/composables.html#accepting-reactive-state" target="_blank" rel="noopener noreferrer">接收响应式状态</a></h3>
<p><code>useFetch()</code> 接收一个静态 URL 字符串作为输入——因此它只会执行一次 fetch 并且就此结束。如果我们想要在 URL 改变时重新 fetch 呢？为了实现这一点，我们需要将响应式状态传入组合式函数，并让它基于传入的状态来创建执行操作的侦听器。</p>
<p>举例来说，<code>useFetch()</code> 应该能够接收一个 ref：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者接收一个 getter 函数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以用 <a href="https://cn.vuejs.org/api/reactivity-core.html#watcheffect" target="_blank" rel="noopener noreferrer"><code>watchEffect()</code></a> 和 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#tovalue" target="_blank" rel="noopener noreferrer"><code>toValue()</code></a> API 来重构我们现有的实现：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>toValue()</code> 是一个在 3.3 版本中新增的 API。它的设计目的是将 ref 或 getter 规范化为值。如果参数是 ref，它会返回 ref 的值；如果参数是函数，它会调用函数并返回其返回值。否则，它会原样返回参数。它的工作方式类似于 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#unref" target="_blank" rel="noopener noreferrer"><code>unref()</code></a>，但对函数有特殊处理。</p>
<p>注意 <code>toValue(url)</code> 是在 <code>watchEffect</code> 回调函数的<strong>内部</strong>调用的。这确保了在 <code>toValue()</code> 规范化期间访问的任何响应式依赖项都会被侦听器跟踪。</p>
<p>这个版本的 <code>useFetch()</code> 现在能接收静态 URL 字符串、ref 和 getter，使其更加灵活。watch effect 会立即运行，并且会跟踪 <code>toValue(url)</code> 期间访问的任何依赖项。如果没有跟踪到依赖项（例如 url 已经是字符串），则 effect 只会运行一次；否则，它将在跟踪到的任何依赖项更改时重新运行。</p>
<h2> <a href="https://cn.vuejs.org/guide/reusability/composables.html#conventions-and-best-practices" target="_blank" rel="noopener noreferrer">约定和最佳实践</a></h2>
<h3> 命名</h3>
<p>组合式函数约定用驼峰命名法命名，并以“use”作为开头。</p>
<h3> 输入参数</h3>
<p>即便不依赖于 ref 或 getter 的响应性，组合式函数也可以接收它们作为参数。如果你正在编写一个可能被其他开发者使用的组合式函数，最好处理一下输入参数是 ref 或 getter 而非原始值的情况。可以利用 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#tovalue" target="_blank" rel="noopener noreferrer"><code>toValue()</code></a> 工具函数来实现：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你的组合式函数在输入参数是 ref 或 getter 的情况下创建了响应式 effect，为了让它能够被正确追踪，请确保要么使用 <code>watch()</code> 显式地监视 ref 或 getter，要么在 <code>watchEffect()</code> 中调用 <code>toValue()</code>。</p>
<p><a href="https://cn.vuejs.org/guide/reusability/composables.html#accepting-reactive-state" target="_blank" rel="noopener noreferrer">前面讨论过的 useFetch() 实现</a>提供了一个接受 ref、getter 或普通值作为输入参数的组合式函数的具体示例。</p>
<h3> <a href="https://cn.vuejs.org/guide/reusability/composables.html#return-values" target="_blank" rel="noopener noreferrer">返回值</a></h3>
<p>你可能已经注意到了，我们一直在组合式函数中使用 <code>ref()</code> 而不是 <code>reactive()</code>。我们推荐的约定是组合式函数始终返回一个包含多个 ref 的普通的非响应式对象，这样该对象在组件中被解构为 ref 之后仍可以保持响应性：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>从组合式函数返回一个响应式对象会导致在对象解构过程中丢失与组合式函数内状态的响应性连接。与之相反，ref 则可以维持这一响应性连接。</p>
<p>如果你更希望以对象属性的形式来使用组合式函数中返回的状态，你可以将返回的对象用 <code>reactive()</code> 包装一次，这样其中的 ref 会被自动解包，例如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 副作用<a href="https://cn.vuejs.org/guide/reusability/composables.html#side-effects" target="_blank" rel="noopener noreferrer"></a></h3>
<p>在组合式函数中的确可以执行副作用 (例如：添加 DOM 事件监听器或者请求数据)，但请注意以下规则：</p>
<ul>
<li>如果你的应用用到了<a href="https://cn.vuejs.org/guide/scaling-up/ssr.html" target="_blank" rel="noopener noreferrer">服务端渲染</a> (SSR)，请确保在组件挂载后才调用的生命周期钩子中执行 DOM 相关的副作用，例如：<code>onMounted()</code>。这些钩子仅会在浏览器中被调用，因此可以确保能访问到 DOM。</li>
<li>确保在 <code>onUnmounted()</code> 时清理副作用。举例来说，如果一个组合式函数设置了一个事件监听器，它就应该在 <code>onUnmounted()</code> 中被移除 (就像我们在 <code>useMouse()</code> 示例中看到的一样)。当然也可以像之前的 <code>useEventListener()</code> 示例那样，使用一个组合式函数来自动帮你做这些事。</li>
</ul>
<h3> 使用限制<a href="https://cn.vuejs.org/guide/reusability/composables.html#usage-restrictions" target="_blank" rel="noopener noreferrer"></a></h3>
<p>组合式函数只能在 <code>&lt;script setup&gt;</code> 或 <code>setup()</code> 钩子中被调用。在这些上下文中，它们也只能被<strong>同步</strong>调用。在某些情况下，你也可以在像 <code>onMounted()</code> 这样的生命周期钩子中调用它们。</p>
<p>这些限制很重要，因为这些是 Vue 用于确定当前活跃的组件实例的上下文。访问活跃的组件实例很有必要，这样才能：</p>
<ol>
<li>将生命周期钩子注册到该组件实例上</li>
<li>将计算属性和监听器注册到该组件实例上，以便在该组件被卸载时停止监听，避免内存泄漏。</li>
</ol>
<blockquote>
<p><code>&lt;script setup&gt;</code>&nbsp;是唯一在调用&nbsp;await&nbsp;之后仍可调用组合式函数的地方。编译器会在异步操作之后自动为你恢复当前的组件实例。</p>
</blockquote>
<h3> <a href="https://cn.vuejs.org/guide/reusability/composables.html#extracting-composables-for-code-organization" target="_blank" rel="noopener noreferrer">通过抽取组合式函数改善代码结构</a></h3>
<p>抽取组合式函数不仅是为了复用，也是为了代码组织。随着组件复杂度的增高，你可能会最终发现组件多得难以查询和理解。组合式 API 会给予你足够的灵活性，让你可以基于逻辑问题将组件代码拆分成更小的函数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在某种程度上，你可以将这些提取出的组合式函数看作是可以相互通信的组件范围内的服务。</p>
<h3> <a href="https://cn.vuejs.org/guide/reusability/composables.html#using-composables-in-options-api" target="_blank" rel="noopener noreferrer">在选项式 API 中使用组合式函数</a></h3>
<p>如果你正在使用选项式 API，组合式函数必须在 <code>setup()</code> 中调用。且其返回的绑定必须在 <code>setup()</code> 中返回，以便暴露给 <code>this</code> 及其模板：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> <a href="https://cn.vuejs.org/guide/reusability/composables.html#vs-mixins" target="_blank" rel="noopener noreferrer">对比</a></h2>
<p>Vue 2 的用户可能会对 <a href="https://cn.vuejs.org/api/options-composition.html#mixins" target="_blank" rel="noopener noreferrer">mixins</a> 选项比较熟悉。它也让我们能够把组件逻辑提取到可复用的单元里。然而 mixins 有三个主要的短板：</p>
<ol>
<li><strong>不清晰的数据来源</strong>：当使用了多个 mixin 时，实例上的数据属性来自哪个 mixin 变得不清晰，这使追溯实现和理解组件行为变得困难。这也是我们推荐在组合式函数中使用 ref + 解构模式的理由：让属性的来源在消费组件时一目了然。</li>
<li><strong>命名空间冲突</strong>：多个来自不同作者的 mixin 可能会注册相同的属性名，造成命名冲突。若使用组合式函数，你可以通过在解构变量时对变量进行重命名来避免相同的键名。</li>
<li><strong>隐式的跨 mixin 交流</strong>：多个 mixin 需要依赖共享的属性名来进行相互作用，这使得它们隐性地耦合在一起。而一个组合式函数的返回值可以作为另一个组合式函数的参数被传入，像普通函数那样。</li>
</ol>
<p>基于上述理由，我们不再推荐在 Vue 3 中继续使用 mixin。保留该功能只是为了项目迁移的需求和照顾熟悉它的用户。</p>
<h3> <a href="https://cn.vuejs.org/guide/reusability/composables.html#vs-renderless-components" target="_blank" rel="noopener noreferrer">和无渲染组件的对比</a></h3>
<p>在组件插槽一章中，我们讨论过了基于作用域插槽的<a href="https://cn.vuejs.org/guide/components/slots.html#renderless-components" target="_blank" rel="noopener noreferrer">无渲染组件</a>。我们甚至用它实现了一样的鼠标追踪器示例。</p>
<p>组合式函数相对于无渲染组件的主要优势是：组合式函数不会产生额外的组件实例开销。当在整个应用中使用时，由无渲染组件产生的额外组件实例会带来无法忽视的性能开销。</p>
<p>我们推荐在纯逻辑复用时使用组合式函数，在需要同时复用逻辑和视图布局时使用无渲染组件。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Vue 过渡与动画初体验</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/animation/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/animation/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Vue 过渡与动画初体验</source>
      <description>认识动画 在开发中，我们想要给一个组件的显示和消失添加某种过渡动画，可以很好的增加用户体验： React框架本身并没有提供任何动画相关的API，所以在React中使用过渡动画我们需要使用一个第三方库 react-transition-group； Vue中为我们提供一些内置组件和对应的API来完成动画，利用它们我们可以方便的实现过渡动画效果； 我们来看一个案例： Hello World的显示和隐藏； 通过下面的代码实现，是不会有任何动画效果的；</description>
      <pubDate>Fri, 15 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 认识动画</h2>
<ul>
<li>在开发中，我们想要给一个组件的显示和消失添加某种过渡动画，可以很好的增加用户体验：
<ul>
<li>React框架本身并没有提供任何动画相关的API，所以在React中使用过渡动画我们需要使用一个第三方库 react-transition-group；</li>
<li>Vue中为我们提供一些内置组件和对应的API来完成动画，利用它们我们可以方便的实现过渡动画效果；</li>
</ul>
</li>
<li>我们来看一个案例：
<ul>
<li>Hello World的显示和隐藏；</li>
<li>通过下面的代码实现，是不会有任何动画效果的；</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>没有动画的情况下，整个内容的显示和隐藏会非常的生硬：
<ul>
<li>如果我们希望给单元素或者组件实现过渡动画，可以使用 <code>transition</code>内置组件来完成动画；</li>
</ul>
</li>
</ul>
<h2> Vue的 transition 动画</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/built-ins/transition.html#transition</p>
</blockquote>
<p><code>&lt;Transition&gt;</code> 会在一个元素或组件进入和离开 DOM 时应用动画。</p>
<p><code>&lt;Transition&gt;</code> 是一个内置组件，这意味着它在任意别的组件中都可以被使用，无需注册。它可以将进入和离开动画应用到通过默认插槽传递给它的元素或组件上。进入或离开可以由以下的条件之一触发：</p>
<ul>
<li>由 <code>v-if</code> 所触发的切换</li>
<li>由 <code>v-show</code> 所触发的切换</li>
<li>由特殊元素 <code>&lt;component&gt;</code> 切换的动态组件</li>
<li>改变特殊的 <code>key</code> 属性</li>
</ul>
<p>以下是最基本用法的示例：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><code>&lt;Transition&gt;</code> 仅支持单个元素或组件作为其插槽内容。如果内容是一个组件，这个组件必须仅有一个根元素。</p>
</blockquote>
<p>当一个 <code>&lt;Transition&gt;</code> 组件中的元素被插入或移除时，会发生下面这些事情：</p>
<ol>
<li>Vue 会自动检测目标元素是否应用了 CSS 过渡或动画。如果是，则一些 <a href="https://cn.vuejs.org/guide/built-ins/transition.html#transition-classes" target="_blank" rel="noopener noreferrer">CSS 过渡 class</a> 会在适当的时机被添加和移除。</li>
<li>如果有作为监听器的 <a href="https://cn.vuejs.org/guide/built-ins/transition.html#javascript-hooks" target="_blank" rel="noopener noreferrer">JavaScript 钩子</a>，这些钩子函数会在适当时机被调用。</li>
<li>如果没有探测到 CSS 过渡或动画、也没有提供 JavaScript 钩子，那么 DOM 的插入、删除操作将在浏览器的下一个动画帧后执行。</li>
</ol>
<h3> 基于 CSS 的过渡效果</h3>
<h4> <a href="https://cn.vuejs.org/guide/built-ins/transition.html#transition-classes" target="_blank" rel="noopener noreferrer">CSS 过渡 class</a></h4>
<p>一共有 6 个应用于进入与离开过渡效果的 CSS class。</p>
<figure><img src="https://qiniu.waite.wang/202312111414504.png" alt="过渡图示" tabindex="0" loading="lazy"><figcaption>过渡图示</figcaption></figure>
<ol>
<li><code>v-enter-from</code>：进入动画的起始状态。在元素插入之前添加，在元素插入完成后的下一帧移除。</li>
<li><code>v-enter-active</code>：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。</li>
<li><code>v-enter-to</code>：进入动画的结束状态。在元素插入完成后的下一帧被添加 (也就是 <code>v-enter-from</code> 被移除的同时)，在过渡或动画完成之后移除。</li>
<li><code>v-leave-from</code>：离开动画的起始状态。在离开过渡效果被触发时立即添加，在一帧后被移除。</li>
<li><code>v-leave-active</code>：离开动画的生效状态。应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡或动画完成之后移除。这个 class 可以被用来定义离开动画的持续时间、延迟与速度曲线类型。</li>
<li><code>v-leave-to</code>：离开动画的结束状态。在一个离开动画被触发后的下一帧被添加 (也就是 <code>v-leave-from</code> 被移除的同时)，在过渡或动画完成之后移除。</li>
</ol>
<h4> 为过渡效果命名</h4>
<p>我们可以给 <code>&lt;Transition&gt;</code> 组件传一个 <code>name</code> prop 来声明一个过渡效果名：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于一个有名字的过渡效果，对它起作用的过渡 class 会以其名字而不是 <code>v</code> 作为前缀。比如，上方例子中被应用的 class 将会是 <code>fade-enter-active</code> 而不是 <code>v-enter-active</code>。这个“fade”过渡的 class 应该是这样：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> CSS 的 transition</h4>
<p><code>&lt;Transition&gt;</code> 一般都会搭配<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions" target="_blank" rel="noopener noreferrer">原生 CSS 过渡</a>一起使用，正如你在上面的例子中所看到的那样。这个 <code>transition</code> CSS 属性是一个简写形式，使我们可以一次定义一个过渡的各个方面，包括需要执行动画的属性、持续时间和<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function" target="_blank" rel="noopener noreferrer">速度曲线</a>。</p>
<p>下面是一个更高级的例子，它使用了不同的持续时间和速度曲线来过渡多个属性：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> CSS 的 animation</h2>
<blockquote>
<p>帧动画, 可以指定在什么时间是什么状态!</p>
</blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations" target="_blank" rel="noopener noreferrer">原生 CSS 动画</a>和 CSS transition 的应用方式基本上是相同的，只有一点不同，那就是 <code>*-enter-from</code> 不是在元素插入后立即移除，而是在一个 <code>animationend</code> 事件触发时被移除。</p>
<p>对于大多数的 CSS 动画，我们可以简单地在 <code>*-enter-active</code> 和 <code>*-leave-active</code> class 下声明它们。下面是一个示例：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> <a href="https://cn.vuejs.org/guide/built-ins/transition.html#custom-transition-classes" target="_blank" rel="noopener noreferrer">自定义过渡 class</a></h2>
<p>你也可以向 <code>&lt;Transition&gt;</code> 传递以下的 props 来指定自定义的过渡 class：</p>
<ul>
<li><code>enter-from-class</code></li>
<li><code>enter-active-class</code></li>
<li><code>enter-to-class</code></li>
<li><code>leave-from-class</code></li>
<li><code>leave-active-class</code></li>
<li><code>leave-to-class</code></li>
</ul>
<p>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如  Animate.css.</p>
<p>你传入的这些 class 会覆盖相应阶段的默认 class 名。这个功能在你想要在 Vue 的动画机制下集成其他的第三方 CSS 动画库时非常有用，比如 <a href="https://daneden.github.io/animate.css/" target="_blank" rel="noopener noreferrer">Animate.css</a>：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 同时设置过渡和动画</h2>
<ul>
<li>Vue为了知道过渡的完成，内部是在监听 <code>transitionend </code>或 <code>animationend</code>，到底使用哪一个取决于元素应用的 CSS规则：
<ul>
<li>如果我们只是使用了其中的一个，那么Vue能自动识别类型并设置监听；</li>
</ul>
</li>
<li>但是如果我们同时使用了过渡和动画呢？
<ul>
<li>并且在这个情况下可能某一个动画执行结束时，另外一个动画还没有结束；</li>
<li>在这种情况下，我们可以设置 type 属性为 animation 或者 transition 来明确的告知Vue监听的类型；</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> <a href="https://cn.vuejs.org/guide/built-ins/transition.html#nested-transitions-and-explicit-transition-durations" target="_blank" rel="noopener noreferrer">深层级过渡与显式过渡时长</a></h2>
<p>尽管过渡 class 仅能应用在 <code>&lt;Transition&gt;</code> 的直接子元素上，我们还是可以使用深层级的 CSS 选择器，在深层级的元素上触发过渡效果。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们甚至可以在深层元素上添加一个过渡延迟，从而创建一个带渐进延迟的动画序列：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然而，这会带来一个小问题。默认情况下，<code>&lt;Transition&gt;</code> 组件会通过监听过渡根元素上的<strong>第一个</strong> <code>transitionend</code> 或者 <code>animationend</code> 事件来尝试自动判断过渡何时结束。而在嵌套的过渡中，期望的行为应该是等待所有内部元素的过渡完成。</p>
<p>在这种情况下，你可以通过向 <code>&lt;Transition&gt;</code> 组件传入 <code>duration</code> prop 来显式指定过渡的持续时间 (以毫秒为单位)。总持续时间应该匹配延迟加上内部元素的过渡持续时间：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果有必要的话，你也可以用对象的形式传入，分开指定进入和离开所需的时间：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> <a href="https://cn.vuejs.org/guide/built-ins/transition.html#transition-modes" target="_blank" rel="noopener noreferrer">过渡模式</a></h2>
<p>在之前的例子中，进入和离开的元素都是在同时开始动画的，因此我们不得不将它们设为 <code>position: absolute</code> 以避免二者同时存在时出现的布局问题。</p>
<p>然而，很多情况下这可能并不符合需求。我们可能想要先执行离开动画，然后在其完成<strong>之后</strong>再执行元素的进入动画。手动编排这样的动画是非常复杂的，好在我们可以通过向 <code>&lt;Transition&gt;</code> 传入一个 <code>mode</code> prop 来实现这个行为：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>&lt;Transition&gt;</code> 也支持 <code>mode="in-out"</code>，虽然这并不常用。</p>
<p><code>&lt;Transition&gt;</code> 也可以作用于<a href="https://cn.vuejs.org/guide/essentials/component-basics.html#dynamic-components" target="_blank" rel="noopener noreferrer">动态组件</a>之间的切换：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <a href="https://cn.vuejs.org/guide/built-ins/transition.html#transition-on-appear" target="_blank" rel="noopener noreferrer">出现时过渡</a></h3>
<p>如果你想在某个节点初次渲染时应用一个过渡效果，你可以添加 <code>appear</code> prop：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <a href="https://cn.vuejs.org/guide/built-ins/transition.html#transition-between-elements" target="_blank" rel="noopener noreferrer">元素间过渡</a></h3>
<p>除了通过 <code>v-if</code> / <code>v-show</code> 切换一个元素，我们也可以通过 <code>v-if</code> / <code>v-else</code> / <code>v-else-if</code> 在几个组件间进行切换，只要确保任一时刻只会有一个元素被渲染即可：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> JavaScript 钩子</h2>
<p>你可以通过监听 <code>&lt;Transition&gt;</code> 组件事件的方式在过渡过程中挂上钩子函数：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些钩子可以与 CSS 过渡或动画结合使用，也可以单独使用。</p>
<p>在使用仅由 JavaScript 执行的动画时，最好是添加一个 <code>:css="false"</code> prop。这显式地向 Vue 表明可以跳过对 CSS 过渡的自动探测。除了性能稍好一些之外，还可以防止 CSS 规则意外地干扰过渡效果。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在有了 <code>:css="false"</code> 后，我们就自己全权负责控制什么时候过渡结束了。这种情况下对于 <code>@enter</code> 和 <code>@leave</code> 钩子来说，回调函数 <code>done</code> 就是必须的。否则，钩子将被同步调用，过渡将立即完成。</p>
<p>这里是使用 <a href="https://greensock.com/" target="_blank" rel="noopener noreferrer">GreenSock 库</a>执行动画的一个示例，你也可以使用任何你想要的库，比如 <a href="https://animejs.com/" target="_blank" rel="noopener noreferrer">Anime.js</a> 或者 <a href="https://motion.dev/" target="_blank" rel="noopener noreferrer">Motion One</a>。</p>
<h2> 第三方库的使用</h2>
<h3> animate.css</h3>
<blockquote>
<p>https://animate.style/</p>
</blockquote>
<ul>
<li>如果我们手动一个个来编写这些动画，那么效率是比较低的，所以在开发中我们可能会引用一些第三方库的动画库， 比如animate.css。</li>
<li>Animate.css是一个已经<strong>准备好的、跨平台的</strong>动画库为我们的web项目，对于强调、主页、滑动、注意力引导 非常有用；</li>
</ul>
<p><strong>如何使用?</strong></p>
<ul>
<li>
<p>安装animate.css：</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>在main.js中导入animate.css：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>接下来在使用的时候我们有两种用法：</p>
<ul>
<li>用法一：直接使用animate库中定义的 keyframes 动画；</li>
<li>用法二：直接使用animate库提供给我们的类；</li>
</ul>
</li>
<li>
<p>使用参考: <a href="https://cn.vuejs.org/guide/built-ins/transition.html#custom-transition-classes" target="_blank" rel="noopener noreferrer">自定义过渡 class</a></p>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> gsap</h3>
<blockquote>
<p>https://gsap.com/docs/v3/Installation/</p>
<p>https://gsap.framer.wiki/stated -- 中文文档</p>
</blockquote>
<ul>
<li>某些情况下我们希望通过JavaScript来实现一些动画的效果，这个时候我们可以选择使用gsap库来完成。</li>
<li>什么是<code>gsap</code>呢？
<ul>
<li><code>GSAP</code>是<code>The GreenSock Animation</code></li>
<li><code>latform</code>（<code>GreenSock</code>动画平台）的缩写；</li>
</ul>
</li>
<li>它可以通过JavaScript为CSS属性、SVG、Canvas等设置动画，并且是浏览器兼容的；</li>
</ul>
<p><strong>如何使用</strong></p>
<ul>
<li>安装</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>调用 api</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>enter</code>函数接收两个参数：<code>el</code>和<code>done</code>。<code>el</code>是正在进入的元素，<code>done</code>是一个在进入过渡完成时应该被调用的函数。</li>
<li><code>onComplete: done</code>部分在动画完成时调用<code>done</code>函数。这是必要的，以便让Vue知道过渡已经完成。如果不调用<code>done</code>，Vue可能无法正确地确定过渡的结束，这可能会导致意外的行为。</li>
<li>在使用仅由 JavaScript 执行的动画时，最好是添加一个 <code>:css="false"</code> prop。这显式地向 Vue 表明可以跳过对 CSS 过渡的自动探测。除了性能稍好一些之外，还可以防止 CSS 规则意外地干扰过渡效果。</li>
</ul>
<h3> gsap 数字递增效果</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 认识列表的过渡</h2>
<ul>
<li>目前为止，过渡动画我们只要是针对单个元素或者组件的：
<ul>
<li>要么是单个节点；</li>
<li>要么是同一时间渲染多个节点中的一个；</li>
</ul>
</li>
<li>那么如果希望渲染的是一个列表，并且该列表中添加删除数据也希望有动画执行呢？
<ul>
<li>这个时候我们要使用 组件来完成；</li>
</ul>
</li>
<li>使用 有如下的特点：
<ul>
<li>默认情况下，它不会渲染一个元素的包裹器，但是你可以指定一个元素并以 tag attribute 进行渲染；</li>
<li>过渡模式不可用，因为我们不再相互切换特有的元素；</li>
<li>内部元素总是需要提供唯一的 key attribute 值；</li>
<li>CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身；</li>
</ul>
</li>
</ul>
<h3> 基本使用</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>methods</code>对象定义了四个方法：</p>
<ul>
<li><code>addNum</code>方法在<code>numbers</code>数组的随机位置插入一个新的数字，然后<code>numCounter</code>加1。</li>
<li><code>removeNum</code>方法从<code>numbers</code>数组的随机位置删除一个数字。</li>
<li><code>shuffleNum</code>方法使用lodash的<code>shuffle</code>函数打乱<code>numbers</code>数组的顺序。</li>
<li><code>randomIndex</code>方法返回一个<code>numbers</code>数组的随机索引</li>
</ul>
<h3> 列表过渡的移动动画</h3>
<p>在上面的案例中虽然新增的或者删除的节点是有动画的，但是对于哪些其他需要移动的节点是没有动画的：</p>
<ul>
<li>我们可以通过使用一个新增的 v-move 的class来完成动画；</li>
<li>它会在元素改变位置的过程中应用；</li>
<li>像之前的名字一样，我们可以通过name来自定义前缀;</li>
</ul>
<blockquote>
<p><code>&lt;TransitionGroup&gt;</code> 支持通过 CSS transform 控制移动效果。当一个子节点在屏幕上的位置在更新之后发生变化时，它会被添加一个使其位移的 CSS class (基于 <code>name</code> attribute 推导，或使用 <code>move-class</code> prop 显式配置)。如果使其位移的 class 被添加时 CSS 的 <code>transform</code> 属性是“可过渡的”，那么该元素会基于 <a href="https://aerotwist.com/blog/flip-your-animations/" target="_blank" rel="noopener noreferrer">FLIP 技巧</a>平滑地到达动画终点。</p>
<p>https://cn.vuejs.org/api/built-in-components.html#transitiongroup</p>
</blockquote>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 演练 =&gt; 列表的交替动画</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202312111414504.png" type="image/png"/>
    </item>
    <item>
      <title>生命周期</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F..html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F..html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">生命周期</source>
      <description>什么是生命周期? 什么是生命周期呢？ 每个组件都可能会经历从创建、挂载、更新、卸载等一系列的过程； 在这个过程中的某一个阶段，用于可能会想要添加一些属于自己的代码逻辑（比如组件创建完后就请求一些服 务器数据）； 生命周期函数： 生命周期函数是一些钩子函数，在某个时间会被Vue源码内部进行回调； 通过对生命周期函数的回调，我们可以知道目前组件正在经历什么阶段； 那么我们就可以在该生命周期中编写属于自己的逻辑代码了；</description>
      <pubDate>Fri, 08 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是生命周期?</h2>
<p>什么是生命周期呢？</p>
<ul>
<li>每个组件都可能会经历从创建、挂载、更新、卸载等一系列的过程；</li>
<li>在这个过程中的某一个阶段，用于可能会想要添加一些属于自己的代码逻辑（比如组件创建完后就请求一些服 务器数据）；</li>
</ul>
<p>生命周期函数：</p>
<ul>
<li>生命周期函数是一些钩子函数，在某个时间会被Vue源码内部进行回调；</li>
<li>通过对生命周期函数的回调，我们可以知道目前组件正在经历什么阶段；</li>
<li>那么我们就可以在该生命周期中编写属于自己的逻辑代码了；</li>
</ul>
<h3> <a href="https://cn.vuejs.org/guide/essentials/lifecycle.html#registering-lifecycle-hooks" target="_blank" rel="noopener noreferrer">注册周期钩子</a></h3>
<p>举例来说，<code>mounted</code> 钩子可以用来在组件完成初始渲染并创建 DOM 节点后运行代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有其他一些钩子，会在实例生命周期的不同阶段被调用，最常用的是 <a href="https://cn.vuejs.org/api/options-lifecycle.html#mounted" target="_blank" rel="noopener noreferrer"><code>mounted</code></a>、<a href="https://cn.vuejs.org/api/options-lifecycle.html#updated" target="_blank" rel="noopener noreferrer"><code>updated</code></a> 和 <a href="https://cn.vuejs.org/api/options-lifecycle.html#unmounted" target="_blank" rel="noopener noreferrer"><code>unmounted</code></a>。</p>
<p>所有生命周期钩子函数的 <code>this</code> 上下文都会自动指向当前调用它的组件实例。注意：避免用箭头函数来定义生命周期钩子，因为如果这样的话你将无法在函数中通过 <code>this</code> 获取组件实例。</p>
<h2> 组件的生命周期</h2>
<blockquote>
<p>https://cn.vuejs.org/api/options-lifecycle.html#options-lifecycle</p>
</blockquote>
<ol>
<li><code>beforeCreate( )</code>——准备创建</li>
<li><code>created( )</code>——创建完成</li>
<li><code>beforeMount( )</code>—挂载之前</li>
<li><code>mounted( )</code>——挂载完成</li>
<li><code>beforeUpdate( )</code>——更新之前</li>
<li><code>updated( )</code>——更新完成</li>
<li><code>activated( )</code>——当组件在 keep-alive 内被切换的时候它的 monnted( ) 被取代为activated</li>
<li><code>deactivated( )</code>——当组件在 keep-alive 内被切换的时候它的 unmonnted( ) 被取代为deactivated</li>
<li><code>beforeUnmount( )</code>—卸载之前</li>
<li><code>unmounted( )</code>——卸载完成</li>
<li><code>errorCaptured</code>——返回子孙组件中的错误</li>
<li><code>renderTracked</code>——虚拟 DOM 重新渲染时调用。接收 <code>debugger event</code> 作为参数。告诉你哪个操作跟踪了组件以及该操作的目标对象和键。</li>
<li><code>renderTiggered</code>——虚拟 DOM 重新渲染被触发时调用。接收 <code>debugger event</code> 作为参数。告诉你是什么操作触发了重新渲染，以及该操作的目标对象和键</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202312082224668.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202312082224668.png" type="image/png"/>
    </item>
    <item>
      <title>动态组件</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/components/%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/components/%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">动态组件</source>
      <description>切换组件案例 比如我们现在想要实现了一个功能： 点击一个tab-bar，切换不同的组件显示； 这个案例我们可以通过两种不同的实现思路来实现： 方式一：通过v-if来判断，显示不同的组件； 方式二：动态组件的方式；</description>
      <pubDate>Fri, 08 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 切换组件案例</h2>
<ul>
<li>
<p>比如我们现在想要实现了一个功能：</p>
<ul>
<li>点击一个tab-bar，切换不同的组件显示；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312091618269.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>这个案例我们可以通过两种不同的实现思路来实现：</p>
<ul>
<li>方式一：通过v-if来判断，显示不同的组件；</li>
<li>方式二：动态组件的方式；</li>
</ul>
</li>
</ul>
<h3> v-if显示不同的组件</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 动态组件</h2>
<p>Vue.js 的动态组件是指可以根据不同的数据渲染不同的组件的功能。你可以使用 Vue.js 的 <code>&lt;component&gt; </code>元素来实现动态组件。</p>
<p>例如，你可以在父组件中定义一个数据属性，根据这个属性的值来决定渲染哪个子组件。然后，在模板中使用 <code>&lt;component&gt; </code>元素，并将该数据属性绑定到 is 属性上，这样就可以动态地渲染不同的子组件了。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 动态组件的传值</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> keep-alive</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/built-ins/keep-alive.html#keepalive</p>
</blockquote>
<p><code>&lt;KeepAlive&gt;</code> 是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。</p>
<p>默认情况下，一个组件实例在被替换掉后会被销毁。这会导致它丢失其中所有已变化的状态——当这个组件再一次被显示时，会创建一个只带有初始状态的新实例。</p>
<p>在切换时创建新的组件实例通常是有意义的，但在这个例子中，我们的确想要组件能在被“切走”的时候保留它们的状态。要解决这个问题，我们可以用 <code>&lt;KeepAlive&gt;</code> 内置组件将这些动态组件包装起来：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>在 <a href="https://cn.vuejs.org/guide/essentials/component-basics.html#in-dom-template-parsing-caveats" target="_blank" rel="noopener noreferrer">DOM 内模板</a>中使用时，它应该被写为 <code>&lt;keep-alive&gt;</code>。</p>
</blockquote>
<h3> 包含/排除</h3>
<p><code>&lt;KeepAlive&gt;</code> 默认会缓存内部的所有组件实例，但我们可以通过 <code>include</code> 和 <code>exclude</code> prop 来定制该行为。这两个 prop 的值都可以是一个以英文逗号分隔的字符串、一个正则表达式，或是包含这两种类型的一个数组：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>它会根据组件的 <a href="https://cn.vuejs.org/api/options-misc.html#name" target="_blank" rel="noopener noreferrer"><code>name</code></a> 选项进行匹配，所以组件如果想要条件性地被 <code>KeepAlive</code> 缓存，就必须显式声明一个 <code>name</code> 选项。</p>
</blockquote>
<h3> 最大缓存实例数</h3>
<p>我们可以通过传入 <code>max</code> prop 来限制可被缓存的最大组件实例数。<code>&lt;KeepAlive&gt;</code> 的行为在指定了 <code>max</code> 后类似一个 <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)" target="_blank" rel="noopener noreferrer">LRU 缓存</a>：如果缓存的实例数量即将超过指定的那个最大数量，则最久没有被访问的缓存实例将被销毁，以便为新的实例腾出空间。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202312091618269.png" type="image/png"/>
    </item>
    <item>
      <title>异步组件</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/components/%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/components/%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">异步组件</source>
      <description>https://cn.vuejs.org/guide/components/async.html#async-components 基本用法 在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 defineAsyncComponent 方法来实现此功能：</description>
      <pubDate>Fri, 08 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>https://cn.vuejs.org/guide/components/async.html#async-components</p>
</blockquote>
<h2> 基本用法</h2>
<p>在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 <a href="https://cn.vuejs.org/api/general.html#defineasynccomponent" target="_blank" rel="noopener noreferrer"><code>defineAsyncComponent</code></a> 方法来实现此功能：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，<code>defineAsyncComponent</code> 方法接收一个返回 Promise 的加载函数。这个 Promise 的 <code>resolve</code> 回调方法应该在从服务器获得组件定义时调用。你也可以调用 <code>reject(reason)</code> 表明加载失败。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import" target="_blank" rel="noopener noreferrer">ES 模块动态导入</a>也会返回一个 Promise，所以多数情况下我们会将它和 <code>defineAsyncComponent</code> 搭配使用。类似 Vite 和 Webpack 这样的构建工具也支持此语法 (并且会将它们作为打包时的代码分割点)，因此我们也可以用它来导入 Vue 单文件组件：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后得到的 <code>AsyncComp</code> 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。</p>
<ul>
<li>
<p><code>defineAsyncComponent</code>接受两种类型的参数：</p>
<ul>
<li>类型一：工厂函数，该工厂函数需要返回一个Promise对象；</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>类型二：接受一个对象类型，对异步函数进行配置；</li>
<li>异步操作不可避免地会涉及到加载和错误状态，因此 <code>defineAsyncComponent()</code> 也支持在高级选项中处理这些状态：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得很快，加载组件和最终组件之间的替换太快可能产生闪烁，反而影响用户感受。</li>
<li>如果提供了一个报错组件，则它会在加载器函数返回的 Promise 抛错时被渲染。你还可以指定一个超时时间，在请求耗时超过指定时间时也会渲染报错组件。</li>
</ul>
</li>
</ul>
<h2> 搭配 Suspense 使用</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/built-ins/suspense.html</p>
<p><code>&lt;Suspense&gt;</code> 是一项实验性功能。它不一定会最终成为稳定功能，并且在稳定之前相关 API 也可能会发生变化。</p>
</blockquote>
<p><code>&lt;Suspense&gt;</code> 是一个内置组件，用来在组件树中协调对异步依赖的处理。它让我们可以在组件树上层等待下层的多个嵌套异步依赖项解析完成，并可以在等待时渲染一个加载状态。</p>
<p><code>&lt;Suspense&gt;</code> 组件有两个插槽：<code>#default</code> 和 <code>#fallback</code>。两个插槽都只允许<strong>一个</strong>直接子节点。在可能的时候都将显示默认槽中的节点。否则将显示后备槽中的节点。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在初始渲染时，<code>&lt;Suspense&gt;</code> 将在内存中渲染其默认的插槽内容。如果在这个过程中遇到任何异步依赖，则会进入<strong>挂起</strong>状态。在挂起状态期间，展示的是后备内容。当所有遇到的异步依赖都完成后，<code>&lt;Suspense&gt;</code> 会进入<strong>完成</strong>状态，并将展示出默认插槽的内容。</p>
<p>如果在初次渲染时没有遇到异步依赖，<code>&lt;Suspense&gt;</code> 会直接进入完成状态。</p>
<p>进入完成状态后，只有当默认插槽的根节点被替换时，<code>&lt;Suspense&gt;</code> 才会回到挂起状态。组件树中新的更深层次的异步依赖<strong>不会</strong>造成 <code>&lt;Suspense&gt;</code> 回退到挂起状态。</p>
<p>发生回退时，后备内容不会立即展示出来。相反，<code>&lt;Suspense&gt;</code> 在等待新内容和异步依赖完成时，会展示之前 <code>#default</code> 插槽的内容。这个行为可以通过一个 <code>timeout</code> prop 进行配置：在等待渲染新内容耗时超过 <code>timeout</code> 之后，<code>&lt;Suspense&gt;</code> 将会切换为展示后备内容。若 <code>timeout</code> 值为 <code>0</code> 将导致在替换默认内容时立即显示后备内容。</p>
<h3> 和其他组件结合</h3>
<p>我们常常会将 <code>&lt;Suspense&gt;</code> 和 <a href="https://cn.vuejs.org/guide/built-ins/keep-alive.html" target="_blank" rel="noopener noreferrer"><code>](https://cn.vuejs.org/guide/built-ins/transition.html)、[</code></a> 等组件结合。要保证这些组件都能正常工作，嵌套的顺序非常重要。</p>
<p>另外，这些组件都通常与 <a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">Vue Router</a> 中的 <code>&lt;RouterView&gt;</code> 组件结合使用。</p>
<p>下面的示例展示了如何嵌套这些组件，使它们都能按照预期的方式运行。若想组合得更简单，你也可以删除一些你不需要的组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Vue Router 使用动态导入对<a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noopener noreferrer">懒加载组件</a>进行了内置支持。这些与异步组件不同，目前他们不会触发 <code>&lt;Suspense&gt;</code>。但是，它们仍然可以有异步组件作为后代，这些组件可以照常触发 <code>&lt;Suspense&gt;</code>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>插槽</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/components/%E6%8F%92%E6%A7%BD.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/components/%E6%8F%92%E6%A7%BD.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">插槽</source>
      <description>https://cn.vuejs.org/guide/components/slots.html#slots 认识组件 Slot 在开发中，我们会经常封装一个个可复用的组件： 前面我们会通过props传递给组件一些数据，让组件来进行展示； 但是为了让这个组件具备更强的通用性，我们不能将组件中的内容限制为固定的div、span等等这些元素； 比如某种情况下我们使用组件，希望组件显示的是一个按钮，某种情况下我们使用组件希望显示的是一张图片； 我们应该让使用者可以决定某一块区域到底存放什么内容和元素； 举个栗子：假如我们定制一个通用的导航组件 - NavBar 这个组件分成三块区域：左边-中间-右边，每块区域的内容是不固定； 左边区域可能显示一个菜单图标，也可能显示一个返回按钮，可能什么都不显示； 中间区域可能显示一个搜索框，也可能是一个列表，也可能是一个标题，等等； 右边可能是一个文字，也可能是一个图标，也可能什么都不显示；</description>
      <pubDate>Tue, 05 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>https://cn.vuejs.org/guide/components/slots.html#slots</p>
</blockquote>
<h2> 认识组件  Slot</h2>
<ul>
<li>在开发中，我们会经常封装一个个可复用的组件：
<ul>
<li>前面我们会通过props传递给组件一些数据，让组件来进行展示；</li>
<li>但是为了让这个组件<strong>具备更强的通用性</strong>，我们<strong>不能将组件中的内容限制为固定的div、span等等这些元素</strong>；</li>
<li>比如某种情况下我们使用组件，希望组件显示的是一个按钮，某种情况下我们使用组件希望显示的是一张图片；</li>
<li>我们应该让使用者可以<strong>决定某一块区域到底存放什么内容和元素</strong>；</li>
</ul>
</li>
<li>举个栗子：假如我们定制一个通用的导航组件 - <code>NavBar</code>
<ul>
<li>这个组件分成三块区域：左边-中间-右边，每块区域的内容是不固定；</li>
<li>左边区域可能显示一个菜单图标，也可能显示一个返回按钮，可能什么都不显示；</li>
<li>中间区域可能显示一个搜索框，也可能是一个列表，也可能是一个标题，等等；</li>
<li>右边可能是一个文字，也可能是一个图标，也可能什么都不显示；</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312050058752.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>
<h2> 如何使用插槽slot？</h2>
<ul>
<li>这个时候我们就可以来定义插槽slot：
<ul>
<li>插槽的使用过程其实是抽取共性、预留不同；</li>
<li>我们会将共同的元素、内容依然在组件内进行封装；</li>
<li>同时会将不同的元素使用 slot 作为占位，让外部决定到底显示什么样的元素；</li>
</ul>
</li>
<li>如何使用slot呢？
<ul>
<li>Vue中将 元素作为承载分发内容的出口；</li>
<li>在封装组件中，使用特殊的元素就可以为封装组件开启一个插槽；</li>
<li>该插槽插入什么内容取决于父组件如何使用；</li>
</ul>
</li>
</ul>
<h2> 插槽的基本使用</h2>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>&lt;slot&gt;</code> 元素是一个<strong>插槽出口</strong> (slot outlet)，标示了父元素提供的<strong>插槽内容</strong> (slot content) 将在哪里被渲染。</p>
<figure><img src="https://qiniu.waite.wang/202312050109950.png" alt="image-20231205010910410" tabindex="0" loading="lazy"><figcaption>image-20231205010910410</figcaption></figure>
<p>通过使用插槽，<code>&lt;FancyButton&gt;</code> 仅负责渲染外层的 <code>&lt;button&gt;</code> (以及相应的样式)，而其内部的内容由父组件提供。</p>
<p>理解插槽的另一种方式是和下面的 JavaScript 函数作类比，其概念是类似的：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插槽内容可以是任意合法的模板内容，不局限于文本。例如我们可以传入多个元素，甚至是组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 插槽的默认内容</h3>
<p>在外部没有提供任何内容的情况下，可以为插槽指定默认内容。比如有这样一个 <code>&lt;SubmitButton&gt;</code> 组件：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们想在父组件没有提供任何插槽内容时在 <code>&lt;button&gt;</code> 内渲染“Submit”，只需要将“Submit”写在 <code>&lt;slot&gt;</code> 标签之间来作为默认内容：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，当我们在父组件中使用 <code>&lt;SubmitButton&gt;</code> 且没有提供任何插槽内容时：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>“Submit”将会被作为默认内容渲染：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但如果我们提供了插槽内容：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>那么被显式提供的内容会取代默认内容：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 多个插槽的效果</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312050117020.png" alt="image-20231205011717002" tabindex="0" loading="lazy"><figcaption>image-20231205011717002</figcaption></figure>
<h2> 具名插槽的使用</h2>
<p>有时在一个组件中包含多个插槽出口是很有用的。举例来说，在一个 <code>&lt;BaseLayout&gt;</code> 组件中，有如下模板：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于这种场景，<code>&lt;slot&gt;</code> 元素可以有一个特殊的 attribute <code>name</code>，用来给各个插槽分配唯一的 ID，以确定每一处要渲染的内容：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这类带 <code>name</code> 的插槽被称为具名插槽 (named slots)。没有提供 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会隐式地命名为“default”。</p>
<p>在父组件中使用 <code>&lt;BaseLayout&gt;</code> 时，我们需要一种方式将多个插槽内容传入到各自目标插槽的出口。此时就需要用到<strong>具名插槽</strong>了：</p>
<p>要为具名插槽传入内容，我们需要使用一个含 <code>v-slot</code> 指令的 <code>&lt;template&gt;</code> 元素，并将目标插槽的名字传给该指令：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>v-slot</code> 有对应的简写 <code>#</code>，因此 <code>&lt;template v-slot:header&gt;</code> 可以简写为 <code>&lt;template #header&gt;</code>。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。</p>
<figure><img src="https://qiniu.waite.wang/202312050120758.png" alt="image-20231205012048085" tabindex="0" loading="lazy"><figcaption>image-20231205012048085</figcaption></figure>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 JavaScript 函数来类比可能更有助于你来理解具名插槽：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 动态插槽名</h3>
<p>在Vue 3中，动态插槽名可以使用<code>v-slot</code>指令来实现。你可以将插槽名作为一个变量来传递给<code>v-slot</code>指令，以实现动态插槽名的效果。</p>
<p>例如，如果你有一个动态的插槽名变量<code>slotName</code>，你可以这样使用动态插槽名：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，<code>slotName</code>变量的值将作为插槽名来动态指定插槽的位置。</p>
<figure><img src="https://qiniu.waite.wang/202312050129225.png" alt="image-20231205012902405" tabindex="0" loading="lazy"><figcaption>image-20231205012902405</figcaption></figure>
<h2> 渲染作用域</h2>
<p>插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。举例来说：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的两个 <code>{{ message }}</code> 插值表达式渲染的内容都是一样的。</p>
<p>插槽内容<strong>无法访问</strong>子组件的数据。Vue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的词法作用域规则是一致的。换言之：</p>
<blockquote>
<p>父组件模板中的表达式只能访问父组件的作用域；子组件模板中的表达式只能访问子组件的作用域。</p>
</blockquote>
<h3> 作用域插槽</h3>
<p>然而在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。</p>
<p>我们也确实有办法这么做！可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当需要接收插槽 props 时，默认插槽和具名插槽的使用方式有一些小区别。下面我们将先展示默认插槽如何接受 props，通过子组件标签上的 <code>v-slot</code> 指令，直接接收到了一个插槽 props 对象：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312050134291.png" alt="image-20231205013406501" tabindex="0" loading="lazy"><figcaption>image-20231205013406501</figcaption></figure>
<p>子组件传入插槽的 props 作为了 <code>v-slot</code> 指令的值，可以在插槽内的表达式中访问。</p>
<p>你可以将作用域插槽类比为一个传入子组件的函数。子组件会将相应的 props 作为参数传给它：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上，这已经和作用域插槽的最终代码编译结果、以及手动编写<a href="https://cn.vuejs.org/guide/extras/render-function.html" target="_blank" rel="noopener noreferrer">渲染函数</a>时使用作用域插槽的方式非常类似了。</p>
<p><code>v-slot="slotProps"</code> 可以类比这里的函数签名，和函数的参数类似，我们也可以在 <code>v-slot</code> 中使用解构：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 具名作用域插槽</h3>
<p>具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 <code>v-slot</code> 指令的值被访问到：<code>v-slot:name="slotProps"</code>。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 独占默认插槽的缩写</h4>
<ul>
<li>如果我们的插槽是默认插槽<code>default</code>，那么在使用的时候 <code>v-slot:default="slotProps"</code>可以简写为<code>v-slot=“slotProps”</code></li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312050153014.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>
<ul>
<li>并且如果我们的插槽只有默认插槽时，组件的标签可以被当做插槽的模板来使用，这样，我们就可以将 <code>v-slot</code> 直接用在组件上</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312050153237.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>
<h3> 默认插槽和具名插槽混合</h3>
<ul>
<li>但是，如果我们有默认插槽和具名插槽，那么按照完整的template来编写。</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312050153775.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>
<ul>
<li>只要出现多个插槽，请始终为所有的插槽使用完整的基于</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312050154033.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202312050058752.png" type="image/png"/>
    </item>
    <item>
      <title>组件之间的通信</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/components/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/components/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">组件之间的通信</source>
      <description>[TOC] 认识组件的嵌套 在之前的案例中，我们只是创建了一个组件App； 如果我们一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护； 所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件； 再将这些组件组合嵌套在一起，最终形成我们的应用程序； 我们来分析一下下面代码的嵌套逻辑，假如我们将所有的代码逻辑都放到一个App.vue组件中： &amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;Header&amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt;NavBar&amp;lt;/h2&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;Banner&amp;lt;/h2&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;商品列表1&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;商品列表2&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;商品列表3&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;商品列表4&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;商品列表5&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;Footer&amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt;免责声明&amp;lt;/h2&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { }; &amp;lt;/script&amp;gt; &amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;</description>
      <pubDate>Mon, 27 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>[TOC]</p>
<h2> 认识组件的嵌套</h2>
<ul>
<li>在之前的案例中，我们只是创建了一个组件App；</li>
<li>如果我们一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护；</li>
<li>所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件；</li>
<li>再将这些组件组合嵌套在一起，最终形成我们的应用程序；</li>
</ul>
<blockquote>
<p>我们来分析一下下面代码的嵌套逻辑，假如我们将所有的代码逻辑都放到一个App.vue组件中：</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们会发现，将所有的代码逻辑全部放到一个组件中，代码是非常的臃肿和难以维护的。并且在真实开发中，我们会有更多的内容和代码逻辑，对于扩展性和可维护性来说都是非常差的。</p>
<p>所有，在真实的开发中，我们会对组件进行拆分，拆分成一个个功能的小组件。</p>
<h3> 组件的拆分</h3>
<p>如上代码, 我们可以按照如下的方式进行拆分：</p>
<ul>
<li>
<p>App.vue</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Header.vue组件</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Main.vue组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Banner.vue组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>ProductList组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Footer.vue组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>按照如上的拆分方式后，我们开发对应的逻辑只需要去对应的组件编写就可。</p>
</li>
</ul>
<h2> 组件的通信</h2>
<p>上面的嵌套逻辑如下，它们存在如下关系：</p>
<ul>
<li>App组件是Header、Main、Footer组件的父组件；</li>
<li>Main组件是Banner、ProductList组件的父组件；</li>
</ul>
<p>在开发过程中，我们会经常遇到需要组件之间相互进行通信：</p>
<ul>
<li>比如App可能使用了多个Header，每个地方的Header展示的内容不同，那么我们就需要使用者传递给Header一些数据，让其进行展示；</li>
<li>又比如我们在Main中一次性请求了Banner数据和ProductList数据，那么就需要传递给他们来进行展示；</li>
<li>也可能是子组件中发生了事件，需要有父组件来完成某些操作，那就需要子组件向父组件传递事件；</li>
</ul>
<blockquote>
<p>父子组件之间如何进行通信呢？</p>
<ul>
<li>父组件传递给子组件：通过props属性；</li>
<li>子组件传递给父组件：通过$emit触发事件；</li>
</ul>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202311240000049.png" alt="image-20231124000011715" tabindex="0" loading="lazy"><figcaption>image-20231124000011715</figcaption></figure>
<h3> 父传子</h3>
<p>在开发中很常见的就是父子组件之间通信，比如父组件有一些数据，需要子组件来进行展示：</p>
<ul>
<li>这个时候我们可以通过props来完成组件之间的通信；</li>
</ul>
<blockquote>
<p>什么是 props?</p>
<p>在Vue3中，props是一种用于向组件传递数据的机制。它允许父组件向子组件传递数据，并在子组件中使用这些数据。</p>
<p>在Vue3中，每个组件都可以定义自己的props，并指定每个prop的类型、默认值和其他验证规则。当父组件向子组件传递数据时，子组件可以使用这些props来访问传递过来的数据。</p>
</blockquote>
<h4> props 的定义</h4>
<p>在Vue3中，props可以使用两种方式来定义：</p>
<ol>
<li>字符串数组，数组中的字符串就是attribute的名称；</li>
<li>对象类型，对象类型我们可以在指定attribute名称的同时，指定它需要传递的类型、是否是必须的、默认值等等；</li>
</ol>
<h5> 字符串数组</h5>
<p>使用字符串数组的方式，可以简单地指定需要接收的属性名称。在这种情况下，属性类型默认为<code>any</code>。</p>
<p>在下面的示例中，父组件使用<code>message="Hello from parent"将message</code>属性作为字符串传递给子组件。在子组件中，使用<code>props</code>选项并传递一个字符串数组来定义<code>message</code>属性。这样子组件就可以使用<code>message</code>属性来访问父组件传递过来的数据了。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 对象类型</h5>
<p>使用对象类型的方式，可以更详细地指定需要接收的属性名称、类型、是否必须、默认值等等。</p>
<p>在下面的示例中，父组件使用<code>:message="parentMessage"将parentMessage</code>属性作为字符串传递给子组件。在子组件中，使用<code>props</code>选项并传递一个对象来定义<code>message</code>属性。在这个对象中，我们指定了<code>type</code>为字符串、<code>required</code>为true、<code>default</code>为'Hello from child'、以及一个自定义的验证函数。</p>
<p>这样子组件就可以使用<code>message</code>属性来访问父组件传递过来的数据了。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 其他</h5>
<ol>
<li><strong>Type的类型都可以是哪些？</strong>
<ul>
<li>String：用于指定字符串类型的属性。</li>
<li>Number：用于指定数字类型的属性。</li>
<li>Boolean：用于指定布尔类型的属性。</li>
<li>Array：用于指定数组类型的属性。</li>
<li>Object：用于指定对象类型的属性。</li>
<li>Date：用于指定日期类型的属性。</li>
<li>Function：用于指定函数类型的属性。</li>
<li>Symbol：用于指定符号类型的属性。</li>
</ul>
</li>
<li><strong>对象类型的其他写法</strong></li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li><strong>Prop 的大小写命名(camelCase vs kebab-case)</strong></li>
</ol>
<p>在Vue.js中，你可以使用驼峰式(camelCase)或短横线分隔(kebab-case)来命名你的props。然而，由于HTML属性不区分大小写，所以在模板中使用驼峰式命名的props时，需要转换为短横线分隔的形式。</p>
<p>例如，如果你在JavaScript中定义了一个名为<code>myProp</code>的prop，你需要在模板中使用<code>my-prop</code>来引用它。</p>
<p>这是一个例子：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，父组件将其数据<code>parentValue</code>传递给子组件的<code>myProp</code> prop。注意在父组件模板中，我们使用短横线分隔的形式<code>:my-prop</code>，而在子组件的JavaScript代码中，我们使用驼峰式命名<code>myProp</code>, 这也是官方推荐的写法。</p>
<h4> 非 Prop 的Attribute</h4>
<p>在Vue.js中，非prop的attribute是指那些被绑定到组件，但没有对应的prop定义的attribute。这些attribute会被添加到组件的根元素上。</p>
<p>例如，如果你有一个组件，它的模板是一个<code>&lt;div&gt;</code>元素，然后你在使用这个组件时添加了一个<code>class</code>或<code>style</code>属性，那么这个<code>class</code>或<code>style</code>属性就会被添加到<code>&lt;div&gt;</code>元素上，即使你没有在组件的props中定义它们。</p>
<p>这是一个例子：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>id</code>, <code>class</code>和<code>style</code>就是非prop的attribute。它们会被添加到<code>MyComponent</code>的根元素上。</p>
<h4> 禁用 Attribute 继承</h4>
<p>如果你不希望非prop的attribute被添加到根元素上，你可以在组件中定义一个<code>inheritAttrs: false</code>选项。这样，非prop的attribute将只能通过<code>$attrs</code>变量来访问，而不会被添加到根元素上。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>禁用attribute继承的常见情况是需要将attribute应用于根元素之外的其他元素；</li>
<li>我们可以通过 <code>$attrs</code>来访问所有的 <code>非props的attribute</code>；</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>如上, <code>&lt;h2&gt;</code> 仍然会继承非prop的attribute</li>
</ul>
<h4> 多个根节点的attribute</h4>
<blockquote>
<p>多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须手动的指定要绑定到哪一个属性上：</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 子传父</h3>
<p>什么情况下子组件需要传递内容到父组件呢？</p>
<ul>
<li>当子组件有一些事件发生的时候，比如在组件中发生了点击，父组件需要切换内容；</li>
<li>子组件有一些内容想要传递给父组件的时候；</li>
</ul>
<p>我们如何完成上面的操作呢？</p>
<ul>
<li>首先，我们需要在子组件中定义好在某些情况下触发的事件名称；</li>
<li>其次，在父组件中以v-on的方式传入要监听的事件名称，并且绑定到对应的方法中；</li>
<li>最后，在子组件中发生某个事件的时候，根据事件名称触发对应的事件；</li>
</ul>
<blockquote>
<p>以下是一个简单的示例</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>emits</code></h4>
<blockquote>
<p>当使用Vue 3时，你可以使用emits选项来对子组件触发的自定义事件进行校验: 使用<code>emits</code>选项可以提供类型检查和错误提示，确保子组件只触发被允许的自定义事件。这有助于提高代码的可维护性和可靠性。以下是一个示例：</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 非父子组件之间的通信</h2>
<p>在开发中，我们构建了组件树之后，除了父子组件之间的通信之外，还会有非父子组件之间的通信。</p>
<p>这里我们主要讲两种方式：</p>
<ul>
<li>Provide/Inject</li>
<li>Mitt全局事件总线；</li>
</ul>
<h3> Provide/Inject</h3>
<p>Provide/Inject用于非父子组件之间共享数据：</p>
<ul>
<li>比如有一些深度嵌套的组件，子组件想要获取父组件的部分内容；</li>
<li>在这种情况下，如果我们仍然将props沿着组件链逐级传递下去，就会非常的麻烦；</li>
</ul>
<p>对于这种情况下，我们可以使用 <code>Provide</code> 和 <code>Inject</code> ：</p>
<ul>
<li>无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者；</li>
<li>父组件有一个 <code>provide</code> 选项来提供数据；</li>
<li>子组件有一个 <code>inject</code> 选项来开始使用这些数据；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311301958291.png" alt="image-20231130195805276" tabindex="0" loading="lazy"><figcaption>image-20231130195805276</figcaption></figure>
<p>实际上，你可以将依赖注入看作是“long range props”，除了：</p>
<ul>
<li>父组件不需要知道哪些子组件使用它 <code>provide </code>的 <code>property</code></li>
<li>子组件不需要知道 <code>inject </code>的 <code>property </code>来自哪里</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>当然, 我们也可以通过 this 获取到当前组件定义的 data</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 全局事件总线 mitt 库</h3>
<p>在 Vue 3 中，全局事件总线是一种用于在不同组件之间进行通信的机制。它允许你在任何组件中触发事件并在其他组件中监听和响应这些事件。</p>
<blockquote>
<p>https://cn.vuejs.org/api/application.html#app-config-globalproperties</p>
</blockquote>
<p>在 Vue 3 中，可以使用 <code>app.config.globalProperties</code> 来创建一个全局事件总线。通过将事件总线实例添加到全局属性中，你可以在任何组件中访问它，从而实现跨组件的事件通信。</p>
<p>以下是一个示例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建一个名为 <code>createEventBus</code> 的函数来创建事件总线实例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，你可以在任何组件中使用 <code>$bus</code>来触发事件和监听事件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，当点击按钮时，组件 A 使用<code> $bus.emit</code> 发送了一个名为 <code>'message'</code> 的事件，并传递了消息 <code>'Hello from component A'</code>。组件 B 使用 ​<code>$bus.on</code> 监听了 <code>'message' </code>事件，并将接收到的消息显示在页面上。</p>
<p>通过全局事件总线，你可以在不同组件之间进行简单而方便的通信，而无需显式地通过 props 或其他方式传递数据。
[TOC]</p>
<h2> 认识组件的嵌套</h2>
<ul>
<li>在之前的案例中，我们只是创建了一个组件App；</li>
<li>如果我们一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护；</li>
<li>所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件；</li>
<li>再将这些组件组合嵌套在一起，最终形成我们的应用程序；</li>
</ul>
<blockquote>
<p>我们来分析一下下面代码的嵌套逻辑，假如我们将所有的代码逻辑都放到一个App.vue组件中：</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们会发现，将所有的代码逻辑全部放到一个组件中，代码是非常的臃肿和难以维护的。并且在真实开发中，我们会有更多的内容和代码逻辑，对于扩展性和可维护性来说都是非常差的。</p>
<p>所有，在真实的开发中，我们会对组件进行拆分，拆分成一个个功能的小组件。</p>
<h3> 组件的拆分</h3>
<p>如上代码, 我们可以按照如下的方式进行拆分：</p>
<ul>
<li>
<p>App.vue</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Header.vue组件</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Main.vue组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Banner.vue组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>ProductList组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Footer.vue组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>按照如上的拆分方式后，我们开发对应的逻辑只需要去对应的组件编写就可。</p>
</li>
</ul>
<h2> 组件的通信</h2>
<p>上面的嵌套逻辑如下，它们存在如下关系：</p>
<ul>
<li>App组件是Header、Main、Footer组件的父组件；</li>
<li>Main组件是Banner、ProductList组件的父组件；</li>
</ul>
<p>在开发过程中，我们会经常遇到需要组件之间相互进行通信：</p>
<ul>
<li>比如App可能使用了多个Header，每个地方的Header展示的内容不同，那么我们就需要使用者传递给Header一些数据，让其进行展示；</li>
<li>又比如我们在Main中一次性请求了Banner数据和ProductList数据，那么就需要传递给他们来进行展示；</li>
<li>也可能是子组件中发生了事件，需要有父组件来完成某些操作，那就需要子组件向父组件传递事件；</li>
</ul>
<blockquote>
<p>父子组件之间如何进行通信呢？</p>
<ul>
<li>父组件传递给子组件：通过props属性；</li>
<li>子组件传递给父组件：通过$emit触发事件；</li>
</ul>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202311240000049.png" alt="image-20231124000011715" tabindex="0" loading="lazy"><figcaption>image-20231124000011715</figcaption></figure>
<h3> 父传子</h3>
<p>在开发中很常见的就是父子组件之间通信，比如父组件有一些数据，需要子组件来进行展示：</p>
<ul>
<li>这个时候我们可以通过props来完成组件之间的通信；</li>
</ul>
<blockquote>
<p>什么是 props?</p>
<p>在Vue3中，props是一种用于向组件传递数据的机制。它允许父组件向子组件传递数据，并在子组件中使用这些数据。</p>
<p>在Vue3中，每个组件都可以定义自己的props，并指定每个prop的类型、默认值和其他验证规则。当父组件向子组件传递数据时，子组件可以使用这些props来访问传递过来的数据。</p>
</blockquote>
<h4> props 的定义</h4>
<p>在Vue3中，props可以使用两种方式来定义：</p>
<ol>
<li>字符串数组，数组中的字符串就是attribute的名称；</li>
<li>对象类型，对象类型我们可以在指定attribute名称的同时，指定它需要传递的类型、是否是必须的、默认值等等；</li>
</ol>
<h5> 字符串数组</h5>
<p>使用字符串数组的方式，可以简单地指定需要接收的属性名称。在这种情况下，属性类型默认为<code>any</code>。</p>
<p>在下面的示例中，父组件使用<code>message="Hello from parent"将message</code>属性作为字符串传递给子组件。在子组件中，使用<code>props</code>选项并传递一个字符串数组来定义<code>message</code>属性。这样子组件就可以使用<code>message</code>属性来访问父组件传递过来的数据了。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 对象类型</h5>
<p>使用对象类型的方式，可以更详细地指定需要接收的属性名称、类型、是否必须、默认值等等。</p>
<p>在下面的示例中，父组件使用<code>:message="parentMessage"将parentMessage</code>属性作为字符串传递给子组件。在子组件中，使用<code>props</code>选项并传递一个对象来定义<code>message</code>属性。在这个对象中，我们指定了<code>type</code>为字符串、<code>required</code>为true、<code>default</code>为'Hello from child'、以及一个自定义的验证函数。</p>
<p>这样子组件就可以使用<code>message</code>属性来访问父组件传递过来的数据了。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 其他</h5>
<ol>
<li><strong>Type的类型都可以是哪些？</strong>
<ul>
<li>String：用于指定字符串类型的属性。</li>
<li>Number：用于指定数字类型的属性。</li>
<li>Boolean：用于指定布尔类型的属性。</li>
<li>Array：用于指定数组类型的属性。</li>
<li>Object：用于指定对象类型的属性。</li>
<li>Date：用于指定日期类型的属性。</li>
<li>Function：用于指定函数类型的属性。</li>
<li>Symbol：用于指定符号类型的属性。</li>
</ul>
</li>
<li><strong>对象类型的其他写法</strong></li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li><strong>Prop 的大小写命名(camelCase vs kebab-case)</strong></li>
</ol>
<p>在Vue.js中，你可以使用驼峰式(camelCase)或短横线分隔(kebab-case)来命名你的props。然而，由于HTML属性不区分大小写，所以在模板中使用驼峰式命名的props时，需要转换为短横线分隔的形式。</p>
<p>例如，如果你在JavaScript中定义了一个名为<code>myProp</code>的prop，你需要在模板中使用<code>my-prop</code>来引用它。</p>
<p>这是一个例子：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，父组件将其数据<code>parentValue</code>传递给子组件的<code>myProp</code> prop。注意在父组件模板中，我们使用短横线分隔的形式<code>:my-prop</code>，而在子组件的JavaScript代码中，我们使用驼峰式命名<code>myProp</code>, 这也是官方推荐的写法。</p>
<h4> 非 Prop 的Attribute</h4>
<p>在Vue.js中，非prop的attribute是指那些被绑定到组件，但没有对应的prop定义的attribute。这些attribute会被添加到组件的根元素上。</p>
<p>例如，如果你有一个组件，它的模板是一个<code>&lt;div&gt;</code>元素，然后你在使用这个组件时添加了一个<code>class</code>或<code>style</code>属性，那么这个<code>class</code>或<code>style</code>属性就会被添加到<code>&lt;div&gt;</code>元素上，即使你没有在组件的props中定义它们。</p>
<p>这是一个例子：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>id</code>, <code>class</code>和<code>style</code>就是非prop的attribute。它们会被添加到<code>MyComponent</code>的根元素上。</p>
<h4> 禁用 Attribute 继承</h4>
<p>如果你不希望非prop的attribute被添加到根元素上，你可以在组件中定义一个<code>inheritAttrs: false</code>选项。这样，非prop的attribute将只能通过<code>$attrs</code>变量来访问，而不会被添加到根元素上。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>禁用attribute继承的常见情况是需要将attribute应用于根元素之外的其他元素；</li>
<li>我们可以通过 <code>$attrs</code>来访问所有的 <code>非props的attribute</code>；</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>如上, <code>&lt;h2&gt;</code> 仍然会继承非prop的attribute</li>
</ul>
<h4> 多个根节点的attribute</h4>
<blockquote>
<p>多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须手动的指定要绑定到哪一个属性上：</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 子传父</h3>
<p>什么情况下子组件需要传递内容到父组件呢？</p>
<ul>
<li>当子组件有一些事件发生的时候，比如在组件中发生了点击，父组件需要切换内容；</li>
<li>子组件有一些内容想要传递给父组件的时候；</li>
</ul>
<p>我们如何完成上面的操作呢？</p>
<ul>
<li>首先，我们需要在子组件中定义好在某些情况下触发的事件名称；</li>
<li>其次，在父组件中以v-on的方式传入要监听的事件名称，并且绑定到对应的方法中；</li>
<li>最后，在子组件中发生某个事件的时候，根据事件名称触发对应的事件；</li>
</ul>
<blockquote>
<p>以下是一个简单的示例</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>emits</code></h4>
<blockquote>
<p>当使用Vue 3时，你可以使用emits选项来对子组件触发的自定义事件进行校验: 使用<code>emits</code>选项可以提供类型检查和错误提示，确保子组件只触发被允许的自定义事件。这有助于提高代码的可维护性和可靠性。以下是一个示例：</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 动态组件</h2>
<p>Vue.js 的动态组件是指可以根据不同的数据渲染不同的组件的功能。你可以使用 Vue.js 的 <code>&lt;component&gt; </code>元素来实现动态组件。</p>
<p>例如，你可以在父组件中定义一个数据属性，根据这个属性的值来决定渲染哪个子组件。然后，在模板中使用 <code>&lt;component&gt; </code>元素，并将该数据属性绑定到 is 属性上，这样就可以动态地渲染不同的子组件了。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 非父子组件之间的通信</h2>
<p>在开发中，我们构建了组件树之后，除了父子组件之间的通信之外，还会有非父子组件之间的通信。</p>
<p>这里我们主要讲两种方式：</p>
<ul>
<li>Provide/Inject</li>
<li>Mitt全局事件总线；</li>
</ul>
<h3> Provide/Inject</h3>
<p>Provide/Inject用于非父子组件之间共享数据：</p>
<ul>
<li>比如有一些深度嵌套的组件，子组件想要获取父组件的部分内容；</li>
<li>在这种情况下，如果我们仍然将props沿着组件链逐级传递下去，就会非常的麻烦；</li>
</ul>
<p>对于这种情况下，我们可以使用 <code>Provide</code> 和 <code>Inject</code> ：</p>
<ul>
<li>无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者；</li>
<li>父组件有一个 <code>provide</code> 选项来提供数据；</li>
<li>子组件有一个 <code>inject</code> 选项来开始使用这些数据；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311301958291.png" alt="image-20231130195805276" tabindex="0" loading="lazy"><figcaption>image-20231130195805276</figcaption></figure>
<p>实际上，你可以将依赖注入看作是“long range props”，除了：</p>
<ul>
<li>父组件不需要知道哪些子组件使用它 <code>provide </code>的 <code>property</code></li>
<li>子组件不需要知道 <code>inject </code>的 <code>property </code>来自哪里</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>当然, 我们也可以通过 this 获取到当前组件定义的 data</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 全局事件总线 mitt 库</h3>
<p>在 Vue 3 中，全局事件总线是一种用于在不同组件之间进行通信的机制。它允许你在任何组件中触发事件并在其他组件中监听和响应这些事件。</p>
<blockquote>
<p>https://cn.vuejs.org/api/application.html#app-config-globalproperties</p>
</blockquote>
<p>在 Vue 3 中，可以使用 <code>app.config.globalProperties</code> 来创建一个全局事件总线。通过将事件总线实例添加到全局属性中，你可以在任何组件中访问它，从而实现跨组件的事件通信。</p>
<p>以下是一个示例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建一个名为 <code>createEventBus</code> 的函数来创建事件总线实例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，你可以在任何组件中使用 <code>$bus</code>来触发事件和监听事件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，当点击按钮时，组件 A 使用<code> $bus.emit</code> 发送了一个名为 <code>'message'</code> 的事件，并传递了消息 <code>'Hello from component A'</code>。组件 B 使用 ​<code>$bus.on</code> 监听了 <code>'message' </code>事件，并将接收到的消息显示在页面上。</p>
<p>通过全局事件总线，你可以在不同组件之间进行简单而方便的通信，而无需显式地通过 props 或其他方式传递数据。</p>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202311240000049.png" type="image/png"/>
    </item>
    <item>
      <title>Vite</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/cli/Vite.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/cli/Vite.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Vite</source>
      <description>https://cn.vitejs.dev/guide/ 什么是 Vite Vite（法语意为 &amp;quot;快速的&amp;quot;，发音 /vit/，发音同 &amp;quot;veet&amp;quot;）是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成： 一个开发服务器(dev server)，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）。 一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。 Vite 是一种具有明确建议的工具，具备合理的默认设置。您可以在 功能指南 中了解 Vite 的各种可能性。通过 插件，Vite 支持与其他框架或工具的集成。如有需要，您可以通过 配置部分 自定义适应你的项目。 Vite 还提供了强大的扩展性，可通过其 插件 API 和 JavaScript API 进行扩展，并提供完整的类型支持。 Vite作为一个基于浏览器原生ESM的构建工具，它省略了开发环境的打包过程，利用浏览器去解析imports，在服务端按需编译返回。同时，在开发环境拥有速度快到惊人的模块热更新，且热更新的速度不会随着模块增多而变慢。因此，使用Vite进行开发，至少会比Webpack快10倍左右。 你可以在 为什么选 Vite 部分深入了解该项目的设计理念。</description>
      <pubDate>Wed, 22 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>https://cn.vitejs.dev/guide/</p>
</blockquote>
<h2> 什么是 Vite</h2>
<ul>
<li>Vite（法语意为 "快速的"，发音 <code>/vit/</code>，发音同 "veet"）是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成：
<ul>
<li>一个开发服务器(dev server)，它基于 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="noopener noreferrer">原生 ES 模块</a> 提供了 <a href="https://cn.vitejs.dev/guide/features.html" target="_blank" rel="noopener noreferrer">丰富的内建功能</a>，如速度快到惊人的 <a href="https://cn.vitejs.dev/guide/features.html#hot-module-replacement" target="_blank" rel="noopener noreferrer">模块热更新（HMR）</a>。</li>
<li>一套构建指令，它使用 <a href="https://rollupjs.org/" target="_blank" rel="noopener noreferrer">Rollup</a> 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。</li>
</ul>
</li>
<li>Vite 是一种具有明确建议的工具，具备合理的默认设置。您可以在 <a href="https://cn.vitejs.dev/guide/features.html" target="_blank" rel="noopener noreferrer">功能指南</a> 中了解 Vite 的各种可能性。通过 <a href="https://cn.vitejs.dev/guide/using-plugins.html" target="_blank" rel="noopener noreferrer">插件</a>，Vite 支持与其他框架或工具的集成。如有需要，您可以通过 <a href="https://cn.vitejs.dev/config/" target="_blank" rel="noopener noreferrer">配置部分</a> 自定义适应你的项目。</li>
<li>Vite 还提供了强大的扩展性，可通过其 <a href="https://cn.vitejs.dev/guide/api-plugin.html" target="_blank" rel="noopener noreferrer">插件 API</a> 和 <a href="https://cn.vitejs.dev/guide/api-javascript.html" target="_blank" rel="noopener noreferrer">JavaScript API</a> 进行扩展，并提供完整的类型支持。</li>
<li>Vite作为一个基于浏览器原生ESM的构建工具，它省略了开发环境的打包过程，利用浏览器去解析imports，在服务端按需编译返回。同时，在开发环境拥有速度快到惊人的模块热更新，且热更新的速度不会随着模块增多而变慢。因此，使用Vite进行开发，至少会比Webpack快10倍左右。</li>
<li>你可以在 <a href="https://cn.vitejs.dev/guide/why.html" target="_blank" rel="noopener noreferrer">为什么选 Vite</a> 部分深入了解该项目的设计理念。</li>
</ul>
<h3> Vite的主要特性</h3>
<ul>
<li>Instant Server Start —— 即时服务启动</li>
<li>Lightning Fast HMR —— 闪电般快速的热更新</li>
<li>Rich Features —— 丰富的功能</li>
<li>Optimized Build —— 经过优化的构建</li>
<li>Universal Plugin Interface —— 通用的Plugin接口</li>
<li>Fully Typed APIs —— 类型齐全的API</li>
</ul>
<h3> 主流构建工具对比</h3>
<p><strong>Browserify</strong></p>
<p>预编译模块化方案（文件打包工具）</p>
<ul>
<li>Browserify基于流方式干净灵活</li>
<li>遵循commonJS规范打包JS</li>
<li>可引入插件打包CSS等其他资源（非原生能力）</li>
</ul>
<p><strong>Gulp</strong></p>
<ul>
<li>基于流的自动化构建工具（工程化）</li>
<li>配置复杂度高，偏向编程式，需要定义task处理构建</li>
<li>支持监听读写文件</li>
<li>可搭配Browserify等模块化工具来使用</li>
</ul>
<p><strong>Parcel</strong></p>
<ul>
<li>极速打包（工程化：极速0配置）</li>
<li>零配置，但造成了配置不灵活，内置常见场景的构建方案及其依赖，无需再次安装（babel等）</li>
<li>以html入口，自动检测和打包依赖</li>
<li>不支持SourceMap</li>
<li>无法Tree-shaking</li>
</ul>
<p><strong>Webpack</strong></p>
<ul>
<li>预编译模块化方案（工程化：大而全）</li>
<li>通过配置文件达到一站式配置</li>
<li>loader进行资源转换，功能全面（css+js+icon+front）</li>
<li>插件丰富，灵活扩展</li>
<li>社群庞大</li>
<li>大型项目构建慢</li>
</ul>
<p><strong>Rollup</strong></p>
<ul>
<li>基于ES6打包（模块打包工具）</li>
<li>Tree-shaking</li>
<li>打包文件小且干净，执行效率更高</li>
<li>更专注于JS打包</li>
</ul>
<p><strong>Snowpack</strong></p>
<ul>
<li>基于ESM运行时编译（工程化：ESM运行时）</li>
<li>无需递归循环依赖组装依赖树</li>
<li>默认输出单独的构建模块（未打包），可选择不同打包器（webpack、rollup等）</li>
</ul>
<p><strong>Vite</strong></p>
<ul>
<li>基于ESM运行时打包</li>
<li>借鉴了Snowpack</li>
<li>生产环境使用Rollup，集成度更高，相比Snowpack支持多页面、库模式、动态导入自动polyfill等</li>
</ul>
<h2> 为什么使用 Vite</h2>
<h3> <strong>开发环境⚡️速度的提升</strong></h3>
<ol>
<li>使用JS开发的工具通常需要很长的时间才能启动开发服务器，且这个启动时间与代码量、代码复杂度正相关。即使使用HMR，文件修改后的效果也要几秒钟才能在浏览器中反应出来，代表如Webpack。那么Vite是如何解决如Webpack这样的构建工具一样，在复杂、多模块项目开发中启动慢、HMR慢的问题呢？</li>
<li>我们详细对比了开发环境中的Vite和Webpack，发现主要有如下不同：</li>
</ol>
<table>
<thead>
<tr>
<th>Webpack</th>
<th>Vite</th>
</tr>
</thead>
<tbody>
<tr>
<td>先打包生成bundle，再启动开发服务器</td>
<td>先启动开发服务器，利用新一代浏览器的ESM能力，无需打包，直接请求所需模块并实时编译</td>
</tr>
<tr>
<td>HMR时需要把改动模块及相关依赖全部编译</td>
<td>HMR时只需让浏览器重新请求该模块，同时利用浏览器的缓存（源码模块协商缓存，依赖模块强缓存）来优化请求</td>
</tr>
<tr>
<td>内存高效利用</td>
<td>-</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>因此，针对开发环境中的启动慢问题，Vite开发环境冷启动无需打包，无需分析模块之间的依赖，同时也无需在启动开发服务器前进行编译，启动时还会使用 <strong>esbuild</strong> 来进行预构建。而Webpack 启动后会做一堆事情，经历一条很长的编译打包链条，从入口开始需要逐步经历语法解析、依赖收集、代码转译、打包合并、代码优化，最终将高版本的、离散的源码编译打包成低版本、高兼容性的产物代码;</li>
<li>针对HMR慢，即使只有很小的改动，Webpack依然需要构建完整的模块依赖图，并根据依赖图来进行转换。而Vite利用了ESM和浏览器缓存技术，更新速度与项目复杂度无关。可以看到，如Snowpack、Vite这类面相非打包的构建工具，在开发环境启动时只需要启动两个Server，一个用于页面加载，一个用于HMR的Websocket。当浏览器发出原生的ESM请求，Server收到请求只需要编译当前文件后返回给浏览器，不需要管理依赖。</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202311221718913.png" alt="image-20231122171817220" tabindex="0" loading="lazy"><figcaption>image-20231122171817220</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202311221718035.png" alt="image-20231122171839049" tabindex="0" loading="lazy"><figcaption>image-20231122171839049</figcaption></figure>
<h3> <strong>使用简单，开箱即用</strong></h3>
<p>相比Webpack需要对entry、loader、plugin等进行诸多配置，Vite的使用可谓是相当简单了。只需执行初始化命令，就可以得到一个预设好的开发环境，开箱即获得一堆功能，包括：CSS预处理、html预处理、异步加载、分包、压缩、HMR等。他使用复杂度介于Parcel和Webpack的中间，只是暴露了极少数的配置项和plugin接口，既不会像Parcel一样配置不灵活，又不会像Webpack一样需要了解庞大的loader、plugin生态，灵活适中、复杂度适中。适合前端新手。</p>
<h2> Vite 的安装与使用</h2>
<h3> 安装</h3>
<blockquote>
<p>Vite 需要 <a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer">Node.js</a> 版本 18+，20+。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。</p>
</blockquote>
<ul>
<li>
<p>首先，我们安装一下vite工具：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>通过vite来启动项目：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<h3> Vite构建Vue3项目</h3>
<p>使用 NPM:</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用 Yarn:</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为我们要构建Vue3的项目，所以这里我们选择Vue就行了，然后下一步选择开发语言</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>cd 进项目路径, <code>npm install</code>, 然后 <code>npm run dev</code> 运行即可</p>
<figure><img src="https://qiniu.waite.wang/7C797674-06CF-4E87-B344-63990EF519B6.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> Vite 支持</h2>
<h3> Css 支持</h3>
<ul>
<li>
<p>vite可以直接支持css的处理</p>
<ul>
<li>直接导入css即可；</li>
</ul>
</li>
<li>
<p>vite可以直接支持css预处理器，比如less</p>
<ul>
<li>直接导入less；</li>
<li>之后安装less编译器；</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>vite直接支持postcss的转换：</li>
<li>只需要安装postcss，并且配置 postcss.config.js 的配置文件即可；</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 全局导入</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 别名</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> Ts 支持</h3>
<ul>
<li>vite对TypeScript是原生支持的，它会直接使用ESBuild来完成编译：
<ul>
<li>只需要直接导入即可；</li>
</ul>
</li>
<li>如果我们查看浏览器中的请求，会发现请求的依然是ts的代码：
<ul>
<li>这是因为vite中的服务器Connect会对我们的请求进行转发；</li>
<li>获取ts编译后的代码，给浏览器返回，浏览器可以直接进行解析；</li>
</ul>
</li>
</ul>
<h3> vue支持</h3>
<ul>
<li>
<p>vite对vue提供第一优先级支持：</p>
<ul>
<li>Vue 3 单文件组件支持：@vitejs/plugin-vue</li>
<li>Vue 3 JSX 支持：@vitejs/plugin-vue-jsx</li>
<li>Vue 2 支持：underfin/vite-plugin-vue2</li>
</ul>
</li>
<li>
<p>安装支持vue的插件：</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>在vite.config.js中配置插件</p>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Vite 原理</h2>
<h3> ESM&amp;esbuild</h3>
<h4> ESM</h4>
<p>在ES6没有出现之前，随着js代码日益膨胀，往往会对资源模块化来提效，这也就出现了多个模块化方案。如CommonJS常用于服务端，AMD、CMD规范常用在客户端。ES6出现后，紧接着出现了ESM。ESM是浏览器支持的一种模块化方案，允许在浏览器实现模块化。</p>
<ul>
<li>CommonJS：模块同步，如Browserify会对代码进行解析，整理出代码中的所有模块依赖关系，然后把nodejs的模块编译成浏览器可用的模块，相关的模块代码都打包在一起，形成一个完整的JS文件，这个文件中不会存在 require 这类的模块化语法，变成可以在浏览器中运行的普通JS，运行时加载</li>
<li>AMD：模块异步，依赖前置，是requireJS在推广过程中对模块定义的规范化产出，加载完依赖后立即执行依赖模块，依赖加载成功后执行回调</li>
<li>CMD：模块异步，延迟执行，是seaJS在推广过程中对模块定义的规范化产出，就近依赖，先加载所有依赖模块，运行时才执行require内容，按顺序执行</li>
</ul>
<p>与CommonJS、AMD不同，ESM的对外接口只是一种静态定义，为编译时加载，遇到模块加载命令import，就会生成一个只读引用。等脚本真正执行时，再根据这个只读引用，到被加载的那个模块内取值。由于ESM编译时就能确定模块的依赖关系，因此能够只包含要运行的代码，可以显著减少文件体积，降低浏览器压力。</p>
<p>由于ESM是一个比较新的模块化方案，目前其浏览器能力支持如下：</p>
<figure><img src="https://qiniu.waite.wang/202311221721568.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<p>可以看到，除了IE、Opera等，新一代浏览器中绝大部分都已支持。</p>
<p>接下来以Vite创建的模板为例，看一下ESM的解析过程：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>当浏览器解析 import HelloWorld from './components/HelloWorld.vue' 时，会向当前域名发送一个请求获取对应的资源（ESM支持解析相对路径）</li>
<li>浏览器下载对应的文件，然后解析成模块记录。接下来会进行实例化，为模块分配内存，然后按照导入、导出语句建立模块和内存的映射关系。最后，运行上述代码，把内存空间填充为真实的值。</li>
</ul>
<h4> esbuild</h4>
<ul>
<li>ESBuild的特点：
<ul>
<li>超快的构建速度，并且不需要缓存；</li>
<li>支持ES6和CommonJS的模块化；</li>
<li>支持ES6的Tree Shaking；</li>
<li>支持Go、JavaScript的API；</li>
<li>支持TypeScript、JSX等语法编译；</li>
<li>支持SourceMap；</li>
<li>支持代码压缩；</li>
<li>支持扩展其他插件；</li>
</ul>
</li>
<li>ESBuild的构建速度和其他构建工具速度对比：</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311221724703.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>
<ul>
<li>ESBuild为什么这么快呢？
<ul>
<li>使用Go语言编写的，可以直接转换成机器代码，而无需经过字节码；</li>
<li>ESBuild可以充分利用CPU的多内核，尽可能让它们饱和运行；</li>
<li>ESBuild的所有内容都是从零开始编写的，而不是使用第三方，所以从一开始就可以考虑各种性能问题；</li>
</ul>
</li>
</ul>
<h3> <strong>依赖处理</strong></h3>
<p>Vite 通过在一开始将应用中的模块区分为 <strong>依赖</strong> 和 <strong>源码</strong> 两类，改进了开发服务器启动时间。<strong>依赖</strong> 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。</p>
<ul>
<li><strong>依赖解析</strong></li>
</ul>
<p>以 Vite 官方 demo 为例，当我们请求 <strong>localhost:3000</strong> 时，Vite 默认返回 <strong>localhost:3000/index.html</strong> 的代码。而后发送请求 <strong>src/main.js</strong>。</p>
<p>main.js 代码如下：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202311222321963.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<p>可以观察到浏览器请求 vue.js 时， 请求路径是 <strong>@modules/vue.js</strong>。在 Vite 中约定若 path 的请求路径满足 <strong>/^/@modules//</strong> 格式时，被认为是一个 node_modules 模块。</p>
<p>平时开发中，webpack &amp; rollup(rollup有对应插件) 等打包工具会帮我们找到模块的路径，但浏览器只能通过相对路径去寻找，而如果是直接使用模块名比如：<strong>import vue from 'vue'</strong>，浏览器就会报错，这个时候就需要一个三方包进行处理。Vite 对ESM形式的 js 文件模块使用了 ES Module Lexer 处理。Lexer 会找到代码中以 import 语法导入的模块并以数组形式返回。Vite 通过该数组的值获取判断是否为一个 node_modules 模块。若是则进行对应改写成 @modules/:id 的写法。</p>
<p>重写完路径后，浏览器会发送 path 为 /@modules/:id 的对应请求，接下来会被 Vite 客户端做一层拦截来解析模块的真实位置。</p>
<p>首先正则匹配请求路径，如果是/@modules开头就进行后续处理，否则就跳过。若是，会设置响应类型为js，读取真实模块路径内容，返回给客户端。</p>
<p>客户端注入本质上是创建一个script标签（type='module'），然后将其插入到head中，这样客户端在解析html是就可以执行代码了</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><strong>依赖预构建</strong></li>
</ul>
<p>依赖预构建主要有两个目的：</p>
<ul>
<li><strong>CommonJS 和 UMD 兼容性:</strong> 开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。</li>
<li><strong>性能：</strong> Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。</li>
</ul>
<p>Vite使用esbuild在初次启动开发服务器前把检测到的依赖进行预构建。Vite 基于ESM，在使用某些模块时，由于模块依赖了另一些模块，依赖的模块又基于另一些模块。会出现页面初始化时一次发送数百个模块请求的情况。</p>
<p>以 lodash-es 为例，代码中以 import { debounce } from 'lodash' 导入一个命名函数时候，并不是只下载包含这个函数的文件，而是有一个依赖图。</p>
<figure><img src="https://qiniu.waite.wang/202311222322996.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<p>Vite 为了优化请求数量和速度，利用esbuild在启动的时候预先把debounce用到的所有内部模块全部打包成一个bundle，这样就浏览器在请求debounce时，便只需要发送一次请求了</p>
<h4> <strong>静态资源加载</strong></h4>
<p>当请求的路径符合 imageRE, mediaRE, fontsRE 或 JSON 格式，会被认为是一个静态资源。静态资源将处理成ESM模块返回。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>vue文件缓存</strong></h4>
<p>当 Vite 遇到一个 .vue 后缀的文件时。由于 .vue 模板文件的特殊性，它被拆分成 template, css, script 模块三个模块进行分别处理。最后会对 script, template, css 发送多个请求获取</p>
<figure><img src="https://qiniu.waite.wang/202311222324430.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h4> <strong>js/ts处理</strong></h4>
<p>Vite使用esbuild将ts转译到js，约是tsc速度的20～30倍，同时HMR更新反应到浏览器的时间会小于50ms。但是，由于esbuild转换ts到js对于类型操作仅仅是擦除，所以完全保证不了类型正确，因此需要额外校验类型，比如使用tsc --noEmit。</p>
<p>将ts转换成js后，浏览器便可以利用ESM直接拿到js资源。</p>
<h3> 热更新原理</h3>
<p>Vite 的热加载原理，其实就是在客户端与服务端建立了一个 websocket 连接，当代码被修改时，服务端发送消息通知客户端去请求修改模块的代码，完成热更新。</p>
<ul>
<li>服务端：服务端做的就是监听代码文件的改变，在合适的时机向客户端发送 websocket 信息通知客户端去请求新的模块代码。</li>
<li>客户端：Vite 中客户端的 websocket 相关代码在处理 html 中时被写入代码中。可以看到在处理 html 时，vite/client 的相关代码已经被插入。</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当request.path 路径是 /vite/client 时，请求获取已经提前写好的关于 websocket 的代码。因此在客户端中我们创建了一个 websocket 服务并与服务端建立了连接。</p>
<p>Vite 会接受到来自客户端的消息。通过不同的消息触发一些事件。做到浏览器端的即时热模块更换（热更新）。包括 connect、vue-reload、vue-rerender 等事件，分别触发组件vue 的重新加载，render等。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202311221718913.png" type="image/png"/>
    </item>
    <item>
      <title>VueCLI</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/cli/vueCli.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/cli/vueCli.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">VueCLI</source>
      <description>https://cli.vuejs.org/zh/ 什么是Vue脚手架？ 我们前面学习了如何通过webpack配置Vue的开发环境，但是在真实开发中我们不可能每一个项目从头来完成 所有的webpack配置，这样显示开发的效率会大大的降低； 所以在真实开发中，我们通常会使用脚手架来创建一个项目，Vue的项目我们使用的就是Vue的脚手架； 脚手架其实是建筑工程中的一个概念，在我们软件工程中也会将一些帮助我们搭建项目的工具称之为脚手架； 我们可以通过CLI选择项目的配置和创建出我们的项目； Vue CLI已经内置了webpack相关的配置，我们不需要从零来配置；</description>
      <pubDate>Wed, 22 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>https://cli.vuejs.org/zh/</p>
</blockquote>
<p>什么是Vue脚手架？</p>
<ul>
<li>我们前面学习了如何通过webpack配置Vue的开发环境，但是在真实开发中我们不可能每一个项目从头来完成 所有的webpack配置，这样显示开发的效率会大大的降低；</li>
<li>所以在真实开发中，我们通常会使用脚手架来创建一个项目，Vue的项目我们使用的就是Vue的脚手架；</li>
<li>脚手架其实是建筑工程中的一个概念，在我们软件工程中也会将一些帮助我们搭建项目的工具称之为脚手架；</li>
<li>我们可以通过CLI选择项目的配置和创建出我们的项目；</li>
<li>Vue CLI已经内置了webpack相关的配置，我们不需要从零来配置；</li>
</ul>
<p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：</p>
<ul>
<li>通过 <code>@vue/cli</code> 实现的交互式的项目脚手架。</li>
<li>通过 <code>@vue/cli</code> + <code>@vue/cli-service-global</code> 实现的零配置原型开发。</li>
<li>一个运行时依赖 (<code>@vue/cli-service</code>)，该依赖：
<ul>
<li>可升级；</li>
<li>基于 webpack 构建，并带有合理的默认配置；</li>
<li>可以通过项目内的配置文件进行配置；</li>
<li>可以通过插件进行扩展。</li>
</ul>
</li>
<li>一个丰富的官方插件集合，集成了前端生态中最好的工具。</li>
<li>一套完全图形化的创建和管理 Vue.js 项目的用户界面。</li>
</ul>
<p>Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需 eject。</p>
<h2> Vue CLI 安装</h2>
<blockquote>
<p>Node 版本要求</p>
<p>Vue CLI 4.x 需要 <a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer">Node.js</a> v8.9 或更高版本 (推荐 v10 以上)。你可以使用 <a href="https://github.com/tj/n" target="_blank" rel="noopener noreferrer">n</a>，<a href="https://github.com/creationix/nvm" target="_blank" rel="noopener noreferrer">nvm</a> 或 <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener noreferrer">nvm-windows</a> 在同一台电脑中管理多个 Node 版本。</p>
</blockquote>
<ul>
<li>可以使用下列任一命令安装这个新的包：</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>安装之后，你就可以在命令行中访问 <code>vue</code> 命令。你可以通过简单运行 <code>vue</code>，看看是否展示出了一份所有可用命令的帮助信息，来验证它是否安装成功。你还可以用这个命令来检查其版本是否正确：</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>如需升级全局的 Vue CLI 包，请运行：</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>上面列出来的命令是用于升级全局的 Vue CLI。如需升级项目中的 Vue CLI 相关模块（以 <code>@vue/cli-plugin-</code> 或 <code>vue-cli-plugin-</code> 开头），请在项目目录下运行 <code>vue upgrade</code>：</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 创建一个项目</h2>
<p>运行以下命令来创建一个新项目：</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol>
<li>选择预设
<ul>
<li>Default ([Vue 3] babel, eslint): 选择 Vue3 版本, 并且默认选择 babel, eslint</li>
<li>Default ([Vue 2] babel, eslint): 选择 Vue2 版本, 并且默认选择 babel, eslint</li>
<li>Manually select features: 手动选择需要获取的特性</li>
</ul>
</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202311221033285.png" alt="image-20231122103332793" tabindex="0" loading="lazy"><figcaption>image-20231122103332793</figcaption></figure>
<ol start="2">
<li>我们选择 <code>Manually select features</code>
<ul>
<li>Babel: Babel是一个JavaScript编译器，用于将新版本的JavaScript代码转换为向后兼容的旧版本，以便在不同浏览器和环境中运行。</li>
<li>TypeScript: TypeScript是一种静态类型的JavaScript超集，它添加了类型注解和其他特性，以提供更强大的开发工具和更可靠的代码。</li>
<li>Progressive Web App (PWA) Support: PWA是一种使用现代Web技术构建的应用程序，可以在各种设备和平台上提供类似原生应用的体验。</li>
<li>Router: Vue Router是Vue.js官方提供的路由管理器，用于实现单页面应用程序（SPA）中的导航和路由功能。</li>
<li>Vuex: Vuex是Vue.js官方提供的状态管理库，用于在大型应用程序中管理和共享状态。</li>
<li>CSS Pre-processors: CSS预处理器（如Sass、Less）允许您在编写CSS时使用变量、嵌套规则、函数等高级功能，以提高样式表的可维护性和可重用性。</li>
<li>Linter / Formatter: 代码检查工具（如ESLint）用于强制执行一致的代码风格和检测潜在的错误。代码格式化工具（如Prettier）可自动格式化代码，使其符合统一的样式规范。</li>
<li>Unit Testing: 单元测试是一种软件测试方法，用于验证应用程序中各个部分的功能是否按预期工作。</li>
<li>E2E Testing: 端到端（End-to-End）测试是一种测试方法，用于模拟用户在应用程序中执行的实际操作，以验证整个应用程序的功能和流程。</li>
</ul>
</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202311221036769.png" alt="image-20231122103618450" tabindex="0" loading="lazy"><figcaption>image-20231122103618450</figcaption></figure>
<ol start="3">
<li>选择 Vue 版本</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202311221036975.png" alt="image-20231122103654515" tabindex="0" loading="lazy"><figcaption>image-20231122103654515</figcaption></figure>
<ol start="4">
<li>
<p>Pick a linter / formatter config: 选择的代码检查和格式化配置</p>
<ul>
<li>ESLint with error prevention only：仅使用ESLint进行错误检查，不应用其他格式化规则。</li>
<li>ESLint + Airbnb config：使用ESLint进行错误检查，并应用Airbnb JavaScript风格指南的格式化规则。</li>
<li>ESLint + Standard config：使用ESLint进行错误检查，并应用JavaScript Standard风格的格式化规则。</li>
<li>ESLint + Prettier：使用ESLint进行错误检查，并与Prettier代码格式化工具集成，以实现一致的代码样式</li>
</ul>
</li>
<li>
<p>Pick additional lint features: 可供选择的附加代码检查功能</p>
<ul>
<li>Lint on save：在保存文件时运行代码检查，以及在编辑器中进行实时错误检测和提示。</li>
<li>Lint and fix on commit：在提交代码时运行代码检查，并自动修复一些常见的问题，以确保提交的代码符合规范。</li>
</ul>
</li>
<li>
<p>Where do you prefer placing config for Babel, ESLint, etc.? 配置文件位置选择</p>
<ul>
<li>In dedicated config files：将Babel、ESLint等配置信息分别保存在它们各自的配置文件中（如.babelrc、.eslintrc等。</li>
<li>In package.json：将Babel、ESLint等配置信息保存在package.json文件的特定字段中，如babel、eslintConfig等。</li>
</ul>
</li>
<li>
<p>Save this as a preset for future projects? (y/N) 这是一个保存预设供以后使用的选项，如果您希望将当前配置保存为预设，以便在将来的项目中重用，可以选择“y”，否则选择“N”。</p>
</li>
</ol>
<blockquote>
<p>您还可以使用图形界面使用以下<code>vue ui</code>命令创建和管理项目：</p>
</blockquote>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://cli.vuejs.org/ui-new-project.png" alt="界面预览" tabindex="0" loading="lazy"><figcaption>界面预览</figcaption></figure>
<h2> 项目结构</h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>在一个 Vue CLI 项目中，<code>@vue/cli-service</code> 安装了一个名为 <code>vue-cli-service</code> 的命令。你可以在 npm scripts 中以 <code>vue-cli-service</code>、或者从终端中以 <code>./node_modules/.bin/vue-cli-service</code> 访问这个命令。</p>
</blockquote>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以通过 npm 或 Yarn 调用这些 script：</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你可以使用 <a href="https://github.com/npm/npx" target="_blank" rel="noopener noreferrer">npx</a> (最新版的 npm 应该已经自带)，也可以直接这样调用命令：</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> vue-cli-service serve</h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>vue-cli-service serve</code> 命令会启动一个开发服务器 (基于 <a href="https://github.com/webpack/webpack-dev-server" target="_blank" rel="noopener noreferrer">webpack-dev-server</a>) 并附带开箱即用的模块热重载 (Hot-Module-Replacement)。</p>
<p>除了通过命令行参数，你也可以使用 <code>vue.config.js</code> 里的 <a href="https://cli.vuejs.org/zh/config/#devserver" target="_blank" rel="noopener noreferrer">devServer</a> 字段配置开发服务器。</p>
<p>命令行参数 <code>[entry]</code> 将被指定为唯一入口 (默认值：<code>src/main.js</code>，TypeScript 项目则为 <code>src/main.ts</code>)，而非额外的追加入口。尝试使用 <code>[entry]</code> 覆盖 <code>config.pages</code> 中的 <code>entry</code> 将可能引发错误。</p>
<h2> <a href="https://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-build" target="_blank" rel="noopener noreferrer">vue-cli-service build</a></h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>vue-cli-service build</code> 会在 <code>dist/</code> 目录产生一个可用于生产环境的包，带有 JS/CSS/HTML 的压缩，和为更好的缓存而做的自动的 vendor chunk splitting。它的 chunk manifest 会内联在 HTML 里。</p>
<p>这里还有一些有用的命令参数：</p>
<ul>
<li><code>--modern</code> 使用<a href="https://cli.vuejs.org/zh/guide/browser-compatibility.html#%E7%8E%B0%E4%BB%A3%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener noreferrer">现代模式</a>构建应用，为现代浏览器交付原生支持的 ES2015 代码，并生成一个兼容老浏览器的包用来自动回退。</li>
<li><code>--target</code> 允许你将项目中的任何组件以一个库或 Web Components 组件的方式进行构建。更多细节请查阅<a href="https://cli.vuejs.org/zh/guide/build-targets.html" target="_blank" rel="noopener noreferrer">构建目标</a>。</li>
<li><code>--report</code> 和 <code>--report-json</code> 会根据构建统计生成报告，它会帮助你分析包中包含的模块们的大小。</li>
</ul>
<h2> vue-cli-service inspect</h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你想要设置 inspect 命令的选项，可以在命令后面添加对应的参数。例如，如果你想要查看生产环境的 webpack 配置，可以运行以下命令：<code>vue-cli-service inspect --mode production</code></p>
<p>你也可以通过在 vue.config.js 文件中配置 configureWebpack 选项来修改 webpack 配置。这个选项允许你返回一个对象或函数来修改默认的 webpack 配置。例如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>你可以使用 <code>vue-cli-service inspect</code> 来审查一个 Vue CLI 项目的 webpack config。更多细节请查阅<a href="https://cli.vuejs.org/zh/guide/webpack.html#%E5%AE%A1%E6%9F%A5%E9%A1%B9%E7%9B%AE%E7%9A%84-webpack-config" target="_blank" rel="noopener noreferrer">审查 webpack config</a>。</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202311221033285.png" type="image/png"/>
    </item>
    <item>
      <title>Webpack_devServer</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/cli/devServer.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/cli/devServer.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Webpack_devServer</source>
      <description>devServer 是指开发服务器，通常用于前端开发环境。在前端开发中，开发者通常需要一个本地服务器来运行他们的应用程序，以便进行测试和调试。Webpack是一个流行的前端构建工具，而devServer就是Webpack提供的一个功能，用于在开发过程中提供一个简单的服务器。 devServer 可以帮助开发者在本地启动一个服务器，监视文件的变化，并在文件发生更改时自动重新加载页面，以提高开发效率。此外，它还支持一些其他功能，比如模块热替换（Hot Module Replacement），允许在不刷新整个页面的情况下更新部分模块。 在使用Webpack配置文件时，你可以配置 devServer 的各种选项，以满足你的开发需求。这包括设置服务器的端口、指定静态资源的路径、配置代理等。</description>
      <pubDate>Sun, 19 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p><code>devServer</code> 是指开发服务器，通常用于前端开发环境。在前端开发中，开发者通常需要一个本地服务器来运行他们的应用程序，以便进行测试和调试。Webpack是一个流行的前端构建工具，而<code>devServer</code>就是Webpack提供的一个功能，用于在开发过程中提供一个简单的服务器。</p>
<p><code>devServer</code> 可以帮助开发者在本地启动一个服务器，监视文件的变化，并在文件发生更改时自动重新加载页面，以提高开发效率。此外，它还支持一些其他功能，比如模块热替换（Hot Module Replacement），允许在不刷新整个页面的情况下更新部分模块。</p>
<p>在使用Webpack配置文件时，你可以配置 <code>devServer</code> 的各种选项，以满足你的开发需求。这包括设置服务器的端口、指定静态资源的路径、配置代理等。</p>
</blockquote>
<ul>
<li>目前我们开发的代码，为了运行需要有两个操作：
<ul>
<li>操作一：npm run build，编译相关的代码；</li>
<li>操作二：通过live server或者直接通过浏览器，打开index.html代码，查看效果；</li>
</ul>
</li>
<li>这个过程经常操作会影响我们的开发效率，我们希望可以做到，当文件发生变化时，可以自动的完成编译和展示；</li>
<li>为了完成自动编译，webpack提供了几种可选的方式：
<ul>
<li><code>webpack watch mode</code>：在文件发生变化时，Webpack会自动重新编译代码。</li>
<li><code>webpack-dev-server</code>（常用）：提供了一个开发服务器，可以在本地运行你的应用程序，并且在文件发生变化时自动重新加载页面。</li>
<li><code>webpack-dev-middleware</code>：结合其他服务器框架使用，将Webpack与服务器集成，实现在文件发生变化时自动重新编译</li>
</ul>
</li>
</ul>
<h2> Webpack watch</h2>
<ul>
<li>
<p>webpack给我们提供了watch模式：</p>
<ul>
<li>在该模式下，webpack依赖图中的所有文件，只要有一个发生了更新，那么代码将被重新编译；</li>
<li>我们不需要手动去运行 npm run build指令了；</li>
</ul>
</li>
<li>
<p>开启watch模式有两种方式：</p>
<ul>
<li>通过在命令行中使用--watch参数来开启watch模式。例如，运行<code>webpack --watch</code>命令即可开启watch模式。</li>
</ul>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>在Webpack配置文件中添加``watch: true`选项来开启watch模式。例如，在Webpack配置文件中添加以下代码：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> webpack-dev-server</h2>
<ul>
<li>上面的方式可以监听到文件的变化，但是事实上它本身是没有自动刷新浏览器的功能的：
<ul>
<li>当然，目前我们可以在 VSCode 中使用 live-server 来完成这样的功能；</li>
<li>但是，我们希望在不适用live-server的情况下，可以具备live reloading（实时重新加载）的功能；</li>
</ul>
</li>
<li>安装webpack-dev-server</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>修改配置文件</li>
</ul>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>运行 <code>npm run serve</code>, 在本地配置一个服务器, 使用 <code>webpack cli</code> 解析/ 启动本地服务</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311191904772.png" alt="image-20231119190420271" tabindex="0" loading="lazy"><figcaption>image-20231119190420271</figcaption></figure>
</li>
</ul>
<blockquote>
<p>在运行 <code>npm run serve</code> 命令时，如果没有指定输出目录，webpack会默认将打包后的文件输出到内存中，而不是硬盘上的某个目录中。因此即使没有指定输出目录，该命令仍然可以正常运行。这种方式称为内存编译，可以提高开发效率，因为不需要每次修改代码后都重新编译和写入磁盘。 使用 <code>memfs</code> 这一个库实现;</p>
</blockquote>
<h2> 认识模块热替换（HMR）</h2>
<ul>
<li>什么是HMR呢？
<ul>
<li>HMR的全称是Hot Module Replacement，翻译为模块热替换；</li>
<li>模块热替换是指在 应用程序运行过程中，<strong>替换、添加、删除模块，而无需重新刷新整个页面</strong>；</li>
</ul>
</li>
<li>HMR通过如下几种方式，来提高开发的速度：
<ul>
<li>不重新加载整个页面，这样可以保留某些应用程序的状态不丢失；</li>
<li>只更新需要变化的内容，节省开发的时间；</li>
<li>修改了css、js源代码，会立即在浏览器更新，相当于直接在浏览器的 devtools 中直接修改样式；</li>
</ul>
</li>
<li>如何使用HMR呢？
<ul>
<li>默认情况下，webpack-dev-server已经支持HMR，我们只需要开启即可；</li>
<li>在不开启HMR的情况下，当我们修改了源代码之后，整个页面会自动刷新，使用的是live reloading；</li>
</ul>
</li>
</ul>
<h3> 开启 HMR</h3>
<ul>
<li>修改webpack的配置：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202311192014822.png" alt="image-20231119201428778" tabindex="0" loading="lazy"><figcaption>image-20231119201428778</figcaption></figure>
<ul>
<li>指定哪些模块发生更新时，进行HMR；</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 框架 的 HMR</h3>
<ul>
<li>
<p>大多数主流框架（如React、Vue和Angular）都对模块热替换（HMR）提供了内置的支持，以便在开发过程中实现更快的热更新。</p>
</li>
<li>
<p>具体而言，这些框架通常会提供开发服务器或开发工具，用于在开发过程中启用HMR功能。通过使用这些工具，你可以在修改代码时实时查看更新后的效果，而无需手动刷新页面。</p>
</li>
<li>
<p>以下是一些常见的框架的HMR支持方式：</p>
<ul>
<li>React：React 框架通常使用Webpack的 <code>react-hot-loader</code> 插件来实现HMR功能。你可以在Webpack配置文件中配置该插件，然后在开发服务器中启用HMR。</li>
<li>Vue：Vue 框架内置了对HMR的支持。你可以使用 <code>vue-loader</code> 和 <code>vue-style-loader</code> 等相关插件，以及在Webpack配置文件中配置HMR选项，来启用Vue的HMR功能。</li>
<li>Angular：Angular 框架使用Webpack的 <code>@angular-builders/custom-webpack</code> 插件来实现HMR功能。你可以在Angular项目的配置文件中进行相应的配置，以启用HMR。</li>
</ul>
</li>
<li>
<p>请注意，每个框架的具体配置方式可能会有所不同。建议查阅相应框架的官方文档或社区资源，以获取更详细的关于HMR的配置和使用说明。</p>
</li>
</ul>
<h3> HMR的原理</h3>
<p>HMR（Hot Module Replacement）的原理是通过在应用程序运行时，通过开发服务器向客户端发送更新的模块代码，然后使用热更新运行时（Hot Update Runtime）来替换旧的模块代码，从而实现模块的热替换，而无需重新加载整个页面。</p>
<ul>
<li>webpack-dev-server会创建两个服务：提供静态资源的服务（express）和Socket服务（net.Socket）；
<ul>
<li>HMR Socket Server，是一个socket的长连接：
<ul>
<li>长连接有一个最好的好处是建立连接后双方可以通信（服务器可以直接发送文件到客户端）；</li>
<li>当服务器监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）；</li>
<li>通过长连接，可以直接将这两个文件主动发送给客户端（浏览器）；</li>
<li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新；</li>
</ul>
</li>
<li>Webpack-dev-server使用Node.js内置的net模块提供WebSocket服务。该服务与静态资源服务配合使用，用于与客户端进行实时通信。当客户端连接到WebSocket服务时，Webpack-dev-server会将更新的模块代码发送到客户端，并触发模块热替换（HMR）功能。客户端接收到更新后，会通过WebSocket与Webpack-dev-server建立连接，并将更新的模块代码应用到正在运行的应用程序中。</li>
</ul>
</li>
<li>express server负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）；
<ul>
<li>Webpack-dev-server使用express框架提供静态资源服务。该服务可以将Webpack打包后的静态资源文件（如HTML、CSS、JavaScript等）提供给浏览器访问。同时，该服务还支持一些特殊的路由，如/__webpack_hmr，用于与客户端建立WebSocket通信。</li>
</ul>
</li>
</ul>
<p>具体而言，HMR的原理可以分为以下几个步骤：</p>
<ol>
<li>构建过程中的注入：在Webpack构建过程中，会将特殊的HMR运行时代码注入到应用程序中的每个模块中。这些HMR运行时代码负责与开发服务器建立连接，并接收来自服务器的更新通知。</li>
<li>开发服务器的更新通知：开发服务器会监视文件的变化，并在文件发生更改时，向连接的客户端发送更新通知。这些更新通知包含了被修改的模块的更新代码。</li>
<li>客户端接收更新：当客户端接收到更新通知时，它会根据更新代码进行处理。这些更新代码会被热更新运行时处理，并将其应用于相应的模块。</li>
<li>模块的热替换：热更新运行时会将新的模块代码与旧的模块代码进行比较，并尽可能地将新代码应用于正在运行的应用程序。如果新代码可以被成功替换，应用程序会保持运行状态，同时显示更新后的效果。</li>
</ol>
<p>总结起来，HMR利用了Webpack的构建能力和热更新运行时，使得在开发过程中可以实时地修改代码并查看更新后的效果，从而提高开发效率。</p>
<figure><img src="https://qiniu.waite.wang/202311192033908.png" alt="image-20231119203330239" tabindex="0" loading="lazy"><figcaption>image-20231119203330239</figcaption></figure>
<h2> devServer 配置信息</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> hotOnly、host 配置</h3>
<ul>
<li>
<p>host设置主机地址：</p>
<ul>
<li>默认值是localhost；</li>
<li>如果希望其他地方也可以访问，可以设置为 0.0.0.0；</li>
</ul>
</li>
<li>
<p>localhost 和 0.0.0.0 的区别：</p>
<ul>
<li><code>localhost</code>：<code>localhost</code>是一个主机名，表示本地计算机或设备自身。它通常映射到回环地址（loopback address）``127.0.0.1<code>，也可以是IPv6的</code>::1<code>。当应用程序绑定到</code>localhost`时，它只能通过本地计算机或设备上的回环接口进行访问。这意味着只有本地计算机或设备上的进程可以访问该应用程序，其他计算机或设备无法直接访问。</li>
<li><code>0.0.0.0</code>：<code>0.0.0.0</code>是一个特殊的IP地址，表示任意主机或所有主机。当应用程序绑定到<code>0.0.0.0</code>时，它将监听所有可用的网络接口，包括本地计算机上的回环接口和其他网络接口。这意味着其他计算机或设备可以通过网络访问该应用程序，前提是网络连接和防火墙允许。</li>
</ul>
</li>
<li>
<p>简而言之，<code>localhost</code>指的是本地计算机或设备自身，只能通过本地访问。而<code>0.0.0.0</code>表示任意主机或所有主机，可以通过网络访问。在开发过程中，通常将应用程序绑定到localhost以进行本地开发和测试，而将其绑定到<code>0.0.0.0</code>可以使其在局域网或公共网络上可访问。</p>
</li>
</ul>
<h3> port、open、compress</h3>
<ul>
<li>port设置监听的端口，默认情况下是8080
<ul>
<li>这个选项用于指定Webpack开发服务器的端口号。通过设置port选项，你可以指定应用程序在开发服务器上监听的端口。</li>
</ul>
</li>
<li>open是否打开浏览器：
<ul>
<li>默认值是false，设置为true会打开浏览器；</li>
<li>这个选项用于指定是否在启动Webpack开发服务器后自动打开浏览器。通过设置open选项为true，开发服务器将在启动后自动打开默认浏览器，并加载应用程序</li>
<li>也可以设置为类似于 Google Chrome等值；</li>
</ul>
</li>
<li>compress是否为静态文件开启gzip compression：
<ul>
<li>默认值是false，可以设置为true；</li>
<li>这个选项用于指定是否启用gzip压缩。通过设置compress选项为true，开发服务器将对传输到浏览器的资源进行gzip压缩，以减小文件大小，提高传输速度。</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Proxy</h3>
<blockquote>
<p>https://webpack.docschina.org/configuration/dev-server#devserverproxy</p>
</blockquote>
<ul>
<li>
<p>proxy是我们开发中非常常用的一个配置选项，它的目的设置代理来解决跨域访问的问题：</p>
<ul>
<li>比如我们的一个api请求是 http://localhost:3000但是本地启动服务器的域名是 http://localhost:8000，这 个时候发送网络请求就会出现跨域的问题；</li>
<li>那么我们可以将请求先发送到一个代理服务器，代理服务器和API服务器没有跨域的问题，就可以解决我们的跨域问题了</li>
</ul>
</li>
<li>
<p>代理（Proxy）是一种常见的网络应用程序架构，它可以将客户端的请求转发到另一个服务器进行处理。在开发环境中，我们通常会将应用程序和API服务分开部署，这时就需要使用代理将客户端的API请求转发到后端API服务器上。</p>
</li>
<li>
<p>在 Webpack 的 devServer 中，可以使用proxy选项来配置代理设置。proxy选项可以是一个对象，也可以是一个函数。对象方式的proxy选项可以指定一个或多个代理规则，每个规则包含了要转发的请求路径和目标服务器地址。例如：</p>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>在这个示例中，我们将所有以<code>/api</code>开头的请求转发到<code>http://localhost:3000</code>服务器上。同时，我们还设置了<code>changeOrigin</code>选项为<code>true</code>，以改变请求头中的<code>Origin</code>字段，并使用<code>pathRewrite</code>选项将请求路径中的<code>/api</code>前缀替换为空。</li>
<li>当 <code>changeOrigin </code>设置为 true 时，代理服务器会将请求头中的 Origin 字段替换为目标服务器的地址，这样目标服务器就可以正确识别请求来源。否则，目标服务器可能会拒绝请求或返回错误的响应。</li>
<li>除了对象方式的<code>proxy</code>选项外，还可以使用函数方式的<code>proxy</code>选项来进行更灵活的配置。例如：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>在这个示例中，我们使用函数方式的<code>proxy</code>选项来动态配置代理规则。如果请求路径以<code>/api</code>开头，则将其转发到<code>http://localhost:3000</code>服务器上，并使用相应的选项进行配置。</p>
</li>
<li>
<p>默认情况下，将不接受在 HTTPS 上运行且证书无效的后端服务器。 如果需要，可以这样修改配置：</p>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> historyApiFallback</h3>
<ul>
<li>
<p><code>historyApiFallback </code>是 <code>webpack-dev-server </code>的一个配置项，用于控制当使用 HTML5 History API 时，如果找不到对应的资源应该返回什么页面。</p>
</li>
<li>
<p>当浏览器使用 HTML5 History API 进行前端路由跳转时，例如从<code> /home</code> 跳转到 <code>/about</code>，浏览器会向服务器发送一个 GET 请求，但是服务器上并没有对应的 <code>/about</code> 路径和资源，此时会返回 404 错误。为了避免这种情况，<code>historyApiFallback</code> 可以设置一个默认的页面，用于代替 404 错误页面。</p>
</li>
<li>
<p>例如，设置 <code>historyApiFallback</code>: true 后，当访问一个不存在的路由时，<code>webpack-dev-server</code> 会返回一个默认的 HTML 页面，通常是 <code>index.html</code>。这个页面会包含前端路由所需的 JavaScript 和 CSS 资源，从而保证前端路由跳转的正常运行。</p>
</li>
<li>
<p>需要注意的是，在生产环境中，historyApiFallback 应该由服务器来处理，而不是由前端框架或工具来处理。</p>
</li>
<li>
<p>https://webpack.docschina.org/configuration/dev-server/#devserverhistoryapifallback</p>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>要将 404 错误跳转到一个名为 <code>404.html </code>的页面，你可以通过 <code>historyApiFallback </code>的 <code>rewrites </code>选项来实现。以下是一个示例配置：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>在上述配置中，我们使用了 <code>rewrites </code>数组来定义重写规则。第一个规则 <code>{ from: /^\/$/, to: '/index.html' }</code> 将根路径 <code>/ </code>重写到 <code>index.html</code> 页面，这样确保了默认路径的正确加载。第二个规则 <code>{ from: /./, to: '/404.html' } </code>将所有其他路径都重写到 <code>404.html</code> 页面，实现了将 404 错误跳转到指定页面的效果。</li>
</ul>
<h2> resolve模块解析</h2>
<blockquote>
<p>https://webpack.docschina.org/configuration/resolve</p>
</blockquote>
<ul>
<li><code>resolve </code>是 <code>webpack</code> 中的一个配置选项，用于配置模块解析的规则。
<ul>
<li>在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库；</li>
<li>resolve可以帮助webpack从每个 require/import 语句中，找到需要引入到合适的模块代码；</li>
<li>webpack 使用 <a href="https://github.com/webpack/enhanced-resolve" target="_blank" rel="noopener noreferrer">enhanced-resolve</a> 来解析文件路径；</li>
</ul>
</li>
</ul>
<ol>
<li>
<p>extensions
<code>extensions </code>用于配置在导入模块时可以省略的文件扩展名。例如，配置了 <code>extensions: ['.js', '.jsx']</code> 后，当导入模块时可以省略文件扩展名，如 <code>import MyComponent from './MyComponent'</code>，<code>webpack</code> 会自动尝试解析 <code>MyComponent.js</code> 或 <code>MyComponent.jsx</code>。</p>
</li>
<li>
<p>alias
<code>alias </code>用于创建模块的别名，可以简化模块导入的路径。例如，配置了 <code>alias: { '@': path.resolve(__dirname, 'src') } </code>后，可以使用<code>import MyComponent from '@/components/MyComponent'</code>来导入位于 <code>src/components/MyComponent</code> 的模块。</p>
</li>
<li>
<p>modules
<code>modules </code>用于配置 <code>webpack </code>在解析模块时搜索的目录。默认情况下，<code>webpack </code>只会搜索 <code>node_modules</code> 目录。通过配置 <code>modules</code>，可以告诉 <code>webpack </code>在其他目录中查找模块。例如，配置了 <code>modules: ['src', 'node_modules']</code> 后，<code>webpack </code>会先在 <code>src </code>目录中查找模块，然后再在 <code>node_modules </code>目录中查找。</p>
</li>
<li>
<p>mainFields
<code>mainFields </code>用于配置在导入模块时，<code>webpack </code>优先使用的字段。当导入一个模块时，它可能在 <code>package.json</code> 文件中定义了多个入口字段（如 main, module, browser 等）。通过配置 <code>mainFields</code>，可以告诉 webpack 使用哪个字段作为模块的主入口。例如，配置了 <code>mainFields: ['browser', 'module', 'main']</code> 后，webpack 会优先使用 <code>browser</code> 字段，然后是 <code>module </code>字段，最后是 <code>main </code>字段。</p>
</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>webpack能解析三种文件路径：
<ul>
<li>绝对路径
<ul>
<li>由于已经获得文件的绝对路径，因此不需要再做进一步解析。</li>
</ul>
</li>
<li>相对路径
<ul>
<li>在这种情况下，使用 import 或 require 的资源文件所处的目录，被认为是上下文目录；</li>
<li>在 import/require 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径；</li>
</ul>
</li>
<li>模块路径
<ul>
<li>在 resolve.modules中指定的所有目录检索模块；
<ul>
<li>默认值是 [‘node_modules’]，所以默认会从node_modules中查找文件；</li>
</ul>
</li>
<li>我们可以通过设置别名的方式来替换初识模块路径，具体后面讲解alias的配置；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2> 区分开发/ 生产环境</h2>
<ul>
<li>目前我们所有的webpack配置信息都是放到一个配置文件中的：webpack.config.js
<ul>
<li>当配置越来越多时，这个文件会变得越来越不容易维护；</li>
<li>并且某些配置是在开发环境需要使用的，某些配置是在生成环境需要使用的，当然某些配置是在开发和生成环 境都会使用的；</li>
<li>所以，我们最好对配置进行划分，方便我们维护和管理；</li>
</ul>
</li>
<li>方案一：编写两个不同的配置文件，开发和生成时，分别加载不同的配置文件即可；</li>
</ul>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202311192229409.png" alt="image-20231119222920881" tabindex="0" loading="lazy"><figcaption>image-20231119222920881</figcaption></figure>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>方式二：使用相同的一个入口配置文件，通过设置参数来区分它们；</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>在命令行中，可以通过 <code>--mode</code> 参数来指定 webpack 的构建模式。例如：</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202311191904772.png" type="image/png"/>
    </item>
    <item>
      <title>Webpack_Babel</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/cli/babel.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/cli/babel.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Webpack_Babel</source>
      <description>什么是 Babel? https://babeljs.io/ Babel 是一个 JavaScript 编译器，可以将 ECMAScript 2015+ 代码转换为向后兼容的 JavaScript 版本，以便在当前和旧版浏览器或环境中运行。它还支持将 JSX 转换为普通 JavaScript 代码。Babel 是一个非常流行的工具，许多现代的 JavaScript 应用程序都使用它来构建和部署。 事实上，在开发中我们很少直接去接触babel，但是babel对于前端开发来说，目前是不可缺少的一部分： 开发中，我们想要使用ES6+的语法，想要使用TypeScript，开发React项目，它们都是离不开Babel的；所以，学习Babel对于我们理解代码从编写到线上的转变过程至关重要；</description>
      <pubDate>Fri, 17 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是 Babel?</h2>
<blockquote>
<p>https://babeljs.io/</p>
</blockquote>
<blockquote>
<ul>
<li>Babel 是一个 JavaScript 编译器，可以将 ECMAScript 2015+ 代码转换为向后兼容的 JavaScript 版本，以便在当前和旧版浏览器或环境中运行。它还支持将 JSX 转换为普通 JavaScript 代码。Babel 是一个非常流行的工具，许多现代的 JavaScript 应用程序都使用它来构建和部署。</li>
<li>事实上，在开发中我们很少直接去接触babel，但是babel对于前端开发来说，目前是不可缺少的一部分：</li>
<li>开发中，我们想要使用ES6+的语法，想要使用TypeScript，开发React项目，它们都是离不开Babel的；所以，学习Babel对于我们理解代码从编写到线上的转变过程至关重要；</li>
</ul>
</blockquote>
<ul>
<li>以下是一个使用 Babel 的示例：</li>
<li>假设我们有一个使用箭头函数和 const 声明的简单 JavaScript 模块：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>如果我们想要在旧版浏览器中运行它，我们可以使用 Babel 将其转换为 ES5：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>这个转换过的代码可以在大多数浏览器中运行，即使它们不支持箭头函数或 const 声明。</li>
</ul>
<h2> Babel 命令行使用</h2>
<ul>
<li>babel本身可以作为一个独立的工具（和postcss一样），不和webpack等构建工具配置来单独使用。</li>
<li>如果我们希望在命令行尝试使用babel，需要安装如下库：
<ul>
<li>@babel/core：babel的核心代码，必须安装；</li>
<li>@babel/cli：可以让我们在命令行使用babel；</li>
</ul>
</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>使用babel来处理我们的源代码：
<ul>
<li>src：是源文件的目录；</li>
<li>–out-dir：指定要输出的文件夹dist；</li>
<li>--out-file: 指定要输出的文件dist；</li>
</ul>
</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 插件</h2>
<ul>
<li>
<p>Babel 的插件是用于转换 JavaScript 代码的小型程序，可以添加到 Babel 配置中。Babel 插件可以执行各种任务，例如：</p>
<ul>
<li>转换语法：将新的 ECMAScript 特性转换为向后兼容的代码。</li>
<li>转换 API：将使用新 API 的代码转换为旧 API。</li>
<li>转换 JSX：将 JSX 转换为普通的 JavaScript 代码。</li>
</ul>
</li>
<li>
<p>以下是一些常见的 Babel 插件：</p>
<ul>
<li>@babel/plugin-transform-arrow-functions: 将箭头函数转换为普通函数。</li>
<li>@babel/plugin-transform-block-scoping: 将 let 和 const 声明转换为 var 声明。</li>
<li>@babel/plugin-transform-classes: 将类转换为 ES5 构造函数。</li>
<li>@babel/plugin-transform-destructuring: 将解构赋值转换为普通赋值。</li>
<li>@babel/plugin-transform-object-assign: 将 Object.assign() 转换为 ES5 兼容的代码。</li>
<li>@babel/plugin-transform-react-jsx: 将 JSX 转换为普通的 JavaScript 代码。</li>
<li>@babel/plugin-transform-runtime: 避免在每个文件中重复使用 Babel 运行时代码。</li>
</ul>
</li>
<li>
<p>如何使用?</p>
<ul>
<li>比如我们需要转换箭头函数, const 转成 var，那么我们就可以使用箭头函数转换相关的插件：</li>
</ul>
</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 预设 preset</h2>
<p>Babel 的预设（preset）是一组预先配置的转换规则，用于将特定版本的 JavaScript 代码转换为向后兼容的旧版本。以下是一些常用的 Babel 预设：</p>
<ol>
<li>@babel/preset-env: 根据目标环境自动确定需要的转换规则。它根据你在 .babelrc 或 babel.config.js 文件中的配置来确定需要转换的 JavaScript 特性。</li>
<li>@babel/preset-react: 用于转换 React JSX 语法的预设。它可以将 JSX 转换为普通的 JavaScript 代码。</li>
<li>@babel/preset-typescript: 用于转换 TypeScript 代码的预设。它可以将 TypeScript 的类型注解和其他特定语法转换为普通的 JavaScript 代码。</li>
<li>@babel/preset-flow: 用于转换 Flow 类型注解的预设。它可以将 Flow 的类型注解转换为普通的 JavaScript 代码。</li>
</ol>
<p>这些预设可以根据你的项目需求进行选择和配置。你可以在 .babelrc 或 babel.config.js 文件中指定所需的预设，例如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 原理</h2>
<h3> 底层原理</h3>
<ul>
<li>
<p>babel是如何做到将我们的一段代码（ES6、TypeScript、React）转成另外一段代码（ES5）的呢？</p>
<ul>
<li>从一种源代码（原生语言）转换成另一种源代码（目标语言），这是什么的工作呢？</li>
<li>就是编译器，事实上我们可以将babel看成就是一个编译器。</li>
<li>Babel编译器的作用就是将我们的源代码，转换成浏览器可以直接识别的另外一段源代码；</li>
</ul>
</li>
<li>
<p>Babel也拥有编译器的工作流程：</p>
<ul>
<li>解析（Parsing）：Babel首先将输入的JavaScript代码解析成抽象语法树（Abstract Syntax Tree，AST）。AST是一个用于表示代码结构的树状数据结构，它能够准确地描述代码的语法和语义。</li>
<li>转换（Transformation）：在AST的基础上，Babel会应用一系列的插件和预设来进行代码转换。这些插件和预设可以执行各种转换操作，例如语法转换、代码优化、添加兼容性处理等。每个插件都负责处理AST中的特定节点，并根据需要进行修改或替换。</li>
<li>生成（Generation）：转换完成后，Babel会将修改后的AST重新生成为JavaScript代码。这些生成的代码可以是与输入代码相同的版本，也可以是经过转换后的新代码。</li>
</ul>
</li>
<li>
<p>https://github.com/jamiebuilds/the-super-tiny-compiler: 非常简单的编译器实现，旨在教授编译器原理和实践。</p>
</li>
</ul>
<h3> 执行原理</h3>
<blockquote>
<p>Babel的执行阶段</p>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202311162053777.png" alt="image-20231116205304599" tabindex="0" loading="lazy"><figcaption>image-20231116205304599</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202311162053832.png" alt="image-20231116205317664" tabindex="0" loading="lazy"><figcaption>image-20231116205317664</figcaption></figure>
<ol>
<li>词法分析（Lexing）：将输入的源代码字符串转换为一个令牌（Token）序列。每个令牌代表源代码中的一个语法单元，例如标识符、运算符、括号等。</li>
<li>语法分析（Parsing）：将令牌序列转换为抽象语法树（AST）。AST是一个用于描述代码结构的树状数据结构，它能够准确地描述源代码的语法和语义。</li>
<li>转换（Transformation）：在AST的基础上，应用一系列的转换规则，以修改和优化AST。这些规则可以执行各种操作，例如语法转换、代码优化、添加兼容性处理等。</li>
<li>代码生成（Code Generation）：将修改后的AST转换为目标语言的代码。在"The Super Tiny Compiler"中，目标语言是JavaScript。</li>
<li>输出：输出生成的目标代码。</li>
</ol>
<h2> babel-loader</h2>
<ul>
<li>babel-loader是一个用于在Webpack构建过程中将JavaScript代码转换的加载器（loader）。它是与Babel配合使用的常用工具之一。</li>
<li>通过配置Webpack的规则，使用babel-loader可以将指定的JavaScript文件传递给Babel进行转换。Babel会根据配置的插件和预设，将源代码转换为目标浏览器或环境所支持的语法。</li>
<li>指定使用的插件</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311162205301.png" alt="image-20231116220536704" tabindex="0" loading="lazy"><figcaption>image-20231116220536704</figcaption></figure>
<ul>
<li>
<p>presets 预设:  如果我们一个个去安装使用插件，那么需要手动来管理大量的babel插件，我们可以直接给webpack提供一个 preset，webpack会根据我们的预设来加载对应的插件列表，并且将其传递给babel。以下使用 <code>@babel/preset-env</code></p>
<ul>
<li>env</li>
<li>react</li>
<li>TypeScript</li>
</ul>
</li>
<li>
<p>使用 babel-loader 的一般步骤如下：</p>
<ol>
<li>安装 babel-loader 和相关的Babel插件和预设：</li>
</ol>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2">
<li>webpack.config.js，在其中配置 babel-loader：</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h2> 配置文件</h2>
<ul>
<li>我们可以将babel的配置信息放到一个独立的文件中，babel给我们提供了两种配置文件的编写：
<ul>
<li>babel.config.json（或者.js，.cjs，.mjs）文件；</li>
<li>babelrc.json（或者.babelrc，.js，.cjs，.mjs）文件；</li>
</ul>
</li>
<li>它们两个有什么区别呢？目前很多的项目都采用了多包管理的方式（babel本身、element-plus、umi等）；
<ul>
<li>.babelrc.json：早期使用较多的配置方式，但是对于配置Monorepos项目是比较麻烦的；</li>
<li>babel.config.json（babel7）：可以直接作用于Monorepos项目的子包，更加推荐；</li>
<li>补充: <em>Monorepo</em> 是一种项目代码管理方式,指单个仓库中管理多个项目,有助于简化代码共享、版本控制、构建和部署等方面的复杂性,并提供更好的可重用性和协作性, 类似 <code>@babel/preset-env</code> 这种写法大概率就是 Monorepo</li>
</ul>
</li>
<li>以下为 <code>babel.config.js</code></li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>这样在 <code>webpack.config.js</code> 中只需要</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 在 Webpack 中使用 Vue</h2>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>此时重新 <code>build</code> 运行后不显示, 报错如下</p>
<p><code>runtime-core.esm-bundler.js:38 [Vue warn]: Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js" at &lt;App&gt;</code> -&gt; <code>runtime-core.esm-bundler.js:38</code></p>
</blockquote>
<blockquote>
<p>这个错误是因为 Vue 3 默认不包含模板编译器，所以当你试图在组件中使用 <code>template</code> 选项时，你会看到这个警告。</p>
<p>要解决这个问题，你需要在 webpack 配置中添加一个别名，将 "vue" 指向 "vue/dist/vue.esm-bundler.js"。这个版本的 Vue 包含了模板编译器。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>Vue打包后不同版本解析</p>
<ul>
<li>vue(.runtime).global(.prod).js 是用于直接在浏览器中引入的全局版本，可以通过 <code>&lt;script&gt;</code> 标签来使用。
+ 我们之前通过CDN引入和下载的Vue版本就是这个版本；
+ 会暴露一个全局的Vue来使用；</li>
<li>vue(.runtime).esm-browser(.prod).js 是用于原生 ES 模块导入的版本，在支持 ES 模块的浏览器中可以使用 <code>&lt;script type='module'&gt;</code> 来引入。</li>
<li>vue(.runtime).esm-bundler.js 是用于构建工具（如webpack、rollup、parcel等）的版本，默认情况下会使用 vue.runtime.esm-bundler.js。如果需要解析模板（template），则需要手动指定 vue.esm-bundler.js。</li>
<li>vue.cjs(.prod).js 是用于服务器端渲染的版本，在 Node.js 中可以使用 require() 来引入。
<ul>
<li><code>require</code> 是 Node.js 中用于导入模块的函数。它是 CommonJS 模块系统的一部分，这是 Node.js 的默认模块系统。以下是一个 <code>require</code> 的基本用法示例：<code>const fs = require('fs');</code>在这个例子中，我们导入了 Node.js 的内置 <code>fs</code>（文件系统）模块。</li>
<li><code>require</code> 函数也可以用来导入你自己的模块。例如，如果你有一个名为 <code>myModule.js</code> 的文件，你可以这样导入它：<code>const myModule = require('./myModule.js');</code> 注意，当导入自己的模块时，你需要提供模块的相对路径（以 <code>./</code> 开头）。</li>
<li>然而，<code>require</code> 并不是 ECMAScript（JavaScript 的标准化规范）的一部分，因此它在浏览器环境中通常不可用。在浏览器环境中，你通常会使用 ECMAScript 的 <code>import</code> 和 <code>export</code> 语句来导入和导出模块。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>接下来我们把 main.js 中的 vue 代码抽离为单文件组件(SFC)</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>重新打包, 报错：我们需要合适的Loader来处理文件。</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>配置 <code>webpack.config.js</code></li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>重新 build 仍然报错 <code>Error:vue-loader requires @vue/compiler present the dependency tree</code>, 打包依然会报错，这是因为我们必须添加@vue/compiler-sfc来对template进行解析：</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>重新打包即可支持App.vue的写法</p>
</li>
</ul>
<h2> 补充</h2>
<ul>
<li>
<p>当然此时控制台还有如下报错 <code>You are running the csm-bundler bu1ld of Vue, It is recommended to contigure your bundler to expl1citly roplace featur flag globals with boolean literals to get proper tree-shaking in the fina bundle, See http://link,yuejs.org/feature-flags for more details.</code></p>
</li>
<li>
<p>在官方解释如下: https://github.com/vuejs/core/tree/main/packages/vue#bundler-build-feature-flags</p>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311172346161.png" alt="image-20231117234618957" tabindex="0" loading="lazy"><figcaption>image-20231117234618957</figcaption></figure>
<ul>
<li>Bundler Build Feature Flags是构建工具（Bundler）中的一种特性标志，用于控制Vue框架的不同特性的开启和关闭。从Vue 3.0.0-rc.3版本开始，esm-bundler构建工具现在公开了全局特性标志，可以在编译时进行覆盖。其中两个重要的特性标志包括：
<ul>
<li>VUE_OPTIONS_API：启用/禁用Options API支持，默认为true。</li>
<li>VUE_PROD_DEVTOOLS：启用/禁用生产环境下的devtools支持，默认为false。</li>
</ul>
</li>
<li>在没有配置这些特性标志的情况下，构建工具仍然可以正常工作，但强烈建议正确配置它们以便在最终的打包文件中实现正确的树摇效果。要配置这些特性标志：
<ul>
<li>https://webpack.js.org/plugins/define-plugin/</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>开启Bundler Build Feature Flags的好处在于能够更好地控制Vue框架的特性和功能，从而有效地减少最终打包文件的大小。通过正确配置特性标志，可以实现树摇（tree-shaking）效果，即只包含应用程序实际使用的代码，而不包含未使用的代码。这将有助于提高应用程序的性能和加载速度，并减少资源消耗。此外，通过禁用不需要的特性，还可以减少应用程序的复杂性，并提高代码的可维护性。因此，建议开发人员在使用Vue框架时正确配置Bundler Build Feature Flags，以获得更好的开发和部署体验。</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202311162053777.png" type="image/png"/>
    </item>
    <item>
      <title>Webpack</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/cli/Webpack.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/cli/Webpack.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Webpack</source>
      <description>认识webpack 事实上随着前端的快速发展，目前前端的开发已经变的越来越复杂了： 比如开发过程中我们需要通过模块化的方式来开发； 比如也会使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑， 通过sass、less等方式来编写 css 样式代码； 比如开发过程中，我们还希望实时的监听文件的变化来并且反映到浏览器上，提高开发的效率； 比如开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化； 但是对于很多的前端开发者来说，并不需要思考这些问题，日常的开发中根本就没有面临这些问题： 这是因为目前前端开发我们通常都会直接使用三大框架来开发：Vue、React、Angular； 但是事实上，这三大框架的创建过程我们都是借助于脚手架（CLI）的； 事实上Vue-CLI、create-react-app、Angular-CLI都是基于webpack来帮助我们支持模块化、less、 TypeScript、打包优化等的；</description>
      <pubDate>Wed, 15 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 认识webpack</h2>
<ul>
<li>
<p>事实上随着前端的快速发展，目前前端的开发已经变的越来越复杂了：</p>
<ul>
<li>比如开发过程中我们需要通过模块化的方式来开发；</li>
<li>比如也会使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑， 通过sass、less等方式来编写 css 样式代码；</li>
<li>比如开发过程中，我们还希望实时的监听文件的变化来并且反映到浏览器上，提高开发的效率；</li>
<li>比如开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化；</li>
</ul>
</li>
<li>
<p>但是对于很多的前端开发者来说，并不需要思考这些问题，日常的开发中根本就没有面临这些问题：</p>
<ul>
<li>这是因为目前前端开发我们通常都会直接使用三大框架来开发：Vue、React、Angular；</li>
<li>但是事实上，这三大框架的创建过程我们都是借助于脚手架（CLI）的；</li>
<li>事实上Vue-CLI、create-react-app、Angular-CLI都是基于webpack来帮助我们支持模块化、less、 TypeScript、打包优化等的；</li>
</ul>
</li>
</ul>
<h2> Webpack到底是什么呢？</h2>
<blockquote>
<p>https://webpack.docschina.org/</p>
</blockquote>
<blockquote>
<p>本质上，<strong>webpack</strong> 是一个用于现代 JavaScript 应用程序的 <em>静态模块打包工具</em>。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 <a href="https://webpack.docschina.org/concepts/dependency-graph/" target="_blank" rel="noopener noreferrer">依赖图(dependency graph)</a>，然后将你项目中所需的每一个模块组合成一个或多个 <em>bundles</em>，它们均为静态资源，用于展示你的内容。</p>
<ul>
<li>打包bundler：webpack可以将帮助我们进行打包，所以它是一个打包工具</li>
<li>模块化module：webpack默认支持各种模块化开发，ES Module、CommonJS、AMD等；</li>
</ul>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202311021029845.png" alt="image-20231102102926580" tabindex="0" loading="lazy"><figcaption>image-20231102102926580</figcaption></figure>
<h2> Vue项目加载的文件有哪些呢？</h2>
<ul>
<li>JavaScript的打包：
<ul>
<li>将ES6转换成ES5的语法；</li>
<li>TypeScript的处理，将其转换成JavaScript；</li>
</ul>
</li>
<li>Css的处理：
<ul>
<li>CSS文件模块的加载、提取；</li>
<li>Less、Sass等预处理器的处理；</li>
</ul>
</li>
<li>资源文件img、font：
<ul>
<li>图片img文件的加载；</li>
<li>字体font文件的加载；</li>
</ul>
</li>
<li>HTML资源的处理：
<ul>
<li>打包HTML资源文件；</li>
</ul>
</li>
<li>处理vue项目的SFC文件.vue文件</li>
</ul>
<h2> Webpack的使用</h2>
<ul>
<li>webpack的官方文档是<a href="https://webpack.js.org/" target="_blank" rel="noopener noreferrer">webpack</a>
<ul>
<li>webpack的中文官方文档是<a href="https://webpack.docschina.org/" target="_blank" rel="noopener noreferrer">webpack</a></li>
</ul>
</li>
<li>Webpack的运行是依赖Node环境的，所以我们电脑上必须有Node环境
<ul>
<li>所以我们需要先安装Node.js，并且同时会安装npm；</li>
<li>Node官方网站：<a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer">Node.js</a></li>
</ul>
</li>
</ul>
<h3> Webpack的安装</h3>
<ul>
<li>webpack的安装目前分为两个：webpack、webpack-cli</li>
<li>执行webpack命令，会执行node_modules下的.bin目录下的webpack；</li>
<li>webpack在执行时是依赖webpack-cli的，如果没有安装就会报错；</li>
<li>而webpack-cli中代码执行时，才是真正利用webpack进行编译和打包的过程；</li>
<li>所以在安装webpack时，我们需要同时安装webpack-cli（第三方的脚手架事实上是没有使用webpack-cli的，而是类似于自 己的vue-service-cli的东西）</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311051542731.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h3> Webpack的默认打包</h3>
<blockquote>
<p>ES6、CommonJS等模块化语法在浏览器中是不被直接识别的，但是通过使用Webpack的打包功能，可以将这些语法转换为浏览器可以识别的语法。Webpack可以将多个模块打包成一个或多个浏览器可识别的文件，使得在浏览器中可以正常运行这些模块化代码。</p>
</blockquote>
<ul>
<li>
<p>我们可以通过webpack进行打包，之后运行打包之后的代码</p>
<ul>
<li>在目录下直接执行 webpack 命令</li>
</ul>
</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>
<p>生成一个 dist 文件夹，里面存放一个main.js的文件，就是我们打包之后的文件：</p>
<ul>
<li>这个文件中的代码被压缩和丑化了；</li>
<li>另外我们发现代码中依然存在ES6的语法，比如箭头函数、const等，这是因为默认情况下webpack并不清楚我们打包后的文 件是否需要转成ES5之前的语法，后续我们需要通过babel来进行转换和设置；</li>
</ul>
</li>
<li>
<p>我们发现是可以正常进行打包的，但是有一个问题，webpack是如何确定我们的入口的呢？</p>
<ul>
<li>事实上，当我们运行webpack时，webpack会查找当前目录下的 src/index.js作为入口；</li>
<li>所以，如果当前项目中没有存在 src/index.js 文件，那么会报错；</li>
</ul>
</li>
<li>
<p>当然，我们也可以通过配置来指定入口和出口</p>
</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> webpack 局部安装</h3>
<ol>
<li>版本控制：通过在项目中局部安装Webpack，可以确保每个项目使用的Webpack版本是一致的，避免不同项目之间的版本冲突。</li>
<li>简化部署：将Webpack安装在项目的本地目录中，可以简化项目的部署过程。只需要将整个项目目录复制到其他环境中，不需要再次安装全局的Webpack。</li>
<li>隔离环境：每个项目可以拥有自己独立的Webpack配置和插件，不会受到其他项目的影响。这样可以更灵活地根据项目需求进行定制和配置。</li>
<li>可移植性：通过局部安装Webpack，可以将整个项目打包成一个可移植的文件夹，方便在不同环境中进行迁移和共享。</li>
</ol>
<ul>
<li>第一步：创建package.json文件，用于管理项目的信息、库依赖等</li>
</ul>
<div class="language-csharp line-numbers-mode" data-ext="cs"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>第二步：安装局部的webpack</li>
</ul>
<div class="language-csharp line-numbers-mode" data-ext="cs"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>第三步：使用局部的webpack</li>
</ul>
<div class="language-undefined line-numbers-mode" data-ext="undefined"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>第四步：在 package.json 中创建scripts脚本，执行脚本打包即可</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202311052352789.png" alt="image-20231105235229201" tabindex="0" loading="lazy"><figcaption>image-20231105235229201</figcaption></figure>
<h2> Webpack配置</h2>
<h3> Webpack 配置文件</h3>
<ul>
<li>在通常情况下，webpack需要打包的项目是非常复杂的，并且我们需要一系列的配置来满足要求，默认配置必然 是不可以的。</li>
<li>我们可以在根目录下创建一个webpack.config.js文件，来作为webpack的配置文件：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>继续执行webpack命令，依然可以正常打包</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 指定配置文件</h3>
<ul>
<li>
<p>但是如果我们的配置文件并不是webpack.config.js的名字，而是其他的名字呢？</p>
<ul>
<li>比如我们将webpack.config.js修改成了 wk.config.js；</li>
<li>这个时候我们可以通过 --config 来指定对应的配置文件；</li>
</ul>
</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>但是每次这样执行命令来对源码进行编译，会非常繁琐，所以我们可以在package.json中增加一个新的脚本：</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>之后我们执行 npm run build来打包即可。</li>
</ul>
<h2> Webpack的依赖</h2>
<p>Webpack通过以下步骤对项目进行打包：</p>
<ol>
<li>配置：创建一个Webpack配置文件（通常命名为webpack.config.js），在其中定义打包的入口文件、输出文件的路径、加载器和插件等。</li>
<li>入口：在配置文件中指定打包的入口文件，可以是单个文件或多个文件,  从入口开始，会生成一个 依赖关系图，这个依赖关系图会包含应用程序中所需的所有模块（比如 js 文件、css 文件、图片、字体等), 然后遍历图结构，打包一个个模块（根据文件的不同使用不同的loader来解析）；</li>
<li>加载器：根据需要，配置加载器来处理不同类型的文件。例如，使用babel-loader来转换ES6+代码，使用 css-loader 和 style-loader 来处理CSS文件。</li>
<li>插件：根据需要，配置插件来执行额外的任务。例如，使用html-webpack-plugin生成HTML文件，使用mini-css-extract-plugin提取CSS文件。</li>
<li>输出：在配置文件中指定打包输出的路径和文件名。</li>
<li>运行：在命令行中运行webpack命令，Webpack将根据配置文件进行打包，并生成输出文件。</li>
</ol>
<p>在运行Webpack命令时，可以使用不同的参数和选项来控制打包的行为。例如，使用--mode参数指定打包的模式（开发模式或生产模式），使用--watch选项启用监听模式等。</p>
<figure><img src="https://qiniu.waite.wang/202311060009812.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h2> loader的使用</h2>
<blockquote>
<p>https://webpack.docschina.org/loaders/</p>
<p>在 Webpack5 以后会采用 asset module type 来替代 loader</p>
</blockquote>
<blockquote>
<p>在Webpack中，Loader是用于对不同类型的文件进行转换和处理的模块。它们作为Webpack的一部分，用于在打包过程中对文件进行预处理。</p>
<p>Loader可以将不同类型的文件（如JavaScript、CSS、图片等）转换为模块，以便在应用程序中使用。它们可以执行各种任务，例如将ES6+代码转换为ES5语法、处理CSS文件中的样式、压缩和优化图像等。</p>
<p>Loader通常以链式调用的方式使用，可以根据需要配置多个Loader来处理文件。每个Loader都会对文件进行一次转换，并将转换后的结果传递给下一个Loader，直到最后一个Loader将最终的结果返回给Webpack进行打包。</p>
<p>Loader的配置是通过Webpack的配置文件（通常是webpack.config.js）中的module.rules字段来完成。在这个字段中，可以指定不同类型文件的匹配规则和对应的Loader。</p>
</blockquote>
<h3> css-loader 的使用</h3>
<ul>
<li>对于加载css文件来说，我们需要一个可以读取css文件的loader；</li>
<li>这个loader最常用的是css-loader；</li>
<li>css-loader的安装：</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>如何使用这个loader来加载css文件呢？有三种方式：
<ul>
<li>内联方式；</li>
<li>CLI方式（webpack5中不再使用）；</li>
<li>配置方式；</li>
</ul>
</li>
</ul>
<ol>
<li>
<p>内联方式：内联方式使用较少，因为不方便管理；</p>
<ul>
<li>在引入的样式前加上使用的loader，并且使用 ! 分割；</li>
</ul>
</li>
</ol>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2">
<li>配置方式</li>
</ol>
<ul>
<li>配置方式表示的意思是在我们的webpack.config.js文件中写明配置信息：
<ul>
<li>module.rules中允许我们配置多个loader（因为我们也会继续使用其他的loader，来完成其他文件的加载)</li>
<li>这种方式可以更好的表示loader的配置，也方便后期的维护，同时也让你对各个Loader有一个全局的概览</li>
</ul>
</li>
<li>module.rules的配置如下：
<ul>
<li>rules属性对应的值是一个数组：[Rule]</li>
<li>数组中存放的是一个个的Rule，Rule是一个对象，对象中可以设置多个属性：
<ul>
<li>test属性：用于对 resource（资源）进行匹配的，通常会设置成正则表达式；</li>
<li>use属性：对应的值时一个数组：[UseEntry]
<ul>
<li>UseEntry是一个对象，可以通过对象的属性来设置一些其他属性
<ul>
<li>loader：必须有一个 loader属性，对应的值是一个字符串；</li>
<li>options：可选的属性，值是一个字符串或者对象，值会被传入到loader中；</li>
<li>query：目前已经使用options来替代；</li>
</ul>
</li>
<li>传递字符串（如：use: [ 'style-loader' ]）是 loader 属性的简写方式（如：use: [ { loader: 'style-loader'} ]）；</li>
</ul>
</li>
<li>loader属性： Rule.use: [ { loader } ] 的简写</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> style-loader</h3>
<ul>
<li>
<p>我们已经可以通过css-loader来加载css文件了</p>
<ul>
<li>但是你会发现这个css在我们的代码中并没有生效（页面没有效果）。</li>
</ul>
</li>
<li>
<p>因为css-loader只是负责将.css文件进行解析，并不会将解析之后的css插入到页面中；</p>
</li>
<li>
<p>如果我们希望再完成插入style的操作，那么我们还需要另外一个loader，就是style-loader；</p>
</li>
<li>
<p>安装style-loader：</p>
</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>那么我们应该如何使用style-loader：
<ul>
<li>在配置文件中，添加style-loader；</li>
<li>注意：因为loader的执行顺序是从右向左（或者说从下到上，或者说从后到前的），所以我们需要将style-loader写到 css-loader 的前面；</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> Less工具处理</h3>
<ul>
<li>我们可以使用less工具来完成它的编译转换：</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>执行如下命令：</li>
</ul>
<div class="language-cobol line-numbers-mode" data-ext="cobol"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> less-loader处理</h4>
<ul>
<li>
<p>但是在项目中我们会编写大量的css，它们如何可以自动转换呢？</p>
<ul>
<li>这个时候我们就可以使用less-loader，来自动使用less工具转换less到css；</li>
</ul>
</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> postcss-loader(认识)</h3>
<ul>
<li>什么是PostCSS呢？
<ul>
<li>PostCSS是一个通过JavaScript来转换样式的工具；</li>
<li>这个工具可以帮助我们进行一些CSS的转换和适配，比如自动添加浏览器前缀、css样式的重置； p但是实现这些功能，我们需要借助于PostCSS对应的插件；</li>
</ul>
</li>
<li>如何使用PostCSS呢？主要就是两个步骤：
<ul>
<li>第一步：查找PostCSS在构建工具中的扩展，比如webpack中的postcss-loader；</li>
<li>第二步：选择可以添加你需要的PostCSS相关的插件；</li>
</ul>
</li>
</ul>
<h4> 命令行使用postcss</h4>
<ul>
<li>安装一下它们：postcss、postcss-cli</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>我们编写一个需要添加前缀的css：
<ul>
<li><a href="https://autoprefixer.github.io/" target="_blank" rel="noopener noreferrer">Autoprefixer CSS online</a></li>
<li>我们可以在上面的网站中查询一些添加css属性的样式；</li>
<li>在Webpack中，PostCSS通常用于对CSS文件进行预处理和后处理。您可以使用PostCSS来编写现代CSS语法，然后使用各种插件对其进行处理，例如自动添加CSS前缀、压缩CSS等。</li>
</ul>
</li>
</ul>
<h4> 插件autoprefixer</h4>
<ul>
<li>因为我们需要添加前缀，所以要安装autoprefixer：</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>直接使用使用postcss工具，并且制定使用autoprefixer</li>
</ul>
<div class="language-cobol line-numbers-mode" data-ext="cobol"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p>转化的结果如下</p>
</blockquote>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> postcss-loader</h4>
<ul>
<li>
<p>真实开发中我们必然不会直接使用命令行工具来对css进行处理，而是可以借助于构建工具：</p>
<ul>
<li>在webpack中使用postcss就是使用postcss-loader来处理的；</li>
</ul>
</li>
<li>
<p>我们来安装postcss-loader：</p>
</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>因为postcss需要有对应的插件才会起效果，所以我们需要配置它的plugin；</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>我们可以将 postcss 配置分离, 根目录下新建 postcss.config.js</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>这样在 webpack.config 中只需要 添加 <code>postcss-loader</code> 即可</li>
</ul>
<h4> postcss-preset-env</h4>
<blockquote>
<p><code>postcss-preset-env</code> 是一个 PostCSS 插件，它允许您使用最新的 CSS 特性，同时它会根据您的目标环境自动添加必要的回退。</p>
<p>这个插件包含了 autoprefixer（自动添加浏览器前缀），cssnano（压缩 CSS），以及一些其他的 PostCSS 插件。这意味着您可以在 CSS 中使用最新的特性，例如 CSS Grid，CSS Variables，等等，而不需要担心兼容性问题。</p>
<p>在您的 <code>postcss.config.js</code> 文件中，您已经将 <code>postcss-preset-env</code> 添加为一个插件，这意味着当您运行 PostCSS 时，它将使用 <code>postcss-preset-env</code> 来处理您的 CSS 文件。</p>
</blockquote>
<ul>
<li>
<p>事实上，在配置postcss-loader时，我们配置插件并不需要使用autoprefixer。</p>
</li>
<li>
<p>我们可以使用另外一个插件：postcss-preset-env</p>
<ul>
<li>postcss-preset-env也是一个postcss的插件；</li>
<li>它可以帮助我们将一些现代的CSS特性，转成大多数浏览器认识的CSS，并且会根据目标浏览器或者运行时环境 添加所需的polyfill；</li>
<li>也包括会自动帮助我们添加 autoprefixer（所以相当于已经内置了 autoprefixer）；</li>
</ul>
</li>
<li>
<p>首先，我们需要安装 postcss-preset-env：</p>
</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>之后，我们直接修改掉之前的 autoprefixer 即可;</li>
</ul>
<h3> file-loader</h3>
<ul>
<li>
<p>要处理jpg、png等格式的图片，我们也需要有对应的loader：file-loader</p>
<ul>
<li>file-loader的作用就是帮助我们处理import/require()方式引入的一个文件资源，并且会将它放到我们输出的文件夹中；</li>
<li>当然我们待会儿可以学习如何修改它的名字和所在文件夹；</li>
</ul>
</li>
<li>
<p>安装file-loader：</p>
</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>配置处理图片的Rule：</li>
</ul>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> url-loader</h3>
<ul>
<li>
<p>url-loader和file-loader的工作方式是相似的，但是可以将较小的文件，转成base64的URI。</p>
</li>
<li>
<p>安装url-loader：</p>
</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>显示结果是一样的，并且图片可以正常显示；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311112113242.png" alt="image-20231111211324041" tabindex="0" loading="lazy"><figcaption>image-20231111211324041</figcaption></figure>
<ul>
<li>但是在dist文件夹中，我们会看不到图片文件：
<ul>
<li>这是因为我的两张图片的大小分别是38kb和295kb；</li>
<li>默认情况下url-loader会将所有的图片文件转成base64编码</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> url-loader的limit</h4>
<ul>
<li>但是开发中我们往往是小的图片需要转换，但是大的图片直接使用图片即可
<ul>
<li>这是因为小的图片转换base64之后可以和页面一起被请求，减少不必要的请求过程；</li>
<li>而大的图片也进行转换，反而会影响页面的请求速度；</li>
</ul>
</li>
<li>那么，我们如何可以限制哪些大小的图片转换和不转换呢？
<ul>
<li>url-loader有一个options属性limit，可以用于设置转换的限制；</li>
<li>下面的代码38kb的图片会进行base64编码，而295kb的不会；</li>
</ul>
</li>
</ul>
<h3> 字体文件加载</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 文件命名规则</h2>
<ul>
<li>有时候我们处理后的文件名称按照一定的规则进行显示：
<ul>
<li>比如保留原来的文件名、扩展名，同时为了防止重复，包含一个hash值等；</li>
</ul>
</li>
<li>这个时候我们可以使用PlaceHolders来完成，webpack给我们提供了大量的PlaceHolders来显示不同的内容：
<ul>
<li>https://webpack.js.org/loaders/file-loader/#placeholders</li>
</ul>
</li>
<li>我们这里介绍几个最常用的placeholder：
<ul>
<li>[ext]： 处理文件的扩展名；</li>
<li>[name]：处理文件的名称；</li>
<li>[hash]：文件的内容，使用MD4的散列函数处理，生成的一个128位的hash值（32个十六进制）；</li>
<li>[contentHash]：在file-loader中和[hash]结果是一致的（在webpack的一些其他地方不一样，后面会讲到）；</li>
<li>[<code>hash:&lt;length&gt;</code>]：截图hash的长度，默认32个字符太长了；</li>
<li>[path]：文件相对于webpack配置文件的路径；</li>
</ul>
</li>
</ul>
<h3> 设置文件名称</h3>
<ul>
<li>那么我们可以按照如下的格式编写：</li>
<li>这个也是vue的写法；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311061505056.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h3> 设置文件的存放路径</h3>
<ul>
<li>刚才通过 img/ 已经设置了文件夹，这个也是vue、react脚手架中常见的设置方式
<ul>
<li>其实按照这种设置方式就可以了；</li>
<li>当然我们也可以通过outputPath来设置输出的文件夹；</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311061506379.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h2> asset module type</h2>
<ul>
<li>我们当前使用的webpack版本是webpack5：
<ul>
<li>在webpack5之前，加载这些资源我们需要使用一些loader，比如raw-loader 、url-loader、file-loader；</li>
<li>在webpack5开始，我们可以直接使用资源模块类型（asset module type），来替代上面的这些loader；</li>
</ul>
</li>
<li>资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：
<ul>
<li>asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现；</li>
<li>asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现；</li>
<li>asset/source 导出资源的源代码。之前通过使用 raw-loader 实现；</li>
<li>asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现；</li>
</ul>
</li>
</ul>
<h3> asset module type的使用</h3>
<ul>
<li>比如加载图片，我们可以使用下面的方式：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Plugin</h2>
<ul>
<li>Loader是用于特定的模块类型进行转换；</li>
<li>Plugin可以用于执行更加广泛的任务，比如打包优化、资源管理、环境变量注入等；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311121514761.png" alt="image-20231112151429444" tabindex="0" loading="lazy"><figcaption>image-20231112151429444</figcaption></figure>
<h3> CleanWebpackPlugin</h3>
<ul>
<li>每次修改了一些配置，重新打包时，都需要手动删除dist文件夹：</li>
<li>我们可以借助于一个插件来帮助我们完成，这个插件就是CleanWebpackPlugin；</li>
<li>首先，我们先安装这个插件：</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>之后在插件中配置：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> HtmlWebpackPlugin</h3>
<ul>
<li>
<p>我们的HTML文件是编写在根目录下的，而最终打包的dist文件夹中是没有index.html文件的。</p>
</li>
<li>
<p>在进行项目部署的时，必然也是需要有对应的入口文件index.html；</p>
</li>
<li>
<p>所以我们也需要对index.html进行打包处理；</p>
</li>
<li>
<p>对HTML进行打包处理我们可以使用另外一个插件：HtmlWebpackPlugin；</p>
</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 自定义HTML模板</h4>
<ul>
<li>
<p>如果我们想在自己的模块中加入一些比较特别的内容：</p>
<ul>
<li>比如添加一个noscript标签，在用户的JavaScript被关闭时，给予响应的提示；</li>
<li>比如在开发vue或者react项目时，我们需要一个可以挂载后续组件的根标签</li>
</ul>
</li>
<li>
<p>这个我们需要一个属于自己的index.html模块：</p>
</li>
</ul>
<blockquote>
<p>public/index.html</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>上面的代码中，会有一些类似这样的语法&lt;% 变量 %&gt;，这个是EJS模块填充数据的方式。
<ul>
<li>在配置 HtmlWebpackPlugin 时，我们可以添加如下配置：
<ul>
<li>template：指定我们要使用的模块所在的路径；</li>
<li>title：在进行 htmlWebpackPlugin.options.title 读取时，就会读到该信息；</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> DefinePlugin</h3>
<blockquote>
<p>https://github.com/jantimon/html-webpack-plugin</p>
</blockquote>
<ul>
<li>因为在模板中使用了 <code>BASE_URL</code>, 但是我们并没有设置过这个常量值，所以会出现没有定义的错误 - <code>BASE_URL is not defined</code></li>
<li>这个时候我们可以使用DefinePlugin插件</li>
<li>DefinePlugin允许在编译时创建配置的全局常量，是一个webpack内置的插件（不需要单独安装）：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> CopyWebpackPlugin</h3>
<ul>
<li>
<p><code>CopyWebpackPlugin</code> 是一个用于 webpack 的插件，它的主要功能是将单个文件或整个目录复制到构建目录。</p>
<p>这个插件在以下情况下非常有用：</p>
<ol>
<li>当你有一些静态资源（例如图片、字体或公共库）需要包含在你的构建中，但是这些资源并不需要通过 webpack 处理时。</li>
<li>当你需要将一些文件复制到构建目录，以便在部署应用程序时使用</li>
</ol>
</li>
<li>
<p>安装CopyWebpackPlugin插件：</p>
</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>接下来配置CopyWebpackPlugin即可：
<ul>
<li>复制的规则在patterns中设置；</li>
<li>from：设置从哪一个源中开始复制；</li>
<li>to：复制到的位置，可以省略，会默认复制到打包的目录下；</li>
<li>globOptions：设置一些额外的选项，其中可以编写需要忽略的文件：
<ul>
<li>.DS_Store：mac目录下回自动生成的一个文件；</li>
<li>index.html：也不需要复制，因为我们已经通过HtmlWebpackPlugin完成了index.html的生成；</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Mode配置列表</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202311021029845.png" type="image/png"/>
    </item>
    <item>
      <title>认识组件化开发</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/components/%E8%AE%A4%E8%AF%86%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/components/%E8%AE%A4%E8%AF%86%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">认识组件化开发</source>
      <description>认识组件化开发 人面对复杂问题的处理方式： 任何一个人处理信息的逻辑能力都是有限的 所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。 但是，我们人有一种天生的能力，就是将问题进行拆解。 如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，你会发现大的问题也会迎刃而解。 组件化也是类似的思想： 如果我们将一个页面中所有的处理逻辑 全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展； 但如果，我们讲一个页面拆分成一个个 小的功能块，每个功能块完成属于自己 这部分独立的功能，那么之后整个页面 的管理和维护就变得非常容易了； 如果我们将一个个功能块拆分后，就可 以像搭建积木一下来搭建我们的项目； 现在可以说整个的大前端开发都是组件化的天下，无论从三大框架（Vue、React、Angular），还是跨平台方案 的Flutter，甚至是移动端都在转向组件化开发，包括小程序的开发也是采用组件化开发的思想 所以，学习组件化最重要的是它的思想，每个框架或者平台可能实现方法不同，但是思想都是一样的。 我们需要通过组件化的思想来思考整个应用程序： 我们将一个完整的页面分成很多个组件； 每个组件都用于实现页面的一个功能块； 而每一个组件又可以进行细分； 而组件本身又可以在多个地方进行复用；</description>
      <pubDate>Tue, 31 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 认识组件化开发</h2>
<ul>
<li>人面对复杂问题的处理方式：
<ul>
<li>任何一个人处理信息的逻辑能力都是有限的</li>
<li>所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。</li>
<li>但是，我们人有一种天生的能力，就是将问题进行拆解。</li>
<li>如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，你会发现大的问题也会迎刃而解。</li>
</ul>
</li>
<li>组件化也是类似的思想：
<ul>
<li>如果我们将一个页面中所有的处理逻辑 全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展；</li>
<li>但如果，我们讲一个页面拆分成一个个 小的功能块，每个功能块完成属于自己 这部分独立的功能，那么之后整个页面 的管理和维护就变得非常容易了；</li>
<li>如果我们将一个个功能块拆分后，就可 以像搭建积木一下来搭建我们的项目；</li>
</ul>
</li>
<li>现在可以说整个的大前端开发都是组件化的天下，无论从三大框架（Vue、React、Angular），还是跨平台方案 的Flutter，甚至是移动端都在转向组件化开发，包括小程序的开发也是采用组件化开发的思想</li>
<li>所以，学习组件化最重要的是它的思想，每个框架或者平台可能实现方法不同，但是思想都是一样的。</li>
<li>我们需要通过组件化的思想来思考整个应用程序：
<ul>
<li>我们将一个完整的页面分成很多个组件；</li>
<li>每个组件都用于实现页面的一个功能块；</li>
<li>而每一个组件又可以进行细分；</li>
<li>而组件本身又可以在多个地方进行复用；</li>
</ul>
</li>
</ul>
<h2> Vue的组件化</h2>
<ul>
<li>vue 项目起始文件 <code>createApp</code> 函数传入了一个对象App，这个对象其实本质上就是一个组件，也是我们应用程序的根 组件；</li>
<li>组件化提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用；</li>
<li>任何的应用都会被抽象成一颗组件树；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310312042389.png" alt="image-20231031204213497" tabindex="0" loading="lazy"><figcaption>image-20231031204213497</figcaption></figure>
<h2> 组件名称</h2>
<ul>
<li>在通过 <code>app.componen</code> t注册一个组件的时候，第一个参数是组件的名称，定义组件名的方式有两种：</li>
<li>方式一：使用 kebab-case（短横线分割符）
<ul>
<li>当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case， 例如 <code>&lt;my-component-name&gt;</code>;</li>
</ul>
</li>
<li>方式二：使用 PascalCase（驼峰标识符）
<ul>
<li>当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也 就是说  <code>&lt;my-component-name&gt;</code>和 <code>MyComponentName</code>  都是可接受的；</li>
</ul>
</li>
<li>在单文件组件和内联字符串模板中，我们都推荐这样做。但是，PascalCase 的标签名在 DOM 模板中是不可用的，详情参见 <a href="https://cn.vuejs.org/guide/essentials/component-basics.html#in-dom-template-parsing-caveats" target="_blank" rel="noopener noreferrer">DOM 内模板解析注意事项</a>。</li>
<li>为了方便，Vue 支持将模板中使用 kebab-case 的标签解析为使用 PascalCase 注册的组件。这意味着一个以 <code>MyComponent</code> 为名注册的组件，在模板中可以通过 <code>&lt;MyComponent&gt;</code> 或 <code>&lt;my-component&gt;</code> 引用。这让我们能够使用同样的 JavaScript 组件注册代码来配合不同来源的模板。</li>
</ul>
<h2> 注册组件的方式</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/components/registration.html#component-registration</p>
</blockquote>
<ul>
<li>如果我们现在有一部分内容（模板、逻辑等），我们希望将这部分内容抽取到一个独立的组件中去维护，这个时候 如何注册一个组件呢？</li>
<li>我们先从简单的开始谈起，比如下面的模板希望抽离到一个单独的组件：</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>注册组件分成两种：
<ul>
<li>全局组件：在任何其他的组件中都可以使用的组件；</li>
<li>局部组件：只有在注册的组件中才能使用的组件；</li>
</ul>
</li>
</ul>
<h3> 注册全局组件</h3>
<ul>
<li>全局组件需要使用我们全局创建的app来注册组件；</li>
<li>通过component方法传入组件名称、组件对象即可注册一个全局组件了；</li>
<li>之后，我们可以在App组件的template中直接使用这个全局组件：</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>也可以</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 注册局部组件</h3>
<p>全局注册虽然很方便，但有以下几个问题：</p>
<ol>
<li>全局注册，但并没有被使用的组件无法在生产打包时被自动移除 (也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。</li>
<li>全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。</li>
</ol>
<p>相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。</p>
<p>局部注册需要使用 <code>components</code> 选项：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于每个 <code>components</code> 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>请注意：<strong>局部注册的组件在后代组件中并不可用</strong>。在这个例子中，<code>ComponentA</code> 注册后仅在当前组件可用，而在任何的子组件或更深层的子组件中都不可用。</p>
</blockquote>
<ul>
<li>全局组件往往是在应用程序一开始就会全局组件完成，那么就意味着如果某些组件我们并没有用到，也会一起被注 册：
<ul>
<li>比如我们注册了三个全局组件：ComponentA、ComponentB、ComponentC；</li>
<li>在开发中我们只使用了ComponentA、ComponentB，如果ComponentC没有用到但是我们依然在全局进行 了注册，那么就意味着类似于webpack这种打包工具在打包我们的项目时，我们依然会对其进行打包；</li>
<li>这样最终打包出的JavaScript包就会有关于ComponentC的内容，用户在下载对应的JavaScript时也会增加包 的大小；</li>
</ul>
</li>
<li>所以在开发中我们通常使用组件的时候采用的都是局部注册：
<ul>
<li>局部注册是在我们需要使用到的组件中，通过components属性选项来进行注册；</li>
<li>比如之前的App组件中，我们有data、computed、methods等选项了，事实上还可以有一个components选项；</li>
<li>该components选项对应的是一个对象，对象中的键值对是 组件的名称: 组件对象；</li>
</ul>
</li>
</ul>
<h2> Vue的开发模式</h2>
<ul>
<li>目前我们使用vue的过程都是在html文件中，通过template编写自己的模板、脚本逻辑、样式等。</li>
<li>但是随着项目越来越复杂，我们会采用组件化的方式来进行开发：
<ul>
<li>这就意味着每个组件都会有自己的模板、脚本逻辑、样式等；</li>
<li>当然我们依然可以把它们抽离到单独的js、css文件中，但是它们还是会分离开来；</li>
<li>也包括我们的script是在一个全局的作用域下，很容易出现命名冲突的问题；</li>
<li>并且我们的代码为了适配一些浏览器，必须使用ES5的语法；</li>
<li>在我们编写代码完成之后，依然需要通过工具对代码进行构建、代码；</li>
</ul>
</li>
<li>所以在真实开发中，我们可以通过一个后缀名为 .vue 的single-file components (单文件组件) 来解决，并且可以使用 webpack 或者 vite 或者 rollup 等构建工具来对其进行处理。</li>
</ul>
<blockquote>
<p>比如: 我们可以单独抽离组件 componentA</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>在这个组件中我们可以获得非常多的特性：</p>
<ul>
<li>代码的高亮；</li>
<li>ES6、CommonJS的模块化能力；</li>
<li>组件作用域的CSS；</li>
<li>可以使用预处理器来构建更加丰富的组件，比如TypeScript、Babel、Less、Sass等；</li>
</ul>
</blockquote>
<h2> 如何支持SFC</h2>
<ul>
<li>如果我们想要使用这一 componentA.vue 文件，比较常见的是两种方式：
<ul>
<li>方式一：使用Vue CLI来创建项目，项目会默认帮助我们配置好所有的配置选项，可以在其中直接使用.vue文件；</li>
<li>方式二：自己使用webpack或rollup或 vite 这类打包工具，对其进行打包处理；</li>
</ul>
</li>
</ul>
<h2> 组件实例</h2>
<h3> <code>$refs</code></h3>
<blockquote>
<p>https://cn.vuejs.org/api/component-instance.html#refs</p>
</blockquote>
<ul>
<li>某些情况下，我们在组件中想要直接获取到元素对象或者子组件实例：
<ul>
<li>在Vue开发中我们是不推荐进行DOM操作的；</li>
<li>这个时候，我们可以给元素或者组件绑定一个ref的attribute属性；</li>
<li>在Vue 3中，$refs属性用于访问父组件中的子组件或DOM元素。它允许您以编程方式直接引用和操作这些组件或元素。</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，我们通过使用ref属性给子组件命名为<code>childRef</code>，然后可以通过<code>this.$refs.childRef</code>来访问和操作子组件。在点击"Log Child Ref"按钮时，会将子组件实例打印到控制台。</p>
<p>###<code> $parent, $root</code></p>
<blockquote>
<p>https://cn.vuejs.org/api/component-instance.html#parent</p>
</blockquote>
<p>在Vue中，<code>$parent</code>和<code>$root</code>都是用于访问组件层级关系的特殊属性。</p>
<ul>
<li><code>$parent</code>属性用于访问当前组件的父组件实例。通过<code>this.$parent</code>可以访问父组件的属性和方法。</li>
<li><code>$root</code>属性用于访问根组件实例。根组件是Vue应用的最顶层组件，通过<code>this.$root</code>可以访问根组件的属性和方法。</li>
</ul>
<p>这些属性在处理组件之间的通信或访问全局状态时非常有用。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，父组件中通过使用<code>$parent</code>属性访问了父组件实例，使用​<code>$root</code>属性访问了根组件实例，并将它们打印到控制台。</p>
<h2> 组件的 v-model</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/components/v-model.html#component-v-model</p>
</blockquote>
<p><code>v-model</code> 可以在组件上使用以实现双向绑定。</p>
<p>首先让我们回忆一下 <code>v-model</code> 在原生元素上的用法：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在代码背后，模板编译器会对 <code>v-model</code> 进行更冗长的等价展开。因此上面的代码其实等价于下面这段：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而当使用在一个组件上时，<code>v-model</code> 会被展开为如下的形式：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要让这个例子实际工作起来，<code>&lt;CustomInput&gt;</code> 组件内部需要做两件事：</p>
<ol>
<li>将内部原生 <code>&lt;input&gt;</code> 元素的 <code>value</code> attribute 绑定到 <code>modelValue</code> prop</li>
<li>当原生的 <code>input</code> 事件触发时，触发一个携带了新值的 <code>update:modelValue</code> 自定义事件</li>
</ol>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在 <code>v-model</code> 可以在这个组件上正常工作了：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>另一种在组件内实现 <code>v-model</code> 的方式是使用一个可写的，同时具有 getter 和 setter 的 <code>computed</code> 属性。<code>get</code> 方法需返回 <code>modelValue</code> prop，而 <code>set</code> 方法需触发相应的事件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 多个 <code>v-model</code> 绑定</h3>
<p>利用刚才在 <a href="https://cn.vuejs.org/guide/components/v-model.html#v-model-arguments" target="_blank" rel="noopener noreferrer"><code>v-model</code> 参数</a>小节中学到的指定参数与事件名的技巧，我们可以在单个组件实例上创建多个 <code>v-model</code> 双向绑定。</p>
<p>组件上的每一个 <code>v-model</code> 都会同步不同的 prop，而无需额外的选项：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310312042389.png" type="image/png"/>
    </item>
    <item>
      <title>Js 的浅拷贝与深拷贝</title>
      <link>https://brain.sunguoqi.com/web/js/Js%20%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D.html</link>
      <guid>https://brain.sunguoqi.com/web/js/Js%20%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Js 的浅拷贝与深拷贝</source>
      <description>数据类型 在探讨深浅拷贝之前，我们先梳理一下js中的数据类型，js的数据类型分为两类：基本数据类型和引用数据类型 前者是存储在栈内存中，后者是将其地址存在栈内存中，而真实数据存储在堆内存中。 如下图所示，基本类型如number、string、boolean、Null和 undefined 等存储在栈内存中，而引用数据类型如 Array、Object 和函数等则是分别存储数据1的地址、数据2的地址和数据3的地址。</description>
      <pubDate>Mon, 30 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 数据类型</h2>
<ol>
<li>在探讨深浅拷贝之前，我们先梳理一下js中的数据类型，js的数据类型分为两类：基本数据类型和引用数据类型</li>
<li>前者是存储在栈内存中，后者是将其地址存在栈内存中，而真实数据存储在堆内存中。</li>
<li>如下图所示，基本类型如number、string、boolean、Null和 undefined 等存储在栈内存中，而引用数据类型如 Array、Object 和函数等则是分别存储数据1的地址、数据2的地址和数据3的地址。</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202310301908367.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 深浅拷贝</h2>
<blockquote>
<p>js中的基本数据类型：<code>String Number Boolean Null Undefined</code>，在赋值的过程中都是深拷贝。</p>
<p>例如，let a = 10 ; b = a , 修改其中一个变量的值，不会影响到另一个变量的值。</p>
</blockquote>
<h3> 概念</h3>
<ol>
<li>浅拷贝：会在栈中开辟另一块空间，并将被拷贝对象的栈内存数据完全拷贝到该块空间中，即基本数据类型的值会被完全拷贝，而引用类型的值则是拷贝了“指向堆内存的地址”。因此，当修改其中一个变量的值时，会影响到另一个变量的值。</li>
<li>深拷贝：不仅会在栈中开辟另一块空间，若被拷贝对象中有引用类型，则还会在堆内存中开辟另一块空间存储引用类型的真实数据。因此，当修改其中一个变量的值时，不会影响到另一个变量的值。</li>
</ol>
<blockquote>
<p>两者示意图如下：</p>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202310301911328.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址</p>
<p>深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址</p>
</blockquote>
<h2> Js 中的深浅拷贝</h2>
<h3> 浅拷贝</h3>
<blockquote>
<p>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p>
<p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址</p>
</blockquote>
<h4> 手写递归</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 展开语法</h4>
<blockquote>
<p>展开语法(spread syntax)允许一个表达式在期望多个参数(用于函数调用)或多个元素(用于数组字面量)或多个变量(用于解构赋值)的位置扩展。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Object.assign()</h4>
<blockquote>
<p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> slice()</h4>
<blockquote>
<p>slice() 方法可从已有的数组中返回选定的元素。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> concat()</h4>
<blockquote>
<p>concat() 方法用于连接两个或多个数组。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310301917518.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 深拷贝</h3>
<blockquote>
<p>深拷贝开辟一个新的栈，两个对象属性完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p>
</blockquote>
<h4> 手写递归</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Object.entries(obj) 遍历对象</h4>
<blockquote>
<p>Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组</p>
<p>比如：Object.entries({ foo: 'bar', baz: 42 }); // [ ['foo', 'bar'], ['baz', 42] ]</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> JSON.parse(JSON.stringify(待拷贝对象) -&gt; 常用</h4>
<blockquote>
<p>JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串。</p>
<p>比如: JSON.stringify({ x: 5, y: 6 }); // "{"x":5,"y":6}" -&gt; string</p>
<p>JSON.parse() 方法用于将一个 JSON 字符串转换为对象。</p>
<p>比如: JSON.parse('{"name":"cxk","age":18}'); // {name: "cxk", age: 18} -&gt; object</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 其他方法</h4>
<ul>
<li>_.cloneDeep()</li>
<li>jQuery.extend()</li>
<li>手写循环递归</li>
</ul>
<h2> Vue 中的深拷贝实现</h2>
<blockquote>
<p>引入loadsh,提供 cloneDeep 实现深拷贝</p>
</blockquote>
<ol>
<li>安装loadsh    npm i --save lodash</li>
<li>引入loadsh    import _ from 'lodash'</li>
<li>直接调用 loadsh 库的方法 <code>const newObj = _.cloneDeep(this.obj)</code></li>
</ol>
<blockquote>
<p>_clone 实现浅拷贝</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310301908367.png" type="image/png"/>
    </item>
    <item>
      <title>Vue3 基本指令</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/Vue3%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/Vue3%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Vue3 基本指令</source>
      <description>VSCode 代码片段 我们在前面练习Vue的过程中，有些代码片段是需要经常写的，我们再VSCode中我们可以生成一个代码片段，方便我们快速生成。 VSCode中的代码片段有固定的格式，所以我们一般会借助于一个在线工具来完成。 具体的步骤如下： 第一步，复制自己需要生成代码片段的代码； 第二步，https://snippet-generator.app/在该网站中生成代码片段； 第三步，在VSCode中配置代码片段； 直接 Tab trigger 即可自动填充</description>
      <pubDate>Thu, 07 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> VSCode 代码片段</h2>
<ul>
<li>我们在前面练习Vue的过程中，有些代码片段是需要经常写的，我们再VSCode中我们可以生成一个代码片段，方便我们快速生成。</li>
<li>VSCode中的代码片段有固定的格式，所以我们一般会借助于一个在线工具来完成。</li>
<li>具体的步骤如下：
<ul>
<li>第一步，复制自己需要生成代码片段的代码；</li>
<li>第二步，https://snippet-generator.app/在该网站中生成代码片段；</li>
<li>第三步，在VSCode中配置代码片段；</li>
</ul>
</li>
<li>直接 Tab trigger 即可自动填充</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310162330091.png" alt="image-20231016233051010" tabindex="0" loading="lazy"><figcaption>image-20231016233051010</figcaption></figure>
<h2> 模板语法</h2>
<ul>
<li>React的开发模式[了解]
<ul>
<li>React使用的jsx,所以对应的代码都是编写的类似于js的一种语法</li>
<li>之后通过Babe将js编译成 React. create Element函数调用</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>vue也支持 jsx 的开发模式:
<ul>
<li>但是大多数情况下,使用基于HTML的模板语法</li>
<li>在模板中,允许开发者以声明式的方式将 DOM 和底层组件实例的数据绑定在-起;口在底层的实现中,vue将模板编译成虚拟DOM渲染函数</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Mustache 语法 双大括号语法</h2>
<ul>
<li>如果我们希望把数据显示到模板（template）中，使用最多的语法是 “Mustache”语法 (双大括号) 的文本插值。
<ul>
<li>并且我们前端提到过，data返回的对象是有添加到Vue的响应式系统中；</li>
<li>当data中的数据发生改变时，对应的内容也会发生更新。</li>
<li>当然，Mustache中不仅仅可以是data中的属性，也可以是一个JavaScript的表达式。</li>
</ul>
</li>
<li>mustache的使用
1. 基本使用
2. 表达式
3. 函数
4. 三元运算符</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>以下为错误写法</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 不常用指令</h2>
<h3> v-once指令</h3>
<ul>
<li>
<p>v-once用于指定元素或者组件只渲染一次</p>
<ul>
<li>
<p>当数据发生变化时,元素或者组件以及其所有的子元素将视为静态内容并且跳过;</p>
</li>
<li>
<p>该指令可以用于性能优化;</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p>如果是子节点的化，也只能渲染一次</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<blockquote>
<p>完整代码</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-html</h3>
<ul>
<li>默认情况下，如果我们展示的内容本身是 html 的，那么vue并不会对其进行特殊的解析。
<ul>
<li>如果我们希望这个内容被Vue可以解析出来，那么可以使用 v-html 来展示</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310180836759.png" alt="image-20231018083558572" tabindex="0" loading="lazy"><figcaption>image-20231018083558572</figcaption></figure>
<h3> v-text</h3>
<ul>
<li>用于更新元素的 textContent</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-pre</h3>
<ul>
<li>v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签：
<ul>
<li>跳过不需要编译的节点，加快编译的速度</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-cloak</h3>
<ul>
<li>用于隐藏尚未完成编译的 DOM 模板。
<ul>
<li><strong>无需传入</strong></li>
<li><strong>详细信息</strong></li>
</ul>
</li>
<li><strong>该指令只在没有构建步骤的环境下需要使用。</strong>
<ul>
<li>当使用直接在 DOM 中书写的模板时，可能会出现一种叫做“未编译模板闪现”的情况：用户可能先看到的是还没编译完成的双大括号标签，直到挂载的组件将它们替换为实际渲染的内容。</li>
<li><code>v-cloak</code> 会保留在所绑定的元素上，直到相关组件实例被挂载后才移除。配合像 <code>[v-cloak] { display: none }</code> 这样的 CSS 规则，它可以在组件编译完毕前隐藏原始模板。</li>
</ul>
</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>直到编译完成前，<code>&lt;div&gt;</code> 将不可见。</p>
</blockquote>
<h2> v-bind</h2>
<p>动态的绑定一个或多个 attribute，也可以是组件的 prop。</p>
<ul>
<li>
<p><strong>缩写：</strong><code>:</code> 或者 <code>.</code> (当使用 <code>.prop</code> 修饰符)</p>
</li>
<li>
<p><strong>期望：</strong><code>any (带参数) | Object (不带参数)</code></p>
</li>
<li>
<p><strong>参数：</strong><code>attrOrProp (可选的)</code></p>
</li>
<li>
<p><strong>修饰符</strong></p>
<ul>
<li><code>.camel</code> - 将短横线命名的 attribute 转变为驼峰式命名。</li>
<li><code>.prop</code> - 强制绑定为 DOM property。<code>3.2+</code></li>
<li><code>.attr</code> - 强制绑定为 DOM attribute。<code>3.2+</code></li>
</ul>
</li>
<li>
<p><strong>用途</strong></p>
<p>当用于绑定 <code>class</code> 或 <code>style</code> attribute，<code>v-bind</code> 支持额外的值类型如数组或对象。详见下方的指南链接。</p>
<p>在处理绑定时，Vue 默认会利用 <code>in</code> 操作符来检查该元素上是否定义了和绑定的 key 同名的 DOM property。如果存在同名的 property，则 Vue 会将它作为 DOM property 赋值，而不是作为 attribute 设置。这个行为在大多数情况都符合期望的绑定值类型，但是你也可以显式用 <code>.prop</code> 和 <code>.attr</code> 修饰符来强制绑定方式。有时这是必要的，特别是在和<a href="https://cn.vuejs.org/guide/extras/web-components.html#passing-dom-properties" target="_blank" rel="noopener noreferrer">自定义元素</a>打交道时。</p>
<p>当用于组件 props 绑定时，所绑定的 props 必须在子组件中已被正确声明。</p>
<p>当不带参数使用时，可以用于绑定一个包含了多个 attribute 名称-绑定值对的对象。</p>
</li>
<li>
<p><strong>用法</strong></p>
<ul>
<li>动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</li>
</ul>
</li>
</ul>
<blockquote>
<p>小知识: vue3 是允许template中有多个根元素</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 基本使用</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 绑定 class</h3>
<ul>
<li>在开发中,有时候我们的元素 class也是动态的,比如
<ul>
<li>当数据为某个状态时,字体显示红色。</li>
<li>当数据另一个状态时,字体显示黑色</li>
</ul>
</li>
<li>绑定class有两种方式：
<ul>
<li>对象语法</li>
<li>数组语法</li>
</ul>
</li>
</ul>
<h4> 对象语法</h4>
<ul>
<li>对象语法：我们可以传给 :class (v-bind:class 的简写) 一个对象，以动态地切换 class</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 数组语法</h4>
<ul>
<li>绑定class – 数组语法
<ul>
<li>数组语法：我们可以把一个数组传给 :class，以应用一个 class 列表</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 绑定 style</h3>
<ul>
<li>我们可以利用 <code>v-bind:style</code> 来绑定一些CSS内联样式
<ul>
<li>这次因为某些样式我们需要根据数据动态来决定</li>
<li>比如某段文字的颜色，大小等等</li>
</ul>
</li>
<li>CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名</li>
<li>绑定class有两种方式
<ul>
<li>对象语法</li>
<li>数组语法</li>
</ul>
</li>
</ul>
<blockquote>
<p>CSS property 名短横线分隔 (kebab-case，记得用引号括起来)</p>
</blockquote>
<h4> 对象语法</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 数组语法</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 动态绑定属性</h3>
<ul>
<li>在某些情况下，我们属性的名称可能也不是固定的
<ul>
<li>前端我们无论绑定src、href、class、style，属性名称都是固定的</li>
<li>如果属性名称不是固定的，我们可以使用 :[属性名]=“值” 的格式来定义</li>
<li>这种绑定的方式，我们称之为 <code>动态绑定属性</code>；如下:</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 属性直接绑定一个对象</h3>
<ul>
<li>如果我们希望将一个对象的所有属性，绑定到元素上的所有属性，应该怎么做呢？
<ul>
<li>非常简单，我们可以直接使用 v-bind 绑定一个 对象</li>
</ul>
</li>
<li>案例：info对象会被拆解成div的各个属性</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> v-on</h2>
<ul>
<li>
<p>v-on绑定事件</p>
<ul>
<li>前面我们绑定了元素的内容和属性，在前端开发中另外一个非常重要的特性就是交互。</li>
<li>在前端开发中，我们需要经常和用户进行各种各样的交互
<ul>
<li>这个时候，我们就必须监听用户发生的事件，比如点击、拖拽、键盘事件等等</li>
<li>在Vue中如何监听事件呢？使用v-on指令。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>v-on的用法</p>
<ul>
<li>缩写：@</li>
<li>预期：Function | Inline Statement | Object</li>
<li>参数：event p 修饰符：
<ul>
<li>.stop - 调用 event.stopPropagation()。</li>
<li>.prevent - 调用 event.preventDefault()。</li>
<li>.capture - 添加事件侦听器时使用 capture 模式。</li>
<li>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>
<li>.{keyAlias} - 仅当事件是从特定键触发时才触发回调。</li>
<li>.once - 只触发一次回调。</li>
<li>.left - 只当点击鼠标左键时触发。</li>
<li>.right - 只当点击鼠标右键时触发。</li>
<li>.middle - 只当点击鼠标中键时触发。</li>
<li>.passive - { passive: true } 模式添加侦听器</li>
</ul>
</li>
</ul>
<ul>
<li>用法：绑定事件监听</li>
</ul>
</li>
</ul>
<blockquote>
<p>event 事件可以参考 https://developer.mozilla.org/en-US/docs/Web/Events</p>
</blockquote>
<h3> 基本使用</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 参数传递</h3>
<ul>
<li>当通过methods中定义方法，以供 <code>@click</code>调用时，需要注意参数问题：</li>
<li>情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。
<ul>
<li>但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去</li>
</ul>
</li>
<li>情况二：如果需要同时传入某个参数，同时需要 <code>event</code> 时，可以通过 <code>$event</code> 传入事件。</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310190046946.png" alt="image-20231019004604619" tabindex="0" loading="lazy"><figcaption>image-20231019004604619</figcaption></figure>
<h3> v-on <strong>的修饰符</strong></h3>
<ul>
<li>v-on支持修饰符，修饰符相当于对事件进行了一些特殊的处理：
<ul>
<li>.stop - 调用 event.stopPropagation()。</li>
<li>.prevent - 调用 event.preventDefault()。</li>
<li>.capture - 添加事件侦听器时使用 capture 模式。</li>
<li>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>
<li>.{keyAlias} - 仅当事件是从特定键触发时才触发回调。</li>
<li>.once - 只触发一次回调。</li>
<li>.left - 只当点击鼠标左键时触发。</li>
<li>.right - 只当点击鼠标右键时触发。</li>
<li>.middle - 只当点击鼠标中键时触发。</li>
<li>.passive - { passive: true } 模式添加侦听器</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>stopPropagation</code> 是一个事件修饰符，用于阻止事件冒泡。在 Vue.js 中，当一个元素上的事件被触发时，它会先执行该元素上的事件处理函数，然后再冒泡到该元素的父元素，继续执行父元素的事件处理函数。使用 <code>stopPropagation</code> 可以阻止事件继续冒泡到父元素。在给元素绑定事件时，可以使用 <code>@click.stop</code> 来阻止 <code>click</code> 事件冒泡到父元素。</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310190052768.png" alt="image-20231019005251770" tabindex="0" loading="lazy"><figcaption>image-20231019005251770</figcaption></figure>
<h2> 条件渲染</h2>
<ul>
<li>在某些情况下，我们需要根据当前的条件决定某些元素或组件是否渲染，这个时候我们就需要进行条件判断了。
<ul>
<li>Vue提供了下面的指令来进行条件判断：
<ul>
<li>v-if</li>
<li>v-else</li>
<li>v-else-if</li>
<li>v-show</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3> 基本使用</h3>
<ul>
<li>v-if、v-else、v-else-if用于根据条件来渲染某一块的内容：
<ul>
<li>这些内容只有在条件为true时，才会被渲染出来；</li>
<li>这三个指令与JavaScript的条件语句if、else、else if类似；</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> template 和  v-if  结合使用</h3>
<ul>
<li>v-if的渲染原理：
<ul>
<li>v-if是惰性的；</li>
<li>当条件为false时，其判断的内容完全不会被渲染或者会被销毁掉；</li>
<li>当条件为true时，才会真正渲染条件块中的内容;</li>
</ul>
</li>
<li>template元素
<ul>
<li>因为v-if是一个指令，所以必须将其添加到一个元素上：
<ul>
<li>但是如果我们希望切换的是多个元素呢？</li>
<li>此时我们渲染div，但是我们并不希望div这种元素被渲染；</li>
<li>这个时候，我们可以选择使用template；</li>
</ul>
</li>
<li>template元素可以当做不可见的包裹元素，并且在v-if上使用，但是最终template不会被渲染出来：
<ul>
<li>有点类似于小程序中的block</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-show</h3>
<ul>
<li>v-show和v-if的用法看起来是一致的，也是根据一个条件决定是否显示元素或者组件</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-show和v-if的区别</h3>
<ul>
<li>首先，在用法上的区别：
<ul>
<li>v-show是不支持template；</li>
<li>v-show不可以和v-else一起使用；</li>
</ul>
</li>
<li>其次，本质的区别：
<ul>
<li>v-show元素无论是否需要显示到浏览器上，它的DOM实际都是有渲染的，只是通过CSS的display属性来进行 切换；</li>
<li>v-if当条件为false时，其对应的元素压根不会被渲染到DOM中；</li>
</ul>
</li>
<li>开发中如何进行选择呢？
<ul>
<li>如果我们的元素需要在显示和隐藏之间频繁的切换，那么使用v-show；</li>
<li>如果不会频繁的发生切换，那么使用v-if；</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310192228448.png" alt="image-20231019222841008" tabindex="0" loading="lazy"><figcaption>image-20231019222841008</figcaption></figure>
<h2> 列表渲染</h2>
<ul>
<li>在真实开发中，我们往往会从服务器拿到一组数据，并且需要对其进行渲染。
<ul>
<li>这个时候我们可以使用v-for来完成；</li>
<li>v-for类似于JavaScript的for循环，可以用于遍历一组数据；</li>
</ul>
</li>
</ul>
<h3> 基本使用</h3>
<ul>
<li>
<p>n v-for的基本格式是 "item in 数组"：</p>
<ul>
<li>数组通常是来自data或者prop，也可以是其他方式；</li>
<li>item是我们给每项元素起的一个别名，这个别名可以自定来定义；</li>
</ul>
</li>
<li>
<p>我们知道，在遍历一个数组的时候会经常需要拿到数组的索引：</p>
<ul>
<li>如果我们需要索引，可以使用格式： "(item, index) in 数组"；</li>
<li>注意上面的顺序：数组元素项item是在前面的，索引项index是在后面的；</li>
</ul>
</li>
<li>
<p>v-for支持的类型</p>
<ul>
<li>v-for也支持遍历对象，并且支持有一二三个参数：
<ul>
<li>一个参数： "value in object";</li>
<li>二个参数： "(value, key) in object";</li>
<li>三个参数： "(value, key, index) in object";</li>
</ul>
</li>
<li>v-for同时也支持数字的遍历：
<ul>
<li>每一个item都是一个数字；</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> template元素使用</h3>
<ul>
<li>类似于v-if，你可以使用 template 元素来循环渲染一段包含多个元素的内容：
<ul>
<li>我们使用template来对多个元素进行包裹，而不是使用div来完成；</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 数组更新检测</h3>
<ul>
<li>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
</li>
<li>替换数组的方法
<ul>
<li>上面的方法会直接修改原来的数组，但是某些方法不会替换原来的数组，而是会生成新的数组，比如 filter()、 concat() 和 slice()。</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-for 中的 key 是什么作用？</h3>
<blockquote>
<p>https://cn.vuejs.org/api/built-in-special-attributes.html#key</p>
</blockquote>
<ul>
<li>
<p>在使用v-for进行列表渲染时，我们通常会给元素或者组件绑定一个key属性。</p>
</li>
<li>
<p>这个key属性有什么作用呢？我们先来看一下官方的解释：</p>
<ul>
<li>
<p>key属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes；</p>
</li>
<li>
<p>如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法；</p>
</li>
<li>
<p>而使用key时，它会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素；</p>
</li>
</ul>
</li>
<li>
<p>官方的解释对于初学者来说并不好理解，比如下面的问题：</p>
<ul>
<li>什么是新旧nodes，什么是VNode？</li>
<li>没有key的时候，如何尝试修改和复用的？</li>
<li>有key的时候，如何基于key重新排列的？</li>
</ul>
</li>
</ul>
<h4> 认识 VNode</h4>
<ul>
<li>我们先来解释一下VNode的概念：
<ul>
<li>因为目前我们还没有比较完整的学习组件的概念，所以目前我们先理解HTML元素创建出来的VNode；</li>
<li>VNode的全称是Virtual Node，也就是虚拟节点；</li>
<li>事实上，无论是组件还是元素，它们最终在Vue中表示出来的都是一个个VNode；</li>
<li>VNode的本质是一个JavaScript的对象；可以用于描述某一个标签/ 元素 的样子</li>
<li>好处: 多平台的渲染, 跨平台(主要好处)</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310201628396.png" alt="image-20231020162812819" tabindex="0" loading="lazy"><figcaption>image-20231020162812819</figcaption></figure>
<h4> 虚拟 DOM</h4>
<ul>
<li>如果我们不只是一个简单的div，而是有一大堆的元素，那么它们应该会形成一个 VNode Tree</li>
<li>虚拟 DOM 与 真实 DOM 不一定一一对应</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310201631261.png" alt="image-20231020163154944" tabindex="0" loading="lazy"><figcaption>image-20231020163154944</figcaption></figure>
<h4> 插入 F 的案例</h4>
<ul>
<li>
<p>我们先来看一个案例：这个案例是当我点击按钮时会在中间插入一个f；</p>
</li>
<li>
<p>我们可以确定的是，这次更新对于ul和button是不需要进行更新，需要更新的是我们 li 的列表：</p>
<ul>
<li>
<p>在Vue中，对于相同父元素的子元素节点并不会重新渲染整个列 表；</p>
</li>
<li>
<p>因为对于列表中 a、b、c、d它们都是没有变化的；</p>
</li>
<li>
<p>在操作真实DOM的时候，我们只需要在中间插入一个 f 的 li 即可；</p>
</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>那么Vue中对于列表的更新究竟是如何操作的呢？
<ul>
<li>Vue事实上会对于有key和没有key会调用两个不同的方法；</li>
</ul>
</li>
</ul>
<h5> Vue源码对于key的判断</h5>
<ul>
<li>有key，那么就使用 patchKeyedChildren方法；</li>
<li>没有key，那么久使用 patchUnkeyedChildren方法；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310201647317.png" alt="image-20231020164733530" tabindex="0" loading="lazy"><figcaption>image-20231020164733530</figcaption></figure>
<blockquote>
<p>diff算法: diff 算法是指生成更新补丁的方式,主要应用于虚拟 DOM 树变化后,更新真实 DOM。所以 diff 算法一定存在这样一个过程:触发更新 → 生成补丁 → 应用补丁。</p>
</blockquote>
<ul>
<li>没有key的操作过程</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310221823690.png" alt="image-20231022182341619" tabindex="0" loading="lazy"><figcaption>image-20231022182341619</figcaption></figure>
<ul>
<li>我们会发现上面的diff算法效率并不高：
<ul>
<li>c和d来说它们事实上并不需要有任何的改动；</li>
<li>但是因为我们的c被f所使用了，所有后续所有的内容都要一次进行改动，并且最后进行新增；</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310221820519.png" alt="image-20231022182012027" tabindex="0" loading="lazy"><figcaption>image-20231022182012027</figcaption></figure>
<ul>
<li>有key的操作过程-diff算法
<ul>
<li>第一步的操作是从头开始进行遍历、比较：
<ul>
<li>a和b是一致的会继续进行比较；</li>
<li>c和f因为key不一致，所以就会break跳出循环</li>
</ul>
</li>
<li>第二步的操作是从尾部开始进行遍历、比较</li>
<li>第三步是如果旧节点遍历完毕，但是依然有新的节点，那么就新增节点：</li>
<li>第四步是如果新的节点遍历完毕，但是依然有旧的节点，那么就移除旧节点：</li>
<li>第五步是最特色的情况，中间还有很多未知的或者乱序的节点：</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310221822567.png" alt="image-20231022182232738" tabindex="0" loading="lazy"><figcaption>image-20231022182232738</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202310221821946.png" alt="image-20231022182140133" tabindex="0" loading="lazy"><figcaption>image-20231022182140133</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202310221822262.png" alt="image-20231022182241976" tabindex="0" loading="lazy"><figcaption>image-20231022182241976</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202310221822079.png" alt="image-20231022182251535" tabindex="0" loading="lazy"><figcaption>image-20231022182251535</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202310221823627.png" alt="image-20231022182300781" tabindex="0" loading="lazy"><figcaption>image-20231022182300781</figcaption></figure>
<h5> 有无key的结论</h5>
<ul>
<li>有无key的结论
<ul>
<li>所以我们可以发现，Vue在进行diff算法的时候，会尽量利用我们的key来进行优化操作：
<ul>
<li>在没有key的时候我们的效率是非常低效的；</li>
<li>在进行插入或者重置顺序的时候，保持相同的key可以让diff算法更加的高效；</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310162330091.png" type="image/png"/>
    </item>
    <item>
      <title>Vue 的Options API</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/Vue3%E7%9A%84Options-API.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/Vue3%E7%9A%84Options-API.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Vue 的Options API</source>
      <description>Computed 认识计算属性 我们知道，在模板中可以直接通过插值语法显示一些data中的数据。 但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示； 比如我们需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示； 在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算； 在模板中放入太多的逻辑会让模板过重和难以维护； 并且如果多个地方都使用到，那么会有大量重复的代码；</description>
      <pubDate>Tue, 31 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Computed</h2>
<h3> 认识计算属性</h3>
<p>我们知道，在模板中可以直接通过插值语法显示一些data中的数据。</p>
<p>但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示；</p>
<ul>
<li>比如我们需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示；</li>
<li>在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算；</li>
<li>在模板中放入太多的逻辑会让模板过重和难以维护；</li>
<li>并且如果多个地方都使用到，那么会有大量重复的代码；</li>
</ul>
<p>我们有没有什么方法可以将逻辑抽离出去呢？</p>
<ul>
<li>可以，其中一种方式就是将逻辑抽取到一个method中，放到methods的options中；</li>
<li>但是，这种做法有一个直观的弊端，就是所有的data使用过程都会变成了一个方法的调用；</li>
<li>另外一种方式就是使用计算属性computed；</li>
</ul>
<p>什么是计算属性呢？</p>
<ul>
<li>https://cn.vuejs.org/api/reactivity-core.html#computed</li>
<li>官方并没有给出直接的概念解释；</li>
<li>而是说：对于任何包含响应式数据的复杂逻辑，你都应该使用<strong>计算属性</strong>；</li>
<li>计算属性将被混入到组件实例中。所有 getter 和 setter 的 <code>this</code> 上下文自动地绑定为组件实例；</li>
</ul>
<h3> 基本使用</h3>
<p>计算属性的用法：</p>
<ul>
<li><strong>选项：</strong> computed</li>
<li><strong>类型：</strong><code>{ [key: string]: Function | { get: Function, set: Function } }</code></li>
</ul>
<p>我们来看三个案例：</p>
<ul>
<li>我们有两个变量：firstName 和 lastName，希望它们拼接之后在界面上显示；</li>
<li>我们有一个分数：score
<ul>
<li>当score大于60的时候，在界面上显示及格；</li>
<li>当score小于60的时候，在界面上显示不及格；</li>
</ul>
</li>
<li>我们有一个变量message，记录一段文字：比如Hello World
<ul>
<li>某些情况下我们是直接显示这段文字；</li>
<li>某些情况下我们需要对这段文字进行反转；</li>
</ul>
</li>
<li>我们可以有三种实现思路：
<ul>
<li>思路一：在模板语法中直接使用表达式；</li>
<li>思路二：使用method对逻辑进行抽取；</li>
<li>思路三：使用计算属性computed；</li>
</ul>
</li>
</ul>
<h4> 在模板语法中直接使用表达式</h4>
<ul>
<li>缺点一：模板中存在大量的复杂逻辑，不便于维护（模板中表达式的初衷是用于简单的计算）；</li>
<li>缺点二：当有多次一样的逻辑时，存在重复的代码；</li>
<li>缺点三：多次使用的时候，很多运算也需要多次执行，没有缓存；</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 使用method对逻辑进行抽取</h4>
<ul>
<li>缺点一：我们事实上先显示的是一个结果，但是都变成了一种方法的调用；</li>
<li>缺点二：多次使用方法的时候，没有缓存，也需要多次计算；</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> computed 实现</h4>
<ul>
<li>注意：计算属性看起来像是一个函数，但是我们在使用的时候不需要加()，这个后面讲setter和getter时会讲到；</li>
<li>我们会发现无论是直观上，还是效果上计算属性都是更好的选择；</li>
<li>并且计算属性是有缓存的；</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 计算属性 vs methods</h3>
<p>在上面的实现思路中，我们会发现计算属性和methods的实现看起来是差别是不大的，而且我们多次提到计算属性有缓存。</p>
<p>接下来我们来看一下同一个计算多次使用，计算属性和methods的差异：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>打印结果如下：</p>
<ul>
<li>我们会发现methods在多次使用时，会调用多次；</li>
<li>而计算属性虽然使用了多次，但是计算的过程只调用了一次；</li>
<li>这是因为计算属性会基于它们的依赖关系进行缓存；</li>
<li>在数据不发生变化时，计算属性是不需要重新计算的；</li>
<li>但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算；如下:</li>
</ul>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>当 score 变化, console 输出如下:</p>
</blockquote>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 计算属性的 setter 和 getter</h3>
<p>计算属性在大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数。</p>
<p>但是，如果我们确实想设置计算属性的值呢？</p>
<ul>
<li>这个时候我们也可以给计算属性设置一个setter的方法；</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>以下为内部判断</p>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202310251728011.jpeg" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>
<h2> 侦听器 watch</h2>
<blockquote>
<p>用于声明在数据更改时调用的侦听回调。<code>watch</code> 选项期望接受一个对象，其中键是需要侦听的响应式组件实例属性 (例如，通过 <code>data</code> 或 <code>computed</code> 声明的属性)——值是相应的回调函数。该回调函数接受被侦听源的新值和旧值。</p>
</blockquote>
<ul>
<li>什么是侦听器？
<ul>
<li>开发中我们在data返回的对象中定义了数据，这个数据通过插值语法等方式绑定到template中;</li>
<li>当数据变化时，template会自动进行更新来显示最新的数据;</li>
<li>但是在某些情况下，我们希望在代码逻辑中监听某个数据的变化，这个时候就需要用侦听器watch来完成了;</li>
</ul>
</li>
<li>用法如下：
<ul>
<li>选项：watch</li>
<li>类型: <code>{[key: string]: string | Function | Object | Array}</code></li>
</ul>
</li>
</ul>
<h3> 简单案例</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 配置选项</h3>
<ul>
<li><code>watch</code> 默认是浅层的：被侦听的属性，仅在被赋新值时，才会触发回调函数——而嵌套属性的变化不会触发。如果想侦听所有嵌套的变更，你需要深层侦听器：</li>
<li>以下为不使用深度监听, 当 info.name 在方法中被赋值改变时, 页面会改变, 但是watch不会侦听到, 理由如上</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>将 watch 中更改如下, 不管多深都会侦听到</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>immediate: true</code> 立即执行,  这个时候无论后面数据是否有变化，侦听的函数都会有限执行一次；即当刷新页面时会立刻执行一次, 回调函数的初次执行就发生在 <code>created</code> 钩子之前。Vue 此时已经处理了 <code>data</code>、<code>computed</code> 和 <code>methods</code> 选项，所以这些属性在第一次调用时就是可用的。</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p>注意: 引用对象 or watch 不能侦听到旧值, 可以利用 计算属性 缓存旧值, 或者自己深拷贝一份作为保存</p>
</blockquote>
<h3> 其他方式</h3>
<blockquote>
<p>https://cn.vuejs.org/api/options-state.html#watch</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> $watch 的API：</h4>
<ul>
<li>https://cn.vuejs.org/api/component-instance.html#watch</li>
</ul>
<ul>
<li>我们可以在created的生命周期（后续会讲到）中，使用 this.$watchs 来侦听；</li>
<li>
<ul>
<li>第一个参数是要侦听的源；</li>
<li>第二个参数是侦听的回调函数callback；</li>
<li>第三个参数是额外的其他选项，比如deep、immediate；</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 阶段案例</h2>
<blockquote>
<p>现在我们来做一个相对综合一点的练习：书籍购物车</p>
</blockquote>
<ul>
<li>css</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>index</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> v-model</h2>
<ul>
<li>
<p><code>v-model</code> 可以在组件上使用以实现双向绑定。</p>
</li>
<li>
<p>首先让我们回忆一下 <code>v-model</code> 在原生元素上的用法：</p>
<p>template</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>在代码背后，模板编译器会对 <code>v-model</code> 进行更冗长的等价展开。因此上面的代码其实等价于下面这段：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>而当使用在一个组件上时，<code>v-model</code> 会被展开为如下的形式：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>要让这个例子实际工作起来，<code>&lt;CustomInput&gt;</code> 组件内部需要做两件事：</p>
<ol>
<li>将内部原生 <code>&lt;input&gt;</code> 元素的 <code>value</code> attribute 绑定到 <code>modelValue</code> prop</li>
<li>当原生的 <code>input</code> 事件触发时，触发一个携带了新值的 <code>update:modelValue</code> 自定义事件</li>
</ol>
</li>
</ul>
<h3> 内部实现</h3>
<figure><img src="https://qiniu.waite.wang/202310311437450.jpeg" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>
<h3> 绑定其他表单</h3>
<blockquote>
<p>具体可以看: https://cn.vuejs.org/guide/essentials/forms.html#modifiers</p>
</blockquote>
<blockquote>
<p>在 HTML 中，<code>&lt;label&gt;</code> 标签的 <code>for</code> 属性被用来关联 <code>&lt;label&gt;</code> 标签和表单控件（如 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 等）。<code>for</code> 属性的值应该是你想要关联的表单控件的 <code>id</code>。 当 <code>&lt;label&gt;</code> 被点击时，与其关联的表单控件会获得焦点。</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310312002330.png" alt="image-20231031200224648" tabindex="0" loading="lazy"><figcaption>image-20231031200224648</figcaption></figure>
<p>目前我们在前面的案例中大部分的值都是在template中固定好的：</p>
<ul>
<li>比如gender的两个输入框值male、female；</li>
<li>比如hobbies的三个输入框值basketball、football、tennis；</li>
</ul>
<p>在真实开发中，我们的数据可能是来自服务器的，那么我们就可以先将值请求下来，绑定到data返回的对象中，再通过v-bind来进行值的绑定，这个过程就是值绑定。</p>
<h3> 修饰符</h3>
<h4> 内置修饰符</h4>
<h5> <code>.lazy</code></h5>
<p>默认情况下，<code>v-model</code> 会在每次 <code>input</code> 事件后更新数据 (<a href="https://cn.vuejs.org/guide/essentials/forms.html#vmodel-ime-tip" target="_blank" rel="noopener noreferrer">IME 拼字阶段的状态</a>例外)。你可以添加 <code>lazy</code> 修饰符来改为在每次 <code>change</code> 事件后更新数据：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5> <a href="https://cn.vuejs.org/guide/essentials/forms.html#number" target="_blank" rel="noopener noreferrer"><code>.number</code></a></h5>
<p>如果你想让用户输入自动转换为数字，你可以在 <code>v-model</code> 后添加 <code>.number</code> 修饰符来管理输入：</p>
<p>另外，在我们进行逻辑判断时，如果是一个string类型，在可以转化的情况下会进行隐式转换的：</p>
<ul>
<li>下面的score在进行判断的过程中会进行隐式转化的；</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果该值无法被 <code>parseFloat()</code> 处理，那么将返回原始值。</p>
<p><code>number</code> 修饰符会在输入框有 <code>type="number"</code> 时自动启用。</p>
<h5> <a href="https://cn.vuejs.org/guide/essentials/forms.html#trim" target="_blank" rel="noopener noreferrer"><code>.trim</code></a></h5>
<p>如果你想要默认自动去除用户输入内容中两端的空格，你可以在 <code>v-model</code> 后添加 <code>.trim</code> 修饰符：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 自定义的修饰符</h4>
<p>在某些场景下，你可能想要一个自定义组件的 <code>v-model</code> 支持自定义的修饰符。</p>
<p>我们来创建一个自定义的修饰符 <code>capitalize</code>，它会自动将 <code>v-model</code> 绑定输入的字符串值第一个字母转为大写：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>组件的 <code>v-model</code> 上所添加的修饰符，可以通过 <code>modelModifiers</code> prop 在组件内访问到。在下面的组件中，我们声明了 <code>modelModifiers</code> 这个 prop，它的默认值是一个空对象：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意这里组件的 <code>modelModifiers</code> prop 包含了 <code>capitalize</code> 且其值为 <code>true</code>，因为它在模板中的 <code>v-model</code> 绑定 <code>v-model.capitalize="myText"</code> 上被使用了。</p>
<p>有了这个 prop，我们就可以检查 <code>modelModifiers</code> 对象的键，并编写一个处理函数来改变抛出的值。在下面的代码里，我们就是在每次 <code>&lt;input /&gt;</code> 元素触发 <code>input</code> 事件时将值的首字母大写：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 多个 <code>v-model</code> 绑定</h3>
<p>我们可以在单个组件实例上创建多个 <code>v-model</code> 双向绑定。</p>
<p>组件上的每一个 <code>v-model</code> 都会同步不同的 prop，而无需额外的选项：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310251728011.jpeg" type="image/jpeg"/>
    </item>
    <item>
      <title>邂逅Vue3开发</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/%E9%82%82%E9%80%85%20Vue%20%E5%BC%80%E5%8F%91.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/%E9%82%82%E9%80%85%20Vue%20%E5%BC%80%E5%8F%91.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">邂逅Vue3开发</source>
      <description>认识 Vue 什么是 Vue Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。 全程是Vue.js或者Vuejs； 什么是渐进式框架呢？表示我们可以在项目中一点点来引入和使用Vue，而不一定需要全部使用Vue来开发整个 项目； Vue3带来的变化 源码通过monorepo的形式来管理源代码： Mono：单个 Repo：repository仓库 主要是将许多项目的代码存储在同一个 repository 中； 这样做的目的是多个包本身相互独立，可以有自己的功能逻辑、单元测试等，同时又在同一个仓库下方便管理； 而且模块划分的更加清晰，可维护性、可扩展性更强； 源码使用TypeScript来进行重写： 在Vue2.x的时候，Vue使用 Flow 来进行类型检测； 在Vue3.x的时候，Vue的源码全部使用 TypeScript 来进行重构，并且 Vue 本身对 TypeScript 支持也更好了；</description>
      <pubDate>Thu, 07 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 认识 Vue</h2>
<h3> 什么是 Vue</h3>
<ul>
<li>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。
<ul>
<li>全程是Vue.js或者Vuejs；</li>
<li>什么是渐进式框架呢？表示我们可以在项目中一点点来引入和使用Vue，而不一定需要全部使用Vue来开发整个 项目；</li>
</ul>
</li>
</ul>
<h3> Vue3带来的变化</h3>
<ul>
<li>源码通过monorepo的形式来管理源代码：
<ul>
<li>Mono：单个</li>
<li>Repo：repository仓库</li>
<li>主要是将许多项目的代码存储在同一个 repository 中；</li>
<li>这样做的目的是多个包本身相互独立，可以有自己的功能逻辑、单元测试等，同时又在同一个仓库下方便管理；</li>
<li>而且模块划分的更加清晰，可维护性、可扩展性更强；</li>
</ul>
</li>
<li>源码使用TypeScript来进行重写：
<ul>
<li>在Vue2.x的时候，Vue使用 Flow 来进行类型检测；</li>
<li>在Vue3.x的时候，Vue的源码全部使用 TypeScript 来进行重构，并且 Vue 本身对 TypeScript 支持也更好了；</li>
</ul>
</li>
</ul>
<h4> 性能方面</h4>
<ul>
<li>使用Proxy进行数据劫持
<ul>
<li>在 Vue2.x 的时候，Vue2 是使用 <code>Object.defineProperty</code> 来劫持数据的 getter 和 setter 方法的；</li>
<li>这种方式一致存在一个缺陷就是当给对象添加或者删除属性时，是无法劫持和监听的；</li>
<li>所以在 Vue2.x 的时候，不得不提供一些特殊的API，比如 <code>$set</code> 或 <code>$delete</code> ，事实上都是一些 hack 方法，也增加了 开发者学习新的API的成本；</li>
<li>而在 Vue3.x 开始，Vue 使用 Proxy 来实现数据的劫持</li>
</ul>
</li>
<li>删除了一些不必要的API：
<ul>
<li>移除了实例上的 <code>$on</code> , <code>$off</code>  和  <code>$once</code>；</li>
<li>移除了一些特性：如filter、内联模板等；</li>
</ul>
</li>
<li>包括编译方面的优化：
<ul>
<li>生成Block Tree、Slot编译优化、diff算法优化；</li>
</ul>
</li>
</ul>
<h4> 新的API</h4>
<ul>
<li>由Options API 到 Composition API：
<ul>
<li>在 Vue2.x 的时候，我们会通过 Options API 来描述组件对象；</li>
<li>Options API 包括data、props、methods、computed、生命周期等等这些选项；</li>
<li>存在比较大的问题是多个逻辑可能是在不同的地方：
<ul>
<li>比如created中会使用某一个method来修改data的数据，代码的内聚性非常差；</li>
</ul>
</li>
<li>Composition API可以将 相关联的代码 放到同一处 进行处理，而不需要在多个Options之间寻找；</li>
</ul>
</li>
<li>Hooks函数增加代码的复用性：
<ul>
<li>在Vue2.x的时候，我们通常通过mixins在多个组件之间共享逻辑；但是有一个很大的缺陷就是 mixins也是由一大堆的Options组成的，并且多个mixins会存在命名冲突的问题；</li>
<li>在Vue3.x中，我们可以通过Hook函数，来将一部分独立的逻辑抽取出去，并且它们还可以做到是响应式的；</li>
</ul>
</li>
</ul>
<h2> 如何使用 Vue</h2>
<ol>
<li>方式一：在页面中通过CDN的方式来引入；</li>
<li>方式二：下载Vue的JavaScript文件，并且自己手动引入；</li>
<li>方式三：通过npm包管理工具安装使用它；</li>
<li>方式四：直接通过Vue CLI创建项目，并且使用它；</li>
</ol>
<h3> CDN 引入</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 下载和引入</h3>
<ul>
<li>下载Vue的源码，可以直接打开CDN的链接：
<ul>
<li>打开链接，复制其中所有的代码；</li>
<li>创建一个新的文件，比如vue.js，将代码复制到其中；</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 声明式编程和命令式编程</h2>
<ul>
<li>原生开发和Vue开发的模式和特点,我们会发现是完全不同的,这里其实涉及到两种不同的编程范式命令式编程和声明式编程</li>
<li>命令式编程关注的是“ how to do”,声明式编程关注的是" what to do",由框架(机器)完成"how"的过程</li>
</ul>
<h2> MVVM模型</h2>
<ul>
<li>MVC和MVVM都是一种软件的体系结构
<ul>
<li>MVC是 Model-View-Controller的简称,是在前期被使用非常框架的架构模式,比如iS、前端</li>
<li>MVVM是 Model-View- ViewMode的简称,是目前非常流行的架构模式</li>
</ul>
</li>
<li>通常情况下,我们也经常称vue是一个MVVM的框架
<ul>
<li>vue官方其实有说明,vue虽然并没有完全遵守MVVM的模型,但是整个设计是受到它的启发的</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310161331268.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> template属性</h2>
<ul>
<li>在使用 createApp的时候,我们传入了一个对象,接下来我们详细解析一下之前传入的属性分别代表什么含义。
<ul>
<li>template属性:表示的是Vue需要帮助我们渲染的模板信息</li>
<li>目前我们看到它里面有很多的HTML标签,这些标签会替换掉我们挂载到的元素(比如id为app的dⅳv)的innerHTML</li>
<li>模板中有一些奇怪的语法,比如{},比如@ )click,这些都是模板特有的语法</li>
</ul>
</li>
<li>但是这个模板的写法有点过于别扭了,并且IDE很有可能没有任何提示,阻碍我们编程的效率</li>
<li>vue提供了两种方式:</li>
<li>方式一:使用 script标签,并且标记它的类型为 X-template;</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>方式二:使用任意标签(通常使用 template标签,因为不会被浏览器渲染),设置id;v template元素是一种用于保存客户端内容的机制,该内容再加载页面时不会被呈现,但随后可以在运行时使用 JavaScript 实例化</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> data属性</h2>
<ul>
<li>
<p>data属性是传入一个函数,并且该函数需要返回一个对象</p>
<ul>
<li>在Vue2x的时候,也可以传入一个对象(虽然官方推荐是一个函数);</li>
<li>在Vue3x的时候,必须传入一个函数,否则就会直接在浏览器中报错</li>
</ul>
</li>
<li>
<p>data中返回的对象会被vue的响应式系统劫持,之后对该对象的修改或者访问都会在劫持中被处理</p>
<ul>
<li>所以我们在 template中通过{ counter} 访问 counter,可以从对象中获取到数据</li>
<li>所以我们修改 counter的值时, template中的{ counter)也会发生改变;</li>
</ul>
</li>
</ul>
<h2> methods属性（重点）</h2>
<ul>
<li>
<p>methods属性是一个对象,通常我们会在这个对象中定义很多的方法</p>
<ul>
<li>这些方法可以被绑定到 template模板中;</li>
<li>在该方法中,我们可以使用this关键字来直接访问到data中返回的对象的属性;</li>
</ul>
</li>
<li>
<p>问题：官方文档有这个描述，即不能使用箭头函数</p>
</li>
<li>
<p>为什么不能使用箭头函数(VUE3.0)？</p>
</li>
<li>
<p>我们在methods中要使用data返回对象中的数据：</p>
<ul>
<li>那么这个this是必须有值的，并且应该可以通过this获取到data返回对象中的数据。</li>
</ul>
</li>
<li>
<p>那么我们这个this能不能是window呢？</p>
<ul>
<li>不可以是window，因为window中我们无法获取到data返回对象中的数据；</li>
<li>但是如果我们使用箭头函数，那么这个this就会是window了；</li>
</ul>
</li>
<li>
<p>为什么是window呢？</p>
<ul>
<li>这里涉及到箭头函数使用this的查找规则，它会在自己的上层作用于中来查找this；</li>
<li>最终刚好找到的是script作用于中的this，所以就是window；</li>
</ul>
</li>
<li>
<p>this到底是如何查找和绑定的呢？</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA" target="_blank" rel="noopener noreferrer">前端面试之彻底搞懂this指向</a></li>
</ul>
</li>
<li>
<p><strong>不使用箭头函数的情况下，this到底指向什么</strong></p>
<ul>
<li>事实上Vue的源码当中就是对methods中的所有函数进行了遍历，并且通过 bind 绑定了 this</li>
</ul>
</li>
</ul>
<blockquote>
<p>具体看 https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 编写DOM元素的模板方式</h2>
<ol>
<li>方式一：template模板的方式：使用 <code>&lt;template&gt;</code> 标签编写模板。这种方式是之前经常使用的方式。</li>
</ol>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>方式二：render函数的方式：使用h函数来编写渲染的内容。在这种方式中，h函数可以直接返回一个虚拟节点（Vnode节点）。</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>方式三：通过.vue文件中的template来编写模板：在.vue文件中使用<code>&lt;template&gt;</code>标签编写模板。这种方式需要通过特定的代码来对模板进行解析：</li>
</ol>
<ul>
<li>对于方式三，即.vue文件中的template，可以通过vue-loader对其进行编译和处理。</li>
<li>对于方式一，即template模板，我们必须通过源码中的一部分代码来进行编译。</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，Vue在让我们选择版本时，提供了"运行时+编译器"和"仅运行时"两种选项：</p>
<ul>
<li><strong>运行时+编译器</strong>：这个版本包含了Vue的完整功能，包括对template模板的编译代码。在使用这个版本时，我们可以直接在代码中使用template模板，并且Vue会在运行时将其编译成渲染函数。这使得我们可以在开发过程中更方便地编写和调试模板。然而，由于包含了编译代码，这个版本的文件体积相对较大。</li>
<li><strong>仅运行时</strong>：这个版本不包含对template模板的编译代码。它更小巧，文件体积更小。在使用这个版本时，我们需要使用render函数来手动编写渲染逻辑，而不是直接使用template模板。这意味着我们需要更多的代码来实现相同的功能，但也带来了更好的性能和更小的文件大小。</li>
<li>选择哪个版本取决于项目的需求和优化目标。如果我们需要更完整的功能，并且对文件大小没有太大的担忧，可以选择运行时+编译器版本。如果我们对文件大小敏感，并且愿意手动编写渲染逻辑，可以选择仅运行时版本。</li>
</ul>
<h2> VSCode对SFC文件的支持</h2>
<blockquote>
<p>Vue 的单文件组件 (即 *.vue 文件，英文 Single-File Component，简称 SFC) 是一种特殊的文件格式，使我们能够将一个 Vue 组件的模板、逻辑与样式封装在单个文件中。下面是一个单文件组件的示例：</p>
</blockquote>
<blockquote>
<p>为什么要使用 SFC​
使用 SFC 必须使用构建工具，但作为回报带来了以下优点：</p>
<ul>
<li>
<p>使用熟悉的 HTML、CSS 和 JavaScript 语法编写模块化的组件</p>
</li>
<li>
<p>让本来就强相关的关注点自然内聚</p>
</li>
<li>
<p>预编译模板，避免运行时的编译开销</p>
</li>
<li>
<p>组件作用域的 CSS</p>
</li>
<li>
<p>在使用组合式 API 时语法更简单</p>
</li>
<li>
<p>通过交叉分析模板和逻辑代码能进行更多编译时优化</p>
</li>
<li>
<p>更好的 IDE 支持，提供自动补全和对模板中表达式的类型检查</p>
</li>
<li>
<p>开箱即用的模块热更新 (HMR) 支持</p>
</li>
<li>
<p>SFC 是 Vue 框架提供的一个功能，并且在下列场景中都是官方推荐的项目组织方式：</p>
</li>
<li>
<p>单页面应用 (SPA)</p>
</li>
<li>
<p>静态站点生成 (SSG)</p>
</li>
<li>
<p>任何值得引入构建步骤以获得更好的开发体验 (DX) 的项目</p>
</li>
</ul>
<p>https://cn.vuejs.org/guide/scaling-up/sfc.html</p>
</blockquote>
<ol>
<li>插件一：Vetur，从Vue2开发就一直在使用的VSCode支持Vue的插件；</li>
<li>插件二：Volar，官方推荐的插件（后续会基于Volar开发官方的VSCode插件）；</li>
</ol>
<h2> 如何阅读Vue源码</h2>
<ul>
<li>需要的环境 npm，yarn</li>
<li>操作步骤
<ol>
<li>安装yarn npm install yarn -g</li>
<li>在项目中配置yarn yarn install</li>
<li>在package.json中的dev后加上--sourcemap</li>
<li>打包项目 yarn dev （在vue/dist文件夹下有两个文件，vue.global.js和vue.global.js.map）</li>
<li>在vue/examplex新建自己的文件夹以及测试demo</li>
<li>在demo中打下断点—debugger</li>
<li>在浏览器中打开调试面板，选择其中的source面板，查看执行对应的源码</li>
</ol>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310161331268.png" type="image/png"/>
    </item>
  </channel>
</rss>