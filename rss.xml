<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://brain.sunguoqi.com/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://brain.sunguoqi.com/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Waite Wang</title>
    <link>https://brain.sunguoqi.com/</link>
    <description>热爱可抵漫长岁月！</description>
    <language>zh-CN</language>
    <pubDate>Sat, 16 Dec 2023 15:20:40 GMT</pubDate>
    <lastBuildDate>Sat, 16 Dec 2023 15:20:40 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <item>
      <title>Composition API</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/Composition%20API.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/Composition%20API.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Composition API</source>
      <description>[TOC] Options API的弊端 在Vue2中，我们编写组件的方式是Options API： Options API的一大特点就是在对应的属性中编写对应的功能模块； 比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子； 但是这种代码有一个很大的弊端： 当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中； 当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散； 尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）； 下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分： 这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题； 并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中；</description>
      <pubDate>Sat, 16 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>[TOC]</p>
<h2> Options API的弊端</h2>
<ul>
<li>
<p>在Vue2中，我们编写组件的方式是Options API：</p>
<ul>
<li>Options API的一大特点就是在对应的属性中编写对应的功能模块；</li>
<li>比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子；</li>
</ul>
</li>
<li>
<p>但是这种代码有一个很大的弊端：</p>
<ul>
<li>当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中；</li>
<li>当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散；</li>
<li>尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）；</li>
</ul>
</li>
<li>
<p>下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分：</p>
<ul>
<li>这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题；</li>
<li>并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中；</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312160000793.png" alt="image-20231216000029755" tabindex="0" loading="lazy"><figcaption>image-20231216000029755</figcaption></figure>
<ul>
<li>如果我们能将同一个逻辑关注 点相关的代码收集在一起会更 好。</li>
<li>这就是Composition API想 要做的事情，以及可以帮助我 们完成的事情。</li>
<li>也有人把Vue Composition API简称为VCA。</li>
<li>我们无需再为了一个逻辑关注点在不同的选项块间来回滚动切换。此外，我们现在可以很轻松地将这一组代码移动到一个外部文件中，不再需要为了抽象而重新组织代码，大大降低了重构成本，这在长期维护的大型项目中非常关键。</li>
</ul>
<h2> 认识 组合式 API (Composition API)</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/extras/composition-api-faq.html#what-is-composition-api</p>
</blockquote>
<p>组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。它是一个概括性的术语，涵盖了以下方面的 API：</p>
<ul>
<li><a href="https://cn.vuejs.org/api/reactivity-core.html" target="_blank" rel="noopener noreferrer">响应式 API</a>：例如 <code>ref()</code> 和 <code>reactive()</code>，使我们可以直接创建响应式状态、计算属性和侦听器。</li>
<li><a href="https://cn.vuejs.org/api/composition-api-lifecycle.html" target="_blank" rel="noopener noreferrer">生命周期钩子</a>：例如 <code>onMounted()</code> 和 <code>onUnmounted()</code>，使我们可以在组件各个生命周期阶段添加逻辑。</li>
<li><a href="https://cn.vuejs.org/api/composition-api-dependency-injection.html" target="_blank" rel="noopener noreferrer">依赖注入</a>：例如 <code>provide()</code> 和 <code>inject()</code>，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统。</li>
</ul>
<p>组合式 API 是 Vue 3 及 <a href="https://blog.vuejs.org/posts/vue-2-7-naruto.html" target="_blank" rel="noopener noreferrer">Vue 2.7</a> 的内置功能。对于更老的 Vue 2 版本，可以使用官方维护的插件 <a href="https://github.com/vuejs/composition-api" target="_blank" rel="noopener noreferrer"><code>@vue/composition-api</code></a>。在 Vue 3 中，组合式 API 基本上都会配合 <a href="https://cn.vuejs.org/api/sfc-script-setup.html" target="_blank" rel="noopener noreferrer">``</a> 语法在单文件组件中使用。下面是一个使用组合式 API 的组件示例：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然这套 API 的风格是基于函数的组合，但<strong>组合式 API 并不是函数式编程</strong>。组合式 API 是以 Vue 中数据可变的、细粒度的响应性系统为基础的，而函数式编程通常强调数据不可变。</p>
<h2> setup()</h2>
<blockquote>
<p>以下的代码 均会采用选项式的写法, 组合式 Api 的写法可以参考官方文档, 但基本原理差不多, 而且 Vue3 选项式写法是基于组合式写法产生的!</p>
</blockquote>
<p><code>setup()</code> 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：</p>
<ol>
<li>需要在非单文件组件中使用组合式 API 时。</li>
<li>需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。</li>
</ol>
<h3> setup函数的参数</h3>
<ul>
<li>主要有两个参数:
<ul>
<li>第一个参数：props</li>
<li>第二个参数：context</li>
</ul>
</li>
<li><code>setup</code> 函数的第一个参数是组件的 <code>props</code>。和标准的组件一致，一个 <code>setup</code> 函数的 <code>props</code> 是响应式的，并且会在传入新的 props 时同步更新。：
<ul>
<li>对于定义props的类型，我们还是和之前的规则是一样的，在props选项中定义；</li>
<li>并且在template中依然是可以正常去使用props中的属性，比如message；</li>
<li>如果我们在setup函数中想要使用props，那么不可以通过 this 去获取</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>setup</code> 函数的第一个参数是组件的 <code>props</code>。和标准的组件一致，一个 <code>setup</code> 函数的 <code>props</code> 是响应式的，并且会在传入新的 props 时同步更新。</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意如果你解构了 <code>props</code> 对象，解构出的变量将会丢失响应性。因此我们推荐通过 <code>props.xxx</code> 的形式来使用其中的 props。</p>
<p>如果你确实需要解构 <code>props</code> 对象，或者需要将某个 prop 传到一个外部函数中并保持响应性，那么你可以使用 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#torefs" target="_blank" rel="noopener noreferrer">toRefs()</a> 和 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#toref" target="_blank" rel="noopener noreferrer">toRef()</a> 这两个工具函数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>另外一个参数是context，我们也称之为是一个SetupContext，它里面包含三个属性：
<ul>
<li>attrs：所有的非prop的attribute；</li>
<li>slots：父组件传递过来的插槽（这个在以渲染函数返回时会有作用，后面会讲到）；</li>
<li>emit：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可以通过 this.$emit发出事件）；</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>attrs</code> 和 <code>slots</code> 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 <code>attrs.x</code> 或 <code>slots.x</code> 的形式使用其中的属性。此外还需注意，和 <code>props</code> 不同，<code>attrs</code> 和 <code>slots</code> 的属性都<strong>不是</strong>响应式的。如果你想要基于 <code>attrs</code> 或 <code>slots</code> 的改变来执行副作用，那么你应该在 <code>onBeforeUpdate</code> 生命周期钩子中编写相关逻辑。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> setup函数的返回值</h3>
<p><code>setup</code> 也可以返回一个<a href="https://cn.vuejs.org/guide/extras/render-function.html" target="_blank" rel="noopener noreferrer">渲染函数</a>，此时在渲染函数中可以直接使用在同一作用域下声明的响应式状态：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回一个渲染函数将会阻止我们返回其他东西。对于组件内部来说，这样没有问题，但如果我们想通过模板引用将这个组件的方法暴露给父组件，那就有问题了。</p>
<p>我们可以通过调用 <a href="https://cn.vuejs.org/api/composition-api-setup.html#exposing-public-properties" target="_blank" rel="noopener noreferrer"><code>expose()</code></a> 解决这个问题：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时父组件可以通过模板引用来访问这个 <code>increment</code> 方法。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>setup的返回值可以在模板template中被使用</li>
<li>也就是说可以通过setup的返回值来替代data选项</li>
</ul>
<blockquote>
<p><strong>最后导出的一定要是个对象</strong></p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312162228196.gif" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<blockquote>
<p><strong>因为只是定义了个变量，然后导出了，并没有使它响应式</strong></p>
</blockquote>
<h3> 补充: 为什么 setup 不能使用 this</h3>
<p><code>setup()</code> 自身并不含对组件实例的访问权，即在 <code>setup()</code> 中访问 <code>this</code> 会是 <code>undefined</code>。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。</p>
<h2> </h2>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202312160000793.png" type="image/png"/>
    </item>
    <item>
      <title>Mixins, extends 以及组合式函数</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Mixins, extends 以及组合式函数</source>
      <description>认识 Mixin 在 Vue 2 中，mixins 是创建可重用组件逻辑的主要方式。尽管在 Vue 3 中保留了 mixins 支持，但对于组件间的逻辑复用，使用组合式 API 的组合式函数是现在更推荐的方式。 目前我们是使用组件化的方式在开发整个Vue的应用程序，但是组件和组件之间有时候会存在相同的代码逻辑，我们希望对相同的代码逻辑进行抽取。 在Vue2和Vue3中都支持的一种方式就是使用Mixin来完成： Mixin提供了一种非常灵活的方式，来分发Vue组件中的可复用功能； 一个Mixin对象可以包含任何组件选项； 当组件使用Mixin对象时，所有Mixin对象的选项将被 混合 进入该组件本身的选项中；</description>
      <pubDate>Fri, 15 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 认识 Mixin</h2>
<blockquote>
<p>在 Vue 2 中，mixins 是创建可重用组件逻辑的主要方式。尽管在 Vue 3 中保留了 mixins 支持，但对于组件间的逻辑复用，<a href="https://cn.vuejs.org/guide/reusability/composables.html" target="_blank" rel="noopener noreferrer">使用组合式 API 的组合式函数</a>是现在更推荐的方式。</p>
</blockquote>
<ul>
<li>目前我们是使用组件化的方式在开发整个Vue的应用程序，但是组件和组件之间有时候会存在相同的代码逻辑，我们希望对相同的代码逻辑进行抽取。</li>
<li>在Vue2和Vue3中都支持的一种方式就是使用Mixin来完成：
<ul>
<li>Mixin提供了一种非常灵活的方式，来分发Vue组件中的可复用功能；</li>
<li>一个Mixin对象可以包含任何组件选项；</li>
<li>当组件使用Mixin对象时，所有Mixin对象的选项将被 混合 进入该组件本身的选项中；</li>
</ul>
</li>
</ul>
<h3> 基本使用</h3>
<p><code>mixins</code> 选项接受一个 mixin 对象数组。这些 mixin 对象可以像普通的实例对象一样包含实例选项，它们将使用一定的选项合并逻辑与最终的选项进行合并。举例来说，如果你的 mixin 包含了一个 <code>created</code> 钩子，而组件自身也有一个，那么这两个函数都会被调用。</p>
<p>Mixin 钩子的调用顺序与提供它们的选项顺序相同，且会在组件自身的钩子前被调用。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Mixin的合并规则</h3>
<ul>
<li>如果Mixin对象中的选项和组件对象中的选项发生了冲突，那么Vue会如何操作呢？
<ul>
<li>这里分成不同的情况来进行处理；</li>
</ul>
</li>
<li>情况一：如果是data函数的返回值对象
<ul>
<li>返回值对象默认情况下会进行合并；</li>
<li>如果data返回值对象的属性发生了冲突，那么会保留组件自身的数据；</li>
</ul>
</li>
<li>情况二：如何生命周期钩子函数
<ul>
<li>生命周期的钩子函数会被合并到数组中，都会被调用；</li>
</ul>
</li>
<li>情况三：值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。
<ul>
<li>比如都有methods选项，并且都定义了方法，那么它们都会生效；</li>
<li>但是如果对象的key相同，那么会取组件对象的键值对；</li>
</ul>
</li>
</ul>
<h3> 全局混入 Mixin</h3>
<p>如果组件中的某些选项，是所有的组件都需要拥有的，那么这个时候我们可以使用全局的mixin：</p>
<ul>
<li>全局的Mixin可以使用 应用app的方法 mixin 来完成注册；</li>
<li>一旦注册，那么全局混入的选项将会影响每一个组件；</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> externds</h2>
<ul>
<li>另外一个类似与Mixin的方式是通过extends属性
<ul>
<li>允许声明拓展另外一个组件，类似与Mixins；</li>
</ul>
</li>
</ul>
<p>使一个组件可以继承另一个组件的组件选项。</p>
<p>从实现角度来看，<code>extends</code> 几乎和 <code>mixins</code> 相同。通过 <code>extends</code> 指定的组件将会当作第一个 mixin 来处理。</p>
<p>然而，<code>extends</code> 和 <code>mixins</code> 表达的是不同的目标。<code>mixins</code> 选项基本用于组合功能，而 <code>extends</code> 则一般更关注继承关系。</p>
<p>同 <code>mixins</code> 一样，所有选项 (<code>setup()</code> 除外) 都将使用相关的策略进行合并。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><code>extends</code> 是为选项式 API 设计的，不会处理 <code>setup()</code> 钩子的合并。</p>
<p>在组合式 API 中，逻辑复用的首选模式是“组合”而不是“继承”。如果一个组件中的逻辑需要复用，考虑将相关逻辑提取到<a href="https://cn.vuejs.org/guide/reusability/composables.html#composables" target="_blank" rel="noopener noreferrer">组合式函数</a>中。</p>
<p>如果你仍然想要通过组合式 API 来“继承”一个组件，可以在继承组件的 <code>setup()</code> 中调用基类组件的 <code>setup()</code>：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote>
<h2> 组合式函数</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/reusability/composables.html</p>
</blockquote>
<h3> <a href="https://cn.vuejs.org/guide/reusability/composables.html#what-is-a-composable" target="_blank" rel="noopener noreferrer">什么是“组合式函数”？</a></h3>
<p>在 Vue 应用的概念中，“组合式函数”(Composables) 是一个利用 Vue 的组合式 API 来封装和复用<strong>有状态逻辑</strong>的函数。</p>
<p>当构建前端应用时，我们常常需要复用公共任务的逻辑。例如为了在不同地方格式化时间，我们可能会抽取一个可复用的日期格式化函数。这个函数封装了<strong>无状态的逻辑</strong>：它在接收一些输入后立刻返回所期望的输出。复用无状态逻辑的库有很多，比如你可能已经用过的 <a href="https://lodash.com/" target="_blank" rel="noopener noreferrer">lodash</a> 或是 <a href="https://date-fns.org/" target="_blank" rel="noopener noreferrer">date-fns</a>。</p>
<p>相比之下，有状态逻辑负责管理会随时间而变化的状态。一个简单的例子是跟踪当前鼠标在页面中的位置。在实际应用中，也可能是像触摸手势或与数据库的连接状态这样的更复杂的逻辑。</p>
<h3> 鼠标跟踪器示例</h3>
<p>如果我们要直接在组件中使用组合式 API 实现鼠标跟踪功能，它会是这样的：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，如果我们想在多个组件中复用这个相同的逻辑呢？我们可以把这个逻辑以一个组合式函数的形式提取到外部文件中：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是它在组件中使用的方式：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，核心逻辑完全一致，我们做的只是把它移到一个外部函数中去，并返回需要暴露的状态。和在组件中一样，你也可以在组合式函数中使用所有的<a href="https://cn.vuejs.org/api/#composition-api" target="_blank" rel="noopener noreferrer">组合式 API</a>。现在，<code>useMouse()</code> 的功能可以在任何组件中轻易复用了。</p>
<p>更酷的是，你还可以嵌套多个组合式函数：一个组合式函数可以调用一个或多个其他的组合式函数。这使得我们可以像使用多个组件组合成整个应用一样，用多个较小且逻辑独立的单元来组合形成复杂的逻辑。实际上，这正是为什么我们决定将实现了这一设计模式的 API 集合命名为组合式 API。</p>
<p>举例来说，我们可以将添加和清除 DOM 事件监听器的逻辑也封装进一个组合式函数中：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了它，之前的 <code>useMouse()</code> 组合式函数可以被简化为：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <a href="https://cn.vuejs.org/guide/reusability/composables.html#async-state-example" target="_blank" rel="noopener noreferrer">异步状态示例</a></h3>
<p><code>useMouse()</code> 组合式函数没有接收任何参数，因此让我们再来看一个需要接收一个参数的组合式函数示例。在做异步数据请求时，我们常常需要处理不同的状态：加载中、加载成功和加载失败。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在每个需要获取数据的组件中都要重复这种模式，那就太繁琐了。让我们把它抽取成一个组合式函数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们在组件里只需要：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <a href="https://cn.vuejs.org/guide/reusability/composables.html#accepting-reactive-state" target="_blank" rel="noopener noreferrer">接收响应式状态</a></h3>
<p><code>useFetch()</code> 接收一个静态 URL 字符串作为输入——因此它只会执行一次 fetch 并且就此结束。如果我们想要在 URL 改变时重新 fetch 呢？为了实现这一点，我们需要将响应式状态传入组合式函数，并让它基于传入的状态来创建执行操作的侦听器。</p>
<p>举例来说，<code>useFetch()</code> 应该能够接收一个 ref：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者接收一个 getter 函数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以用 <a href="https://cn.vuejs.org/api/reactivity-core.html#watcheffect" target="_blank" rel="noopener noreferrer"><code>watchEffect()</code></a> 和 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#tovalue" target="_blank" rel="noopener noreferrer"><code>toValue()</code></a> API 来重构我们现有的实现：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>toValue()</code> 是一个在 3.3 版本中新增的 API。它的设计目的是将 ref 或 getter 规范化为值。如果参数是 ref，它会返回 ref 的值；如果参数是函数，它会调用函数并返回其返回值。否则，它会原样返回参数。它的工作方式类似于 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#unref" target="_blank" rel="noopener noreferrer"><code>unref()</code></a>，但对函数有特殊处理。</p>
<p>注意 <code>toValue(url)</code> 是在 <code>watchEffect</code> 回调函数的<strong>内部</strong>调用的。这确保了在 <code>toValue()</code> 规范化期间访问的任何响应式依赖项都会被侦听器跟踪。</p>
<p>这个版本的 <code>useFetch()</code> 现在能接收静态 URL 字符串、ref 和 getter，使其更加灵活。watch effect 会立即运行，并且会跟踪 <code>toValue(url)</code> 期间访问的任何依赖项。如果没有跟踪到依赖项（例如 url 已经是字符串），则 effect 只会运行一次；否则，它将在跟踪到的任何依赖项更改时重新运行。</p>
<h2> <a href="https://cn.vuejs.org/guide/reusability/composables.html#conventions-and-best-practices" target="_blank" rel="noopener noreferrer">约定和最佳实践</a></h2>
<h3> 命名</h3>
<p>组合式函数约定用驼峰命名法命名，并以“use”作为开头。</p>
<h3> 输入参数</h3>
<p>即便不依赖于 ref 或 getter 的响应性，组合式函数也可以接收它们作为参数。如果你正在编写一个可能被其他开发者使用的组合式函数，最好处理一下输入参数是 ref 或 getter 而非原始值的情况。可以利用 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#tovalue" target="_blank" rel="noopener noreferrer"><code>toValue()</code></a> 工具函数来实现：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你的组合式函数在输入参数是 ref 或 getter 的情况下创建了响应式 effect，为了让它能够被正确追踪，请确保要么使用 <code>watch()</code> 显式地监视 ref 或 getter，要么在 <code>watchEffect()</code> 中调用 <code>toValue()</code>。</p>
<p><a href="https://cn.vuejs.org/guide/reusability/composables.html#accepting-reactive-state" target="_blank" rel="noopener noreferrer">前面讨论过的 useFetch() 实现</a>提供了一个接受 ref、getter 或普通值作为输入参数的组合式函数的具体示例。</p>
<h3> <a href="https://cn.vuejs.org/guide/reusability/composables.html#return-values" target="_blank" rel="noopener noreferrer">返回值</a></h3>
<p>你可能已经注意到了，我们一直在组合式函数中使用 <code>ref()</code> 而不是 <code>reactive()</code>。我们推荐的约定是组合式函数始终返回一个包含多个 ref 的普通的非响应式对象，这样该对象在组件中被解构为 ref 之后仍可以保持响应性：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>从组合式函数返回一个响应式对象会导致在对象解构过程中丢失与组合式函数内状态的响应性连接。与之相反，ref 则可以维持这一响应性连接。</p>
<p>如果你更希望以对象属性的形式来使用组合式函数中返回的状态，你可以将返回的对象用 <code>reactive()</code> 包装一次，这样其中的 ref 会被自动解包，例如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 副作用<a href="https://cn.vuejs.org/guide/reusability/composables.html#side-effects" target="_blank" rel="noopener noreferrer"></a></h3>
<p>在组合式函数中的确可以执行副作用 (例如：添加 DOM 事件监听器或者请求数据)，但请注意以下规则：</p>
<ul>
<li>如果你的应用用到了<a href="https://cn.vuejs.org/guide/scaling-up/ssr.html" target="_blank" rel="noopener noreferrer">服务端渲染</a> (SSR)，请确保在组件挂载后才调用的生命周期钩子中执行 DOM 相关的副作用，例如：<code>onMounted()</code>。这些钩子仅会在浏览器中被调用，因此可以确保能访问到 DOM。</li>
<li>确保在 <code>onUnmounted()</code> 时清理副作用。举例来说，如果一个组合式函数设置了一个事件监听器，它就应该在 <code>onUnmounted()</code> 中被移除 (就像我们在 <code>useMouse()</code> 示例中看到的一样)。当然也可以像之前的 <code>useEventListener()</code> 示例那样，使用一个组合式函数来自动帮你做这些事。</li>
</ul>
<h3> 使用限制<a href="https://cn.vuejs.org/guide/reusability/composables.html#usage-restrictions" target="_blank" rel="noopener noreferrer"></a></h3>
<p>组合式函数只能在 <code>&lt;script setup&gt;</code> 或 <code>setup()</code> 钩子中被调用。在这些上下文中，它们也只能被<strong>同步</strong>调用。在某些情况下，你也可以在像 <code>onMounted()</code> 这样的生命周期钩子中调用它们。</p>
<p>这些限制很重要，因为这些是 Vue 用于确定当前活跃的组件实例的上下文。访问活跃的组件实例很有必要，这样才能：</p>
<ol>
<li>将生命周期钩子注册到该组件实例上</li>
<li>将计算属性和监听器注册到该组件实例上，以便在该组件被卸载时停止监听，避免内存泄漏。</li>
</ol>
<blockquote>
<p><code>&lt;script setup&gt;</code>&nbsp;是唯一在调用&nbsp;await&nbsp;之后仍可调用组合式函数的地方。编译器会在异步操作之后自动为你恢复当前的组件实例。</p>
</blockquote>
<h3> <a href="https://cn.vuejs.org/guide/reusability/composables.html#extracting-composables-for-code-organization" target="_blank" rel="noopener noreferrer">通过抽取组合式函数改善代码结构</a></h3>
<p>抽取组合式函数不仅是为了复用，也是为了代码组织。随着组件复杂度的增高，你可能会最终发现组件多得难以查询和理解。组合式 API 会给予你足够的灵活性，让你可以基于逻辑问题将组件代码拆分成更小的函数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在某种程度上，你可以将这些提取出的组合式函数看作是可以相互通信的组件范围内的服务。</p>
<h3> <a href="https://cn.vuejs.org/guide/reusability/composables.html#using-composables-in-options-api" target="_blank" rel="noopener noreferrer">在选项式 API 中使用组合式函数</a></h3>
<p>如果你正在使用选项式 API，组合式函数必须在 <code>setup()</code> 中调用。且其返回的绑定必须在 <code>setup()</code> 中返回，以便暴露给 <code>this</code> 及其模板：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> <a href="https://cn.vuejs.org/guide/reusability/composables.html#vs-mixins" target="_blank" rel="noopener noreferrer">对比</a></h2>
<p>Vue 2 的用户可能会对 <a href="https://cn.vuejs.org/api/options-composition.html#mixins" target="_blank" rel="noopener noreferrer">mixins</a> 选项比较熟悉。它也让我们能够把组件逻辑提取到可复用的单元里。然而 mixins 有三个主要的短板：</p>
<ol>
<li><strong>不清晰的数据来源</strong>：当使用了多个 mixin 时，实例上的数据属性来自哪个 mixin 变得不清晰，这使追溯实现和理解组件行为变得困难。这也是我们推荐在组合式函数中使用 ref + 解构模式的理由：让属性的来源在消费组件时一目了然。</li>
<li><strong>命名空间冲突</strong>：多个来自不同作者的 mixin 可能会注册相同的属性名，造成命名冲突。若使用组合式函数，你可以通过在解构变量时对变量进行重命名来避免相同的键名。</li>
<li><strong>隐式的跨 mixin 交流</strong>：多个 mixin 需要依赖共享的属性名来进行相互作用，这使得它们隐性地耦合在一起。而一个组合式函数的返回值可以作为另一个组合式函数的参数被传入，像普通函数那样。</li>
</ol>
<p>基于上述理由，我们不再推荐在 Vue 3 中继续使用 mixin。保留该功能只是为了项目迁移的需求和照顾熟悉它的用户。</p>
<h3> <a href="https://cn.vuejs.org/guide/reusability/composables.html#vs-renderless-components" target="_blank" rel="noopener noreferrer">和无渲染组件的对比</a></h3>
<p>在组件插槽一章中，我们讨论过了基于作用域插槽的<a href="https://cn.vuejs.org/guide/components/slots.html#renderless-components" target="_blank" rel="noopener noreferrer">无渲染组件</a>。我们甚至用它实现了一样的鼠标追踪器示例。</p>
<p>组合式函数相对于无渲染组件的主要优势是：组合式函数不会产生额外的组件实例开销。当在整个应用中使用时，由无渲染组件产生的额外组件实例会带来无法忽视的性能开销。</p>
<p>我们推荐在纯逻辑复用时使用组合式函数，在需要同时复用逻辑和视图布局时使用无渲染组件。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Vue 过渡与动画初体验</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/animation/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/animation/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Vue 过渡与动画初体验</source>
      <description>认识动画 在开发中，我们想要给一个组件的显示和消失添加某种过渡动画，可以很好的增加用户体验： React框架本身并没有提供任何动画相关的API，所以在React中使用过渡动画我们需要使用一个第三方库 react-transition-group； Vue中为我们提供一些内置组件和对应的API来完成动画，利用它们我们可以方便的实现过渡动画效果； 我们来看一个案例： Hello World的显示和隐藏； 通过下面的代码实现，是不会有任何动画效果的；</description>
      <pubDate>Fri, 15 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 认识动画</h2>
<ul>
<li>在开发中，我们想要给一个组件的显示和消失添加某种过渡动画，可以很好的增加用户体验：
<ul>
<li>React框架本身并没有提供任何动画相关的API，所以在React中使用过渡动画我们需要使用一个第三方库 react-transition-group；</li>
<li>Vue中为我们提供一些内置组件和对应的API来完成动画，利用它们我们可以方便的实现过渡动画效果；</li>
</ul>
</li>
<li>我们来看一个案例：
<ul>
<li>Hello World的显示和隐藏；</li>
<li>通过下面的代码实现，是不会有任何动画效果的；</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>没有动画的情况下，整个内容的显示和隐藏会非常的生硬：
<ul>
<li>如果我们希望给单元素或者组件实现过渡动画，可以使用 <code>transition</code>内置组件来完成动画；</li>
</ul>
</li>
</ul>
<h2> Vue的 transition 动画</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/built-ins/transition.html#transition</p>
</blockquote>
<p><code>&lt;Transition&gt;</code> 会在一个元素或组件进入和离开 DOM 时应用动画。</p>
<p><code>&lt;Transition&gt;</code> 是一个内置组件，这意味着它在任意别的组件中都可以被使用，无需注册。它可以将进入和离开动画应用到通过默认插槽传递给它的元素或组件上。进入或离开可以由以下的条件之一触发：</p>
<ul>
<li>由 <code>v-if</code> 所触发的切换</li>
<li>由 <code>v-show</code> 所触发的切换</li>
<li>由特殊元素 <code>&lt;component&gt;</code> 切换的动态组件</li>
<li>改变特殊的 <code>key</code> 属性</li>
</ul>
<p>以下是最基本用法的示例：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><code>&lt;Transition&gt;</code> 仅支持单个元素或组件作为其插槽内容。如果内容是一个组件，这个组件必须仅有一个根元素。</p>
</blockquote>
<p>当一个 <code>&lt;Transition&gt;</code> 组件中的元素被插入或移除时，会发生下面这些事情：</p>
<ol>
<li>Vue 会自动检测目标元素是否应用了 CSS 过渡或动画。如果是，则一些 <a href="https://cn.vuejs.org/guide/built-ins/transition.html#transition-classes" target="_blank" rel="noopener noreferrer">CSS 过渡 class</a> 会在适当的时机被添加和移除。</li>
<li>如果有作为监听器的 <a href="https://cn.vuejs.org/guide/built-ins/transition.html#javascript-hooks" target="_blank" rel="noopener noreferrer">JavaScript 钩子</a>，这些钩子函数会在适当时机被调用。</li>
<li>如果没有探测到 CSS 过渡或动画、也没有提供 JavaScript 钩子，那么 DOM 的插入、删除操作将在浏览器的下一个动画帧后执行。</li>
</ol>
<h3> 基于 CSS 的过渡效果</h3>
<h4> <a href="https://cn.vuejs.org/guide/built-ins/transition.html#transition-classes" target="_blank" rel="noopener noreferrer">CSS 过渡 class</a></h4>
<p>一共有 6 个应用于进入与离开过渡效果的 CSS class。</p>
<figure><img src="https://qiniu.waite.wang/202312111414504.png" alt="过渡图示" tabindex="0" loading="lazy"><figcaption>过渡图示</figcaption></figure>
<ol>
<li><code>v-enter-from</code>：进入动画的起始状态。在元素插入之前添加，在元素插入完成后的下一帧移除。</li>
<li><code>v-enter-active</code>：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。</li>
<li><code>v-enter-to</code>：进入动画的结束状态。在元素插入完成后的下一帧被添加 (也就是 <code>v-enter-from</code> 被移除的同时)，在过渡或动画完成之后移除。</li>
<li><code>v-leave-from</code>：离开动画的起始状态。在离开过渡效果被触发时立即添加，在一帧后被移除。</li>
<li><code>v-leave-active</code>：离开动画的生效状态。应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡或动画完成之后移除。这个 class 可以被用来定义离开动画的持续时间、延迟与速度曲线类型。</li>
<li><code>v-leave-to</code>：离开动画的结束状态。在一个离开动画被触发后的下一帧被添加 (也就是 <code>v-leave-from</code> 被移除的同时)，在过渡或动画完成之后移除。</li>
</ol>
<h4> 为过渡效果命名</h4>
<p>我们可以给 <code>&lt;Transition&gt;</code> 组件传一个 <code>name</code> prop 来声明一个过渡效果名：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于一个有名字的过渡效果，对它起作用的过渡 class 会以其名字而不是 <code>v</code> 作为前缀。比如，上方例子中被应用的 class 将会是 <code>fade-enter-active</code> 而不是 <code>v-enter-active</code>。这个“fade”过渡的 class 应该是这样：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> CSS 的 transition</h4>
<p><code>&lt;Transition&gt;</code> 一般都会搭配<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions" target="_blank" rel="noopener noreferrer">原生 CSS 过渡</a>一起使用，正如你在上面的例子中所看到的那样。这个 <code>transition</code> CSS 属性是一个简写形式，使我们可以一次定义一个过渡的各个方面，包括需要执行动画的属性、持续时间和<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function" target="_blank" rel="noopener noreferrer">速度曲线</a>。</p>
<p>下面是一个更高级的例子，它使用了不同的持续时间和速度曲线来过渡多个属性：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> CSS 的 animation</h2>
<blockquote>
<p>帧动画, 可以指定在什么时间是什么状态!</p>
</blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations" target="_blank" rel="noopener noreferrer">原生 CSS 动画</a>和 CSS transition 的应用方式基本上是相同的，只有一点不同，那就是 <code>*-enter-from</code> 不是在元素插入后立即移除，而是在一个 <code>animationend</code> 事件触发时被移除。</p>
<p>对于大多数的 CSS 动画，我们可以简单地在 <code>*-enter-active</code> 和 <code>*-leave-active</code> class 下声明它们。下面是一个示例：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> <a href="https://cn.vuejs.org/guide/built-ins/transition.html#custom-transition-classes" target="_blank" rel="noopener noreferrer">自定义过渡 class</a></h2>
<p>你也可以向 <code>&lt;Transition&gt;</code> 传递以下的 props 来指定自定义的过渡 class：</p>
<ul>
<li><code>enter-from-class</code></li>
<li><code>enter-active-class</code></li>
<li><code>enter-to-class</code></li>
<li><code>leave-from-class</code></li>
<li><code>leave-active-class</code></li>
<li><code>leave-to-class</code></li>
</ul>
<p>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如  Animate.css.</p>
<p>你传入的这些 class 会覆盖相应阶段的默认 class 名。这个功能在你想要在 Vue 的动画机制下集成其他的第三方 CSS 动画库时非常有用，比如 <a href="https://daneden.github.io/animate.css/" target="_blank" rel="noopener noreferrer">Animate.css</a>：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 同时设置过渡和动画</h2>
<ul>
<li>Vue为了知道过渡的完成，内部是在监听 <code>transitionend </code>或 <code>animationend</code>，到底使用哪一个取决于元素应用的 CSS规则：
<ul>
<li>如果我们只是使用了其中的一个，那么Vue能自动识别类型并设置监听；</li>
</ul>
</li>
<li>但是如果我们同时使用了过渡和动画呢？
<ul>
<li>并且在这个情况下可能某一个动画执行结束时，另外一个动画还没有结束；</li>
<li>在这种情况下，我们可以设置 type 属性为 animation 或者 transition 来明确的告知Vue监听的类型；</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> <a href="https://cn.vuejs.org/guide/built-ins/transition.html#nested-transitions-and-explicit-transition-durations" target="_blank" rel="noopener noreferrer">深层级过渡与显式过渡时长</a></h2>
<p>尽管过渡 class 仅能应用在 <code>&lt;Transition&gt;</code> 的直接子元素上，我们还是可以使用深层级的 CSS 选择器，在深层级的元素上触发过渡效果。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们甚至可以在深层元素上添加一个过渡延迟，从而创建一个带渐进延迟的动画序列：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然而，这会带来一个小问题。默认情况下，<code>&lt;Transition&gt;</code> 组件会通过监听过渡根元素上的<strong>第一个</strong> <code>transitionend</code> 或者 <code>animationend</code> 事件来尝试自动判断过渡何时结束。而在嵌套的过渡中，期望的行为应该是等待所有内部元素的过渡完成。</p>
<p>在这种情况下，你可以通过向 <code>&lt;Transition&gt;</code> 组件传入 <code>duration</code> prop 来显式指定过渡的持续时间 (以毫秒为单位)。总持续时间应该匹配延迟加上内部元素的过渡持续时间：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果有必要的话，你也可以用对象的形式传入，分开指定进入和离开所需的时间：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> <a href="https://cn.vuejs.org/guide/built-ins/transition.html#transition-modes" target="_blank" rel="noopener noreferrer">过渡模式</a></h2>
<p>在之前的例子中，进入和离开的元素都是在同时开始动画的，因此我们不得不将它们设为 <code>position: absolute</code> 以避免二者同时存在时出现的布局问题。</p>
<p>然而，很多情况下这可能并不符合需求。我们可能想要先执行离开动画，然后在其完成<strong>之后</strong>再执行元素的进入动画。手动编排这样的动画是非常复杂的，好在我们可以通过向 <code>&lt;Transition&gt;</code> 传入一个 <code>mode</code> prop 来实现这个行为：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>&lt;Transition&gt;</code> 也支持 <code>mode="in-out"</code>，虽然这并不常用。</p>
<p><code>&lt;Transition&gt;</code> 也可以作用于<a href="https://cn.vuejs.org/guide/essentials/component-basics.html#dynamic-components" target="_blank" rel="noopener noreferrer">动态组件</a>之间的切换：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <a href="https://cn.vuejs.org/guide/built-ins/transition.html#transition-on-appear" target="_blank" rel="noopener noreferrer">出现时过渡</a></h3>
<p>如果你想在某个节点初次渲染时应用一个过渡效果，你可以添加 <code>appear</code> prop：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <a href="https://cn.vuejs.org/guide/built-ins/transition.html#transition-between-elements" target="_blank" rel="noopener noreferrer">元素间过渡</a></h3>
<p>除了通过 <code>v-if</code> / <code>v-show</code> 切换一个元素，我们也可以通过 <code>v-if</code> / <code>v-else</code> / <code>v-else-if</code> 在几个组件间进行切换，只要确保任一时刻只会有一个元素被渲染即可：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> JavaScript 钩子</h2>
<p>你可以通过监听 <code>&lt;Transition&gt;</code> 组件事件的方式在过渡过程中挂上钩子函数：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些钩子可以与 CSS 过渡或动画结合使用，也可以单独使用。</p>
<p>在使用仅由 JavaScript 执行的动画时，最好是添加一个 <code>:css="false"</code> prop。这显式地向 Vue 表明可以跳过对 CSS 过渡的自动探测。除了性能稍好一些之外，还可以防止 CSS 规则意外地干扰过渡效果。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在有了 <code>:css="false"</code> 后，我们就自己全权负责控制什么时候过渡结束了。这种情况下对于 <code>@enter</code> 和 <code>@leave</code> 钩子来说，回调函数 <code>done</code> 就是必须的。否则，钩子将被同步调用，过渡将立即完成。</p>
<p>这里是使用 <a href="https://greensock.com/" target="_blank" rel="noopener noreferrer">GreenSock 库</a>执行动画的一个示例，你也可以使用任何你想要的库，比如 <a href="https://animejs.com/" target="_blank" rel="noopener noreferrer">Anime.js</a> 或者 <a href="https://motion.dev/" target="_blank" rel="noopener noreferrer">Motion One</a>。</p>
<h2> 第三方库的使用</h2>
<h3> animate.css</h3>
<blockquote>
<p>https://animate.style/</p>
</blockquote>
<ul>
<li>如果我们手动一个个来编写这些动画，那么效率是比较低的，所以在开发中我们可能会引用一些第三方库的动画库， 比如animate.css。</li>
<li>Animate.css是一个已经<strong>准备好的、跨平台的</strong>动画库为我们的web项目，对于强调、主页、滑动、注意力引导 非常有用；</li>
</ul>
<p><strong>如何使用?</strong></p>
<ul>
<li>
<p>安装animate.css：</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>在main.js中导入animate.css：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>接下来在使用的时候我们有两种用法：</p>
<ul>
<li>用法一：直接使用animate库中定义的 keyframes 动画；</li>
<li>用法二：直接使用animate库提供给我们的类；</li>
</ul>
</li>
<li>
<p>使用参考: <a href="https://cn.vuejs.org/guide/built-ins/transition.html#custom-transition-classes" target="_blank" rel="noopener noreferrer">自定义过渡 class</a></p>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> gsap</h3>
<blockquote>
<p>https://gsap.com/docs/v3/Installation/</p>
<p>https://gsap.framer.wiki/stated -- 中文文档</p>
</blockquote>
<ul>
<li>某些情况下我们希望通过JavaScript来实现一些动画的效果，这个时候我们可以选择使用gsap库来完成。</li>
<li>什么是<code>gsap</code>呢？
<ul>
<li><code>GSAP</code>是<code>The GreenSock Animation</code></li>
<li><code>latform</code>（<code>GreenSock</code>动画平台）的缩写；</li>
</ul>
</li>
<li>它可以通过JavaScript为CSS属性、SVG、Canvas等设置动画，并且是浏览器兼容的；</li>
</ul>
<p><strong>如何使用</strong></p>
<ul>
<li>安装</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>调用 api</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>enter</code>函数接收两个参数：<code>el</code>和<code>done</code>。<code>el</code>是正在进入的元素，<code>done</code>是一个在进入过渡完成时应该被调用的函数。</li>
<li><code>onComplete: done</code>部分在动画完成时调用<code>done</code>函数。这是必要的，以便让Vue知道过渡已经完成。如果不调用<code>done</code>，Vue可能无法正确地确定过渡的结束，这可能会导致意外的行为。</li>
<li>在使用仅由 JavaScript 执行的动画时，最好是添加一个 <code>:css="false"</code> prop。这显式地向 Vue 表明可以跳过对 CSS 过渡的自动探测。除了性能稍好一些之外，还可以防止 CSS 规则意外地干扰过渡效果。</li>
</ul>
<h3> gsap 数字递增效果</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 认识列表的过渡</h2>
<ul>
<li>目前为止，过渡动画我们只要是针对单个元素或者组件的：
<ul>
<li>要么是单个节点；</li>
<li>要么是同一时间渲染多个节点中的一个；</li>
</ul>
</li>
<li>那么如果希望渲染的是一个列表，并且该列表中添加删除数据也希望有动画执行呢？
<ul>
<li>这个时候我们要使用 组件来完成；</li>
</ul>
</li>
<li>使用 有如下的特点：
<ul>
<li>默认情况下，它不会渲染一个元素的包裹器，但是你可以指定一个元素并以 tag attribute 进行渲染；</li>
<li>过渡模式不可用，因为我们不再相互切换特有的元素；</li>
<li>内部元素总是需要提供唯一的 key attribute 值；</li>
<li>CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身；</li>
</ul>
</li>
</ul>
<h3> 基本使用</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>methods</code>对象定义了四个方法：</p>
<ul>
<li><code>addNum</code>方法在<code>numbers</code>数组的随机位置插入一个新的数字，然后<code>numCounter</code>加1。</li>
<li><code>removeNum</code>方法从<code>numbers</code>数组的随机位置删除一个数字。</li>
<li><code>shuffleNum</code>方法使用lodash的<code>shuffle</code>函数打乱<code>numbers</code>数组的顺序。</li>
<li><code>randomIndex</code>方法返回一个<code>numbers</code>数组的随机索引</li>
</ul>
<h3> 列表过渡的移动动画</h3>
<p>在上面的案例中虽然新增的或者删除的节点是有动画的，但是对于哪些其他需要移动的节点是没有动画的：</p>
<ul>
<li>我们可以通过使用一个新增的 v-move 的class来完成动画；</li>
<li>它会在元素改变位置的过程中应用；</li>
<li>像之前的名字一样，我们可以通过name来自定义前缀;</li>
</ul>
<blockquote>
<p><code>&lt;TransitionGroup&gt;</code> 支持通过 CSS transform 控制移动效果。当一个子节点在屏幕上的位置在更新之后发生变化时，它会被添加一个使其位移的 CSS class (基于 <code>name</code> attribute 推导，或使用 <code>move-class</code> prop 显式配置)。如果使其位移的 class 被添加时 CSS 的 <code>transform</code> 属性是“可过渡的”，那么该元素会基于 <a href="https://aerotwist.com/blog/flip-your-animations/" target="_blank" rel="noopener noreferrer">FLIP 技巧</a>平滑地到达动画终点。</p>
<p>https://cn.vuejs.org/api/built-in-components.html#transitiongroup</p>
</blockquote>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 演练 =&gt; 列表的交替动画</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202312111414504.png" type="image/png"/>
    </item>
    <item>
      <title>生命周期</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F..html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F..html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">生命周期</source>
      <description>什么是生命周期? 什么是生命周期呢？ 每个组件都可能会经历从创建、挂载、更新、卸载等一系列的过程； 在这个过程中的某一个阶段，用于可能会想要添加一些属于自己的代码逻辑（比如组件创建完后就请求一些服 务器数据）； 生命周期函数： 生命周期函数是一些钩子函数，在某个时间会被Vue源码内部进行回调； 通过对生命周期函数的回调，我们可以知道目前组件正在经历什么阶段； 那么我们就可以在该生命周期中编写属于自己的逻辑代码了；</description>
      <pubDate>Fri, 08 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是生命周期?</h2>
<p>什么是生命周期呢？</p>
<ul>
<li>每个组件都可能会经历从创建、挂载、更新、卸载等一系列的过程；</li>
<li>在这个过程中的某一个阶段，用于可能会想要添加一些属于自己的代码逻辑（比如组件创建完后就请求一些服 务器数据）；</li>
</ul>
<p>生命周期函数：</p>
<ul>
<li>生命周期函数是一些钩子函数，在某个时间会被Vue源码内部进行回调；</li>
<li>通过对生命周期函数的回调，我们可以知道目前组件正在经历什么阶段；</li>
<li>那么我们就可以在该生命周期中编写属于自己的逻辑代码了；</li>
</ul>
<h3> <a href="https://cn.vuejs.org/guide/essentials/lifecycle.html#registering-lifecycle-hooks" target="_blank" rel="noopener noreferrer">注册周期钩子</a></h3>
<p>举例来说，<code>mounted</code> 钩子可以用来在组件完成初始渲染并创建 DOM 节点后运行代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有其他一些钩子，会在实例生命周期的不同阶段被调用，最常用的是 <a href="https://cn.vuejs.org/api/options-lifecycle.html#mounted" target="_blank" rel="noopener noreferrer"><code>mounted</code></a>、<a href="https://cn.vuejs.org/api/options-lifecycle.html#updated" target="_blank" rel="noopener noreferrer"><code>updated</code></a> 和 <a href="https://cn.vuejs.org/api/options-lifecycle.html#unmounted" target="_blank" rel="noopener noreferrer"><code>unmounted</code></a>。</p>
<p>所有生命周期钩子函数的 <code>this</code> 上下文都会自动指向当前调用它的组件实例。注意：避免用箭头函数来定义生命周期钩子，因为如果这样的话你将无法在函数中通过 <code>this</code> 获取组件实例。</p>
<h2> 组件的生命周期</h2>
<blockquote>
<p>https://cn.vuejs.org/api/options-lifecycle.html#options-lifecycle</p>
</blockquote>
<ol>
<li><code>beforeCreate( )</code>——准备创建</li>
<li><code>created( )</code>——创建完成</li>
<li><code>beforeMount( )</code>—挂载之前</li>
<li><code>mounted( )</code>——挂载完成</li>
<li><code>beforeUpdate( )</code>——更新之前</li>
<li><code>updated( )</code>——更新完成</li>
<li><code>activated( )</code>——当组件在 keep-alive 内被切换的时候它的 monnted( ) 被取代为activated</li>
<li><code>deactivated( )</code>——当组件在 keep-alive 内被切换的时候它的 unmonnted( ) 被取代为deactivated</li>
<li><code>beforeUnmount( )</code>—卸载之前</li>
<li><code>unmounted( )</code>——卸载完成</li>
<li><code>errorCaptured</code>——返回子孙组件中的错误</li>
<li><code>renderTracked</code>——虚拟 DOM 重新渲染时调用。接收 <code>debugger event</code> 作为参数。告诉你哪个操作跟踪了组件以及该操作的目标对象和键。</li>
<li><code>renderTiggered</code>——虚拟 DOM 重新渲染被触发时调用。接收 <code>debugger event</code> 作为参数。告诉你是什么操作触发了重新渲染，以及该操作的目标对象和键</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202312082224668.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202312082224668.png" type="image/png"/>
    </item>
    <item>
      <title>动态组件</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/components/%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/components/%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">动态组件</source>
      <description>切换组件案例 比如我们现在想要实现了一个功能： 点击一个tab-bar，切换不同的组件显示； 这个案例我们可以通过两种不同的实现思路来实现： 方式一：通过v-if来判断，显示不同的组件； 方式二：动态组件的方式；</description>
      <pubDate>Fri, 08 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 切换组件案例</h2>
<ul>
<li>
<p>比如我们现在想要实现了一个功能：</p>
<ul>
<li>点击一个tab-bar，切换不同的组件显示；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312091618269.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>这个案例我们可以通过两种不同的实现思路来实现：</p>
<ul>
<li>方式一：通过v-if来判断，显示不同的组件；</li>
<li>方式二：动态组件的方式；</li>
</ul>
</li>
</ul>
<h3> v-if显示不同的组件</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 动态组件</h2>
<p>Vue.js 的动态组件是指可以根据不同的数据渲染不同的组件的功能。你可以使用 Vue.js 的 <code>&lt;component&gt; </code>元素来实现动态组件。</p>
<p>例如，你可以在父组件中定义一个数据属性，根据这个属性的值来决定渲染哪个子组件。然后，在模板中使用 <code>&lt;component&gt; </code>元素，并将该数据属性绑定到 is 属性上，这样就可以动态地渲染不同的子组件了。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 动态组件的传值</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> keep-alive</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/built-ins/keep-alive.html#keepalive</p>
</blockquote>
<p><code>&lt;KeepAlive&gt;</code> 是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。</p>
<p>默认情况下，一个组件实例在被替换掉后会被销毁。这会导致它丢失其中所有已变化的状态——当这个组件再一次被显示时，会创建一个只带有初始状态的新实例。</p>
<p>在切换时创建新的组件实例通常是有意义的，但在这个例子中，我们的确想要组件能在被“切走”的时候保留它们的状态。要解决这个问题，我们可以用 <code>&lt;KeepAlive&gt;</code> 内置组件将这些动态组件包装起来：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>在 <a href="https://cn.vuejs.org/guide/essentials/component-basics.html#in-dom-template-parsing-caveats" target="_blank" rel="noopener noreferrer">DOM 内模板</a>中使用时，它应该被写为 <code>&lt;keep-alive&gt;</code>。</p>
</blockquote>
<h3> 包含/排除</h3>
<p><code>&lt;KeepAlive&gt;</code> 默认会缓存内部的所有组件实例，但我们可以通过 <code>include</code> 和 <code>exclude</code> prop 来定制该行为。这两个 prop 的值都可以是一个以英文逗号分隔的字符串、一个正则表达式，或是包含这两种类型的一个数组：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>它会根据组件的 <a href="https://cn.vuejs.org/api/options-misc.html#name" target="_blank" rel="noopener noreferrer"><code>name</code></a> 选项进行匹配，所以组件如果想要条件性地被 <code>KeepAlive</code> 缓存，就必须显式声明一个 <code>name</code> 选项。</p>
</blockquote>
<h3> 最大缓存实例数</h3>
<p>我们可以通过传入 <code>max</code> prop 来限制可被缓存的最大组件实例数。<code>&lt;KeepAlive&gt;</code> 的行为在指定了 <code>max</code> 后类似一个 <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)" target="_blank" rel="noopener noreferrer">LRU 缓存</a>：如果缓存的实例数量即将超过指定的那个最大数量，则最久没有被访问的缓存实例将被销毁，以便为新的实例腾出空间。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202312091618269.png" type="image/png"/>
    </item>
    <item>
      <title>异步组件</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/components/%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/components/%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">异步组件</source>
      <description>https://cn.vuejs.org/guide/components/async.html#async-components 基本用法 在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 defineAsyncComponent 方法来实现此功能：</description>
      <pubDate>Fri, 08 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>https://cn.vuejs.org/guide/components/async.html#async-components</p>
</blockquote>
<h2> 基本用法</h2>
<p>在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 <a href="https://cn.vuejs.org/api/general.html#defineasynccomponent" target="_blank" rel="noopener noreferrer"><code>defineAsyncComponent</code></a> 方法来实现此功能：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，<code>defineAsyncComponent</code> 方法接收一个返回 Promise 的加载函数。这个 Promise 的 <code>resolve</code> 回调方法应该在从服务器获得组件定义时调用。你也可以调用 <code>reject(reason)</code> 表明加载失败。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import" target="_blank" rel="noopener noreferrer">ES 模块动态导入</a>也会返回一个 Promise，所以多数情况下我们会将它和 <code>defineAsyncComponent</code> 搭配使用。类似 Vite 和 Webpack 这样的构建工具也支持此语法 (并且会将它们作为打包时的代码分割点)，因此我们也可以用它来导入 Vue 单文件组件：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后得到的 <code>AsyncComp</code> 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。</p>
<ul>
<li>
<p><code>defineAsyncComponent</code>接受两种类型的参数：</p>
<ul>
<li>类型一：工厂函数，该工厂函数需要返回一个Promise对象；</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>类型二：接受一个对象类型，对异步函数进行配置；</li>
<li>异步操作不可避免地会涉及到加载和错误状态，因此 <code>defineAsyncComponent()</code> 也支持在高级选项中处理这些状态：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得很快，加载组件和最终组件之间的替换太快可能产生闪烁，反而影响用户感受。</li>
<li>如果提供了一个报错组件，则它会在加载器函数返回的 Promise 抛错时被渲染。你还可以指定一个超时时间，在请求耗时超过指定时间时也会渲染报错组件。</li>
</ul>
</li>
</ul>
<h2> 搭配 Suspense 使用</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/built-ins/suspense.html</p>
<p><code>&lt;Suspense&gt;</code> 是一项实验性功能。它不一定会最终成为稳定功能，并且在稳定之前相关 API 也可能会发生变化。</p>
</blockquote>
<p><code>&lt;Suspense&gt;</code> 是一个内置组件，用来在组件树中协调对异步依赖的处理。它让我们可以在组件树上层等待下层的多个嵌套异步依赖项解析完成，并可以在等待时渲染一个加载状态。</p>
<p><code>&lt;Suspense&gt;</code> 组件有两个插槽：<code>#default</code> 和 <code>#fallback</code>。两个插槽都只允许<strong>一个</strong>直接子节点。在可能的时候都将显示默认槽中的节点。否则将显示后备槽中的节点。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在初始渲染时，<code>&lt;Suspense&gt;</code> 将在内存中渲染其默认的插槽内容。如果在这个过程中遇到任何异步依赖，则会进入<strong>挂起</strong>状态。在挂起状态期间，展示的是后备内容。当所有遇到的异步依赖都完成后，<code>&lt;Suspense&gt;</code> 会进入<strong>完成</strong>状态，并将展示出默认插槽的内容。</p>
<p>如果在初次渲染时没有遇到异步依赖，<code>&lt;Suspense&gt;</code> 会直接进入完成状态。</p>
<p>进入完成状态后，只有当默认插槽的根节点被替换时，<code>&lt;Suspense&gt;</code> 才会回到挂起状态。组件树中新的更深层次的异步依赖<strong>不会</strong>造成 <code>&lt;Suspense&gt;</code> 回退到挂起状态。</p>
<p>发生回退时，后备内容不会立即展示出来。相反，<code>&lt;Suspense&gt;</code> 在等待新内容和异步依赖完成时，会展示之前 <code>#default</code> 插槽的内容。这个行为可以通过一个 <code>timeout</code> prop 进行配置：在等待渲染新内容耗时超过 <code>timeout</code> 之后，<code>&lt;Suspense&gt;</code> 将会切换为展示后备内容。若 <code>timeout</code> 值为 <code>0</code> 将导致在替换默认内容时立即显示后备内容。</p>
<h3> 和其他组件结合</h3>
<p>我们常常会将 <code>&lt;Suspense&gt;</code> 和 <a href="https://cn.vuejs.org/guide/built-ins/keep-alive.html" target="_blank" rel="noopener noreferrer"><code>](https://cn.vuejs.org/guide/built-ins/transition.html)、[</code></a> 等组件结合。要保证这些组件都能正常工作，嵌套的顺序非常重要。</p>
<p>另外，这些组件都通常与 <a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">Vue Router</a> 中的 <code>&lt;RouterView&gt;</code> 组件结合使用。</p>
<p>下面的示例展示了如何嵌套这些组件，使它们都能按照预期的方式运行。若想组合得更简单，你也可以删除一些你不需要的组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Vue Router 使用动态导入对<a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noopener noreferrer">懒加载组件</a>进行了内置支持。这些与异步组件不同，目前他们不会触发 <code>&lt;Suspense&gt;</code>。但是，它们仍然可以有异步组件作为后代，这些组件可以照常触发 <code>&lt;Suspense&gt;</code>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>插槽</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/components/%E6%8F%92%E6%A7%BD.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/components/%E6%8F%92%E6%A7%BD.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">插槽</source>
      <description>https://cn.vuejs.org/guide/components/slots.html#slots 认识组件 Slot 在开发中，我们会经常封装一个个可复用的组件： 前面我们会通过props传递给组件一些数据，让组件来进行展示； 但是为了让这个组件具备更强的通用性，我们不能将组件中的内容限制为固定的div、span等等这些元素； 比如某种情况下我们使用组件，希望组件显示的是一个按钮，某种情况下我们使用组件希望显示的是一张图片； 我们应该让使用者可以决定某一块区域到底存放什么内容和元素； 举个栗子：假如我们定制一个通用的导航组件 - NavBar 这个组件分成三块区域：左边-中间-右边，每块区域的内容是不固定； 左边区域可能显示一个菜单图标，也可能显示一个返回按钮，可能什么都不显示； 中间区域可能显示一个搜索框，也可能是一个列表，也可能是一个标题，等等； 右边可能是一个文字，也可能是一个图标，也可能什么都不显示；</description>
      <pubDate>Tue, 05 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>https://cn.vuejs.org/guide/components/slots.html#slots</p>
</blockquote>
<h2> 认识组件  Slot</h2>
<ul>
<li>在开发中，我们会经常封装一个个可复用的组件：
<ul>
<li>前面我们会通过props传递给组件一些数据，让组件来进行展示；</li>
<li>但是为了让这个组件<strong>具备更强的通用性</strong>，我们<strong>不能将组件中的内容限制为固定的div、span等等这些元素</strong>；</li>
<li>比如某种情况下我们使用组件，希望组件显示的是一个按钮，某种情况下我们使用组件希望显示的是一张图片；</li>
<li>我们应该让使用者可以<strong>决定某一块区域到底存放什么内容和元素</strong>；</li>
</ul>
</li>
<li>举个栗子：假如我们定制一个通用的导航组件 - <code>NavBar</code>
<ul>
<li>这个组件分成三块区域：左边-中间-右边，每块区域的内容是不固定；</li>
<li>左边区域可能显示一个菜单图标，也可能显示一个返回按钮，可能什么都不显示；</li>
<li>中间区域可能显示一个搜索框，也可能是一个列表，也可能是一个标题，等等；</li>
<li>右边可能是一个文字，也可能是一个图标，也可能什么都不显示；</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312050058752.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>
<h2> 如何使用插槽slot？</h2>
<ul>
<li>这个时候我们就可以来定义插槽slot：
<ul>
<li>插槽的使用过程其实是抽取共性、预留不同；</li>
<li>我们会将共同的元素、内容依然在组件内进行封装；</li>
<li>同时会将不同的元素使用 slot 作为占位，让外部决定到底显示什么样的元素；</li>
</ul>
</li>
<li>如何使用slot呢？
<ul>
<li>Vue中将 元素作为承载分发内容的出口；</li>
<li>在封装组件中，使用特殊的元素就可以为封装组件开启一个插槽；</li>
<li>该插槽插入什么内容取决于父组件如何使用；</li>
</ul>
</li>
</ul>
<h2> 插槽的基本使用</h2>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>&lt;slot&gt;</code> 元素是一个<strong>插槽出口</strong> (slot outlet)，标示了父元素提供的<strong>插槽内容</strong> (slot content) 将在哪里被渲染。</p>
<figure><img src="https://qiniu.waite.wang/202312050109950.png" alt="image-20231205010910410" tabindex="0" loading="lazy"><figcaption>image-20231205010910410</figcaption></figure>
<p>通过使用插槽，<code>&lt;FancyButton&gt;</code> 仅负责渲染外层的 <code>&lt;button&gt;</code> (以及相应的样式)，而其内部的内容由父组件提供。</p>
<p>理解插槽的另一种方式是和下面的 JavaScript 函数作类比，其概念是类似的：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插槽内容可以是任意合法的模板内容，不局限于文本。例如我们可以传入多个元素，甚至是组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 插槽的默认内容</h3>
<p>在外部没有提供任何内容的情况下，可以为插槽指定默认内容。比如有这样一个 <code>&lt;SubmitButton&gt;</code> 组件：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们想在父组件没有提供任何插槽内容时在 <code>&lt;button&gt;</code> 内渲染“Submit”，只需要将“Submit”写在 <code>&lt;slot&gt;</code> 标签之间来作为默认内容：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，当我们在父组件中使用 <code>&lt;SubmitButton&gt;</code> 且没有提供任何插槽内容时：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>“Submit”将会被作为默认内容渲染：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但如果我们提供了插槽内容：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>那么被显式提供的内容会取代默认内容：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 多个插槽的效果</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312050117020.png" alt="image-20231205011717002" tabindex="0" loading="lazy"><figcaption>image-20231205011717002</figcaption></figure>
<h2> 具名插槽的使用</h2>
<p>有时在一个组件中包含多个插槽出口是很有用的。举例来说，在一个 <code>&lt;BaseLayout&gt;</code> 组件中，有如下模板：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于这种场景，<code>&lt;slot&gt;</code> 元素可以有一个特殊的 attribute <code>name</code>，用来给各个插槽分配唯一的 ID，以确定每一处要渲染的内容：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这类带 <code>name</code> 的插槽被称为具名插槽 (named slots)。没有提供 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会隐式地命名为“default”。</p>
<p>在父组件中使用 <code>&lt;BaseLayout&gt;</code> 时，我们需要一种方式将多个插槽内容传入到各自目标插槽的出口。此时就需要用到<strong>具名插槽</strong>了：</p>
<p>要为具名插槽传入内容，我们需要使用一个含 <code>v-slot</code> 指令的 <code>&lt;template&gt;</code> 元素，并将目标插槽的名字传给该指令：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>v-slot</code> 有对应的简写 <code>#</code>，因此 <code>&lt;template v-slot:header&gt;</code> 可以简写为 <code>&lt;template #header&gt;</code>。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。</p>
<figure><img src="https://qiniu.waite.wang/202312050120758.png" alt="image-20231205012048085" tabindex="0" loading="lazy"><figcaption>image-20231205012048085</figcaption></figure>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 JavaScript 函数来类比可能更有助于你来理解具名插槽：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 动态插槽名</h3>
<p>在Vue 3中，动态插槽名可以使用<code>v-slot</code>指令来实现。你可以将插槽名作为一个变量来传递给<code>v-slot</code>指令，以实现动态插槽名的效果。</p>
<p>例如，如果你有一个动态的插槽名变量<code>slotName</code>，你可以这样使用动态插槽名：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，<code>slotName</code>变量的值将作为插槽名来动态指定插槽的位置。</p>
<figure><img src="https://qiniu.waite.wang/202312050129225.png" alt="image-20231205012902405" tabindex="0" loading="lazy"><figcaption>image-20231205012902405</figcaption></figure>
<h2> 渲染作用域</h2>
<p>插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。举例来说：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的两个 <code>{{ message }}</code> 插值表达式渲染的内容都是一样的。</p>
<p>插槽内容<strong>无法访问</strong>子组件的数据。Vue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的词法作用域规则是一致的。换言之：</p>
<blockquote>
<p>父组件模板中的表达式只能访问父组件的作用域；子组件模板中的表达式只能访问子组件的作用域。</p>
</blockquote>
<h3> 作用域插槽</h3>
<p>然而在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。</p>
<p>我们也确实有办法这么做！可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当需要接收插槽 props 时，默认插槽和具名插槽的使用方式有一些小区别。下面我们将先展示默认插槽如何接受 props，通过子组件标签上的 <code>v-slot</code> 指令，直接接收到了一个插槽 props 对象：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202312050134291.png" alt="image-20231205013406501" tabindex="0" loading="lazy"><figcaption>image-20231205013406501</figcaption></figure>
<p>子组件传入插槽的 props 作为了 <code>v-slot</code> 指令的值，可以在插槽内的表达式中访问。</p>
<p>你可以将作用域插槽类比为一个传入子组件的函数。子组件会将相应的 props 作为参数传给它：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上，这已经和作用域插槽的最终代码编译结果、以及手动编写<a href="https://cn.vuejs.org/guide/extras/render-function.html" target="_blank" rel="noopener noreferrer">渲染函数</a>时使用作用域插槽的方式非常类似了。</p>
<p><code>v-slot="slotProps"</code> 可以类比这里的函数签名，和函数的参数类似，我们也可以在 <code>v-slot</code> 中使用解构：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 具名作用域插槽</h3>
<p>具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 <code>v-slot</code> 指令的值被访问到：<code>v-slot:name="slotProps"</code>。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 独占默认插槽的缩写</h4>
<ul>
<li>如果我们的插槽是默认插槽<code>default</code>，那么在使用的时候 <code>v-slot:default="slotProps"</code>可以简写为<code>v-slot=“slotProps”</code></li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312050153014.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>
<ul>
<li>并且如果我们的插槽只有默认插槽时，组件的标签可以被当做插槽的模板来使用，这样，我们就可以将 <code>v-slot</code> 直接用在组件上</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312050153237.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>
<h3> 默认插槽和具名插槽混合</h3>
<ul>
<li>但是，如果我们有默认插槽和具名插槽，那么按照完整的template来编写。</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312050153775.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>
<ul>
<li>只要出现多个插槽，请始终为所有的插槽使用完整的基于</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202312050154033.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202312050058752.png" type="image/png"/>
    </item>
    <item>
      <title>组件之间的通信</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/components/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/components/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">组件之间的通信</source>
      <description>[TOC] 认识组件的嵌套 在之前的案例中，我们只是创建了一个组件App； 如果我们一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护； 所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件； 再将这些组件组合嵌套在一起，最终形成我们的应用程序； 我们来分析一下下面代码的嵌套逻辑，假如我们将所有的代码逻辑都放到一个App.vue组件中： &amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;Header&amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt;NavBar&amp;lt;/h2&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;Banner&amp;lt;/h2&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;商品列表1&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;商品列表2&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;商品列表3&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;商品列表4&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;商品列表5&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;Footer&amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt;免责声明&amp;lt;/h2&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { }; &amp;lt;/script&amp;gt; &amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;</description>
      <pubDate>Mon, 27 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>[TOC]</p>
<h2> 认识组件的嵌套</h2>
<ul>
<li>在之前的案例中，我们只是创建了一个组件App；</li>
<li>如果我们一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护；</li>
<li>所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件；</li>
<li>再将这些组件组合嵌套在一起，最终形成我们的应用程序；</li>
</ul>
<blockquote>
<p>我们来分析一下下面代码的嵌套逻辑，假如我们将所有的代码逻辑都放到一个App.vue组件中：</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们会发现，将所有的代码逻辑全部放到一个组件中，代码是非常的臃肿和难以维护的。并且在真实开发中，我们会有更多的内容和代码逻辑，对于扩展性和可维护性来说都是非常差的。</p>
<p>所有，在真实的开发中，我们会对组件进行拆分，拆分成一个个功能的小组件。</p>
<h3> 组件的拆分</h3>
<p>如上代码, 我们可以按照如下的方式进行拆分：</p>
<ul>
<li>
<p>App.vue</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Header.vue组件</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Main.vue组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Banner.vue组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>ProductList组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Footer.vue组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>按照如上的拆分方式后，我们开发对应的逻辑只需要去对应的组件编写就可。</p>
</li>
</ul>
<h2> 组件的通信</h2>
<p>上面的嵌套逻辑如下，它们存在如下关系：</p>
<ul>
<li>App组件是Header、Main、Footer组件的父组件；</li>
<li>Main组件是Banner、ProductList组件的父组件；</li>
</ul>
<p>在开发过程中，我们会经常遇到需要组件之间相互进行通信：</p>
<ul>
<li>比如App可能使用了多个Header，每个地方的Header展示的内容不同，那么我们就需要使用者传递给Header一些数据，让其进行展示；</li>
<li>又比如我们在Main中一次性请求了Banner数据和ProductList数据，那么就需要传递给他们来进行展示；</li>
<li>也可能是子组件中发生了事件，需要有父组件来完成某些操作，那就需要子组件向父组件传递事件；</li>
</ul>
<blockquote>
<p>父子组件之间如何进行通信呢？</p>
<ul>
<li>父组件传递给子组件：通过props属性；</li>
<li>子组件传递给父组件：通过$emit触发事件；</li>
</ul>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202311240000049.png" alt="image-20231124000011715" tabindex="0" loading="lazy"><figcaption>image-20231124000011715</figcaption></figure>
<h3> 父传子</h3>
<p>在开发中很常见的就是父子组件之间通信，比如父组件有一些数据，需要子组件来进行展示：</p>
<ul>
<li>这个时候我们可以通过props来完成组件之间的通信；</li>
</ul>
<blockquote>
<p>什么是 props?</p>
<p>在Vue3中，props是一种用于向组件传递数据的机制。它允许父组件向子组件传递数据，并在子组件中使用这些数据。</p>
<p>在Vue3中，每个组件都可以定义自己的props，并指定每个prop的类型、默认值和其他验证规则。当父组件向子组件传递数据时，子组件可以使用这些props来访问传递过来的数据。</p>
</blockquote>
<h4> props 的定义</h4>
<p>在Vue3中，props可以使用两种方式来定义：</p>
<ol>
<li>字符串数组，数组中的字符串就是attribute的名称；</li>
<li>对象类型，对象类型我们可以在指定attribute名称的同时，指定它需要传递的类型、是否是必须的、默认值等等；</li>
</ol>
<h5> 字符串数组</h5>
<p>使用字符串数组的方式，可以简单地指定需要接收的属性名称。在这种情况下，属性类型默认为<code>any</code>。</p>
<p>在下面的示例中，父组件使用<code>message="Hello from parent"将message</code>属性作为字符串传递给子组件。在子组件中，使用<code>props</code>选项并传递一个字符串数组来定义<code>message</code>属性。这样子组件就可以使用<code>message</code>属性来访问父组件传递过来的数据了。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 对象类型</h5>
<p>使用对象类型的方式，可以更详细地指定需要接收的属性名称、类型、是否必须、默认值等等。</p>
<p>在下面的示例中，父组件使用<code>:message="parentMessage"将parentMessage</code>属性作为字符串传递给子组件。在子组件中，使用<code>props</code>选项并传递一个对象来定义<code>message</code>属性。在这个对象中，我们指定了<code>type</code>为字符串、<code>required</code>为true、<code>default</code>为'Hello from child'、以及一个自定义的验证函数。</p>
<p>这样子组件就可以使用<code>message</code>属性来访问父组件传递过来的数据了。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 其他</h5>
<ol>
<li><strong>Type的类型都可以是哪些？</strong>
<ul>
<li>String：用于指定字符串类型的属性。</li>
<li>Number：用于指定数字类型的属性。</li>
<li>Boolean：用于指定布尔类型的属性。</li>
<li>Array：用于指定数组类型的属性。</li>
<li>Object：用于指定对象类型的属性。</li>
<li>Date：用于指定日期类型的属性。</li>
<li>Function：用于指定函数类型的属性。</li>
<li>Symbol：用于指定符号类型的属性。</li>
</ul>
</li>
<li><strong>对象类型的其他写法</strong></li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li><strong>Prop 的大小写命名(camelCase vs kebab-case)</strong></li>
</ol>
<p>在Vue.js中，你可以使用驼峰式(camelCase)或短横线分隔(kebab-case)来命名你的props。然而，由于HTML属性不区分大小写，所以在模板中使用驼峰式命名的props时，需要转换为短横线分隔的形式。</p>
<p>例如，如果你在JavaScript中定义了一个名为<code>myProp</code>的prop，你需要在模板中使用<code>my-prop</code>来引用它。</p>
<p>这是一个例子：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，父组件将其数据<code>parentValue</code>传递给子组件的<code>myProp</code> prop。注意在父组件模板中，我们使用短横线分隔的形式<code>:my-prop</code>，而在子组件的JavaScript代码中，我们使用驼峰式命名<code>myProp</code>, 这也是官方推荐的写法。</p>
<h4> 非 Prop 的Attribute</h4>
<p>在Vue.js中，非prop的attribute是指那些被绑定到组件，但没有对应的prop定义的attribute。这些attribute会被添加到组件的根元素上。</p>
<p>例如，如果你有一个组件，它的模板是一个<code>&lt;div&gt;</code>元素，然后你在使用这个组件时添加了一个<code>class</code>或<code>style</code>属性，那么这个<code>class</code>或<code>style</code>属性就会被添加到<code>&lt;div&gt;</code>元素上，即使你没有在组件的props中定义它们。</p>
<p>这是一个例子：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>id</code>, <code>class</code>和<code>style</code>就是非prop的attribute。它们会被添加到<code>MyComponent</code>的根元素上。</p>
<h4> 禁用 Attribute 继承</h4>
<p>如果你不希望非prop的attribute被添加到根元素上，你可以在组件中定义一个<code>inheritAttrs: false</code>选项。这样，非prop的attribute将只能通过<code>$attrs</code>变量来访问，而不会被添加到根元素上。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>禁用attribute继承的常见情况是需要将attribute应用于根元素之外的其他元素；</li>
<li>我们可以通过 <code>$attrs</code>来访问所有的 <code>非props的attribute</code>；</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>如上, <code>&lt;h2&gt;</code> 仍然会继承非prop的attribute</li>
</ul>
<h4> 多个根节点的attribute</h4>
<blockquote>
<p>多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须手动的指定要绑定到哪一个属性上：</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 子传父</h3>
<p>什么情况下子组件需要传递内容到父组件呢？</p>
<ul>
<li>当子组件有一些事件发生的时候，比如在组件中发生了点击，父组件需要切换内容；</li>
<li>子组件有一些内容想要传递给父组件的时候；</li>
</ul>
<p>我们如何完成上面的操作呢？</p>
<ul>
<li>首先，我们需要在子组件中定义好在某些情况下触发的事件名称；</li>
<li>其次，在父组件中以v-on的方式传入要监听的事件名称，并且绑定到对应的方法中；</li>
<li>最后，在子组件中发生某个事件的时候，根据事件名称触发对应的事件；</li>
</ul>
<blockquote>
<p>以下是一个简单的示例</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>emits</code></h4>
<blockquote>
<p>当使用Vue 3时，你可以使用emits选项来对子组件触发的自定义事件进行校验: 使用<code>emits</code>选项可以提供类型检查和错误提示，确保子组件只触发被允许的自定义事件。这有助于提高代码的可维护性和可靠性。以下是一个示例：</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 非父子组件之间的通信</h2>
<p>在开发中，我们构建了组件树之后，除了父子组件之间的通信之外，还会有非父子组件之间的通信。</p>
<p>这里我们主要讲两种方式：</p>
<ul>
<li>Provide/Inject</li>
<li>Mitt全局事件总线；</li>
</ul>
<h3> Provide/Inject</h3>
<p>Provide/Inject用于非父子组件之间共享数据：</p>
<ul>
<li>比如有一些深度嵌套的组件，子组件想要获取父组件的部分内容；</li>
<li>在这种情况下，如果我们仍然将props沿着组件链逐级传递下去，就会非常的麻烦；</li>
</ul>
<p>对于这种情况下，我们可以使用 <code>Provide</code> 和 <code>Inject</code> ：</p>
<ul>
<li>无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者；</li>
<li>父组件有一个 <code>provide</code> 选项来提供数据；</li>
<li>子组件有一个 <code>inject</code> 选项来开始使用这些数据；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311301958291.png" alt="image-20231130195805276" tabindex="0" loading="lazy"><figcaption>image-20231130195805276</figcaption></figure>
<p>实际上，你可以将依赖注入看作是“long range props”，除了：</p>
<ul>
<li>父组件不需要知道哪些子组件使用它 <code>provide </code>的 <code>property</code></li>
<li>子组件不需要知道 <code>inject </code>的 <code>property </code>来自哪里</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>当然, 我们也可以通过 this 获取到当前组件定义的 data</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 全局事件总线 mitt 库</h3>
<p>在 Vue 3 中，全局事件总线是一种用于在不同组件之间进行通信的机制。它允许你在任何组件中触发事件并在其他组件中监听和响应这些事件。</p>
<blockquote>
<p>https://cn.vuejs.org/api/application.html#app-config-globalproperties</p>
</blockquote>
<p>在 Vue 3 中，可以使用 <code>app.config.globalProperties</code> 来创建一个全局事件总线。通过将事件总线实例添加到全局属性中，你可以在任何组件中访问它，从而实现跨组件的事件通信。</p>
<p>以下是一个示例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建一个名为 <code>createEventBus</code> 的函数来创建事件总线实例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，你可以在任何组件中使用 <code>$bus</code>来触发事件和监听事件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，当点击按钮时，组件 A 使用<code> $bus.emit</code> 发送了一个名为 <code>'message'</code> 的事件，并传递了消息 <code>'Hello from component A'</code>。组件 B 使用 ​<code>$bus.on</code> 监听了 <code>'message' </code>事件，并将接收到的消息显示在页面上。</p>
<p>通过全局事件总线，你可以在不同组件之间进行简单而方便的通信，而无需显式地通过 props 或其他方式传递数据。
[TOC]</p>
<h2> 认识组件的嵌套</h2>
<ul>
<li>在之前的案例中，我们只是创建了一个组件App；</li>
<li>如果我们一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护；</li>
<li>所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件；</li>
<li>再将这些组件组合嵌套在一起，最终形成我们的应用程序；</li>
</ul>
<blockquote>
<p>我们来分析一下下面代码的嵌套逻辑，假如我们将所有的代码逻辑都放到一个App.vue组件中：</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们会发现，将所有的代码逻辑全部放到一个组件中，代码是非常的臃肿和难以维护的。并且在真实开发中，我们会有更多的内容和代码逻辑，对于扩展性和可维护性来说都是非常差的。</p>
<p>所有，在真实的开发中，我们会对组件进行拆分，拆分成一个个功能的小组件。</p>
<h3> 组件的拆分</h3>
<p>如上代码, 我们可以按照如下的方式进行拆分：</p>
<ul>
<li>
<p>App.vue</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Header.vue组件</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Main.vue组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Banner.vue组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>ProductList组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Footer.vue组件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>按照如上的拆分方式后，我们开发对应的逻辑只需要去对应的组件编写就可。</p>
</li>
</ul>
<h2> 组件的通信</h2>
<p>上面的嵌套逻辑如下，它们存在如下关系：</p>
<ul>
<li>App组件是Header、Main、Footer组件的父组件；</li>
<li>Main组件是Banner、ProductList组件的父组件；</li>
</ul>
<p>在开发过程中，我们会经常遇到需要组件之间相互进行通信：</p>
<ul>
<li>比如App可能使用了多个Header，每个地方的Header展示的内容不同，那么我们就需要使用者传递给Header一些数据，让其进行展示；</li>
<li>又比如我们在Main中一次性请求了Banner数据和ProductList数据，那么就需要传递给他们来进行展示；</li>
<li>也可能是子组件中发生了事件，需要有父组件来完成某些操作，那就需要子组件向父组件传递事件；</li>
</ul>
<blockquote>
<p>父子组件之间如何进行通信呢？</p>
<ul>
<li>父组件传递给子组件：通过props属性；</li>
<li>子组件传递给父组件：通过$emit触发事件；</li>
</ul>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202311240000049.png" alt="image-20231124000011715" tabindex="0" loading="lazy"><figcaption>image-20231124000011715</figcaption></figure>
<h3> 父传子</h3>
<p>在开发中很常见的就是父子组件之间通信，比如父组件有一些数据，需要子组件来进行展示：</p>
<ul>
<li>这个时候我们可以通过props来完成组件之间的通信；</li>
</ul>
<blockquote>
<p>什么是 props?</p>
<p>在Vue3中，props是一种用于向组件传递数据的机制。它允许父组件向子组件传递数据，并在子组件中使用这些数据。</p>
<p>在Vue3中，每个组件都可以定义自己的props，并指定每个prop的类型、默认值和其他验证规则。当父组件向子组件传递数据时，子组件可以使用这些props来访问传递过来的数据。</p>
</blockquote>
<h4> props 的定义</h4>
<p>在Vue3中，props可以使用两种方式来定义：</p>
<ol>
<li>字符串数组，数组中的字符串就是attribute的名称；</li>
<li>对象类型，对象类型我们可以在指定attribute名称的同时，指定它需要传递的类型、是否是必须的、默认值等等；</li>
</ol>
<h5> 字符串数组</h5>
<p>使用字符串数组的方式，可以简单地指定需要接收的属性名称。在这种情况下，属性类型默认为<code>any</code>。</p>
<p>在下面的示例中，父组件使用<code>message="Hello from parent"将message</code>属性作为字符串传递给子组件。在子组件中，使用<code>props</code>选项并传递一个字符串数组来定义<code>message</code>属性。这样子组件就可以使用<code>message</code>属性来访问父组件传递过来的数据了。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 对象类型</h5>
<p>使用对象类型的方式，可以更详细地指定需要接收的属性名称、类型、是否必须、默认值等等。</p>
<p>在下面的示例中，父组件使用<code>:message="parentMessage"将parentMessage</code>属性作为字符串传递给子组件。在子组件中，使用<code>props</code>选项并传递一个对象来定义<code>message</code>属性。在这个对象中，我们指定了<code>type</code>为字符串、<code>required</code>为true、<code>default</code>为'Hello from child'、以及一个自定义的验证函数。</p>
<p>这样子组件就可以使用<code>message</code>属性来访问父组件传递过来的数据了。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 其他</h5>
<ol>
<li><strong>Type的类型都可以是哪些？</strong>
<ul>
<li>String：用于指定字符串类型的属性。</li>
<li>Number：用于指定数字类型的属性。</li>
<li>Boolean：用于指定布尔类型的属性。</li>
<li>Array：用于指定数组类型的属性。</li>
<li>Object：用于指定对象类型的属性。</li>
<li>Date：用于指定日期类型的属性。</li>
<li>Function：用于指定函数类型的属性。</li>
<li>Symbol：用于指定符号类型的属性。</li>
</ul>
</li>
<li><strong>对象类型的其他写法</strong></li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li><strong>Prop 的大小写命名(camelCase vs kebab-case)</strong></li>
</ol>
<p>在Vue.js中，你可以使用驼峰式(camelCase)或短横线分隔(kebab-case)来命名你的props。然而，由于HTML属性不区分大小写，所以在模板中使用驼峰式命名的props时，需要转换为短横线分隔的形式。</p>
<p>例如，如果你在JavaScript中定义了一个名为<code>myProp</code>的prop，你需要在模板中使用<code>my-prop</code>来引用它。</p>
<p>这是一个例子：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，父组件将其数据<code>parentValue</code>传递给子组件的<code>myProp</code> prop。注意在父组件模板中，我们使用短横线分隔的形式<code>:my-prop</code>，而在子组件的JavaScript代码中，我们使用驼峰式命名<code>myProp</code>, 这也是官方推荐的写法。</p>
<h4> 非 Prop 的Attribute</h4>
<p>在Vue.js中，非prop的attribute是指那些被绑定到组件，但没有对应的prop定义的attribute。这些attribute会被添加到组件的根元素上。</p>
<p>例如，如果你有一个组件，它的模板是一个<code>&lt;div&gt;</code>元素，然后你在使用这个组件时添加了一个<code>class</code>或<code>style</code>属性，那么这个<code>class</code>或<code>style</code>属性就会被添加到<code>&lt;div&gt;</code>元素上，即使你没有在组件的props中定义它们。</p>
<p>这是一个例子：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>id</code>, <code>class</code>和<code>style</code>就是非prop的attribute。它们会被添加到<code>MyComponent</code>的根元素上。</p>
<h4> 禁用 Attribute 继承</h4>
<p>如果你不希望非prop的attribute被添加到根元素上，你可以在组件中定义一个<code>inheritAttrs: false</code>选项。这样，非prop的attribute将只能通过<code>$attrs</code>变量来访问，而不会被添加到根元素上。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>禁用attribute继承的常见情况是需要将attribute应用于根元素之外的其他元素；</li>
<li>我们可以通过 <code>$attrs</code>来访问所有的 <code>非props的attribute</code>；</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>如上, <code>&lt;h2&gt;</code> 仍然会继承非prop的attribute</li>
</ul>
<h4> 多个根节点的attribute</h4>
<blockquote>
<p>多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须手动的指定要绑定到哪一个属性上：</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 子传父</h3>
<p>什么情况下子组件需要传递内容到父组件呢？</p>
<ul>
<li>当子组件有一些事件发生的时候，比如在组件中发生了点击，父组件需要切换内容；</li>
<li>子组件有一些内容想要传递给父组件的时候；</li>
</ul>
<p>我们如何完成上面的操作呢？</p>
<ul>
<li>首先，我们需要在子组件中定义好在某些情况下触发的事件名称；</li>
<li>其次，在父组件中以v-on的方式传入要监听的事件名称，并且绑定到对应的方法中；</li>
<li>最后，在子组件中发生某个事件的时候，根据事件名称触发对应的事件；</li>
</ul>
<blockquote>
<p>以下是一个简单的示例</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>emits</code></h4>
<blockquote>
<p>当使用Vue 3时，你可以使用emits选项来对子组件触发的自定义事件进行校验: 使用<code>emits</code>选项可以提供类型检查和错误提示，确保子组件只触发被允许的自定义事件。这有助于提高代码的可维护性和可靠性。以下是一个示例：</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 动态组件</h2>
<p>Vue.js 的动态组件是指可以根据不同的数据渲染不同的组件的功能。你可以使用 Vue.js 的 <code>&lt;component&gt; </code>元素来实现动态组件。</p>
<p>例如，你可以在父组件中定义一个数据属性，根据这个属性的值来决定渲染哪个子组件。然后，在模板中使用 <code>&lt;component&gt; </code>元素，并将该数据属性绑定到 is 属性上，这样就可以动态地渲染不同的子组件了。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 非父子组件之间的通信</h2>
<p>在开发中，我们构建了组件树之后，除了父子组件之间的通信之外，还会有非父子组件之间的通信。</p>
<p>这里我们主要讲两种方式：</p>
<ul>
<li>Provide/Inject</li>
<li>Mitt全局事件总线；</li>
</ul>
<h3> Provide/Inject</h3>
<p>Provide/Inject用于非父子组件之间共享数据：</p>
<ul>
<li>比如有一些深度嵌套的组件，子组件想要获取父组件的部分内容；</li>
<li>在这种情况下，如果我们仍然将props沿着组件链逐级传递下去，就会非常的麻烦；</li>
</ul>
<p>对于这种情况下，我们可以使用 <code>Provide</code> 和 <code>Inject</code> ：</p>
<ul>
<li>无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者；</li>
<li>父组件有一个 <code>provide</code> 选项来提供数据；</li>
<li>子组件有一个 <code>inject</code> 选项来开始使用这些数据；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311301958291.png" alt="image-20231130195805276" tabindex="0" loading="lazy"><figcaption>image-20231130195805276</figcaption></figure>
<p>实际上，你可以将依赖注入看作是“long range props”，除了：</p>
<ul>
<li>父组件不需要知道哪些子组件使用它 <code>provide </code>的 <code>property</code></li>
<li>子组件不需要知道 <code>inject </code>的 <code>property </code>来自哪里</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>当然, 我们也可以通过 this 获取到当前组件定义的 data</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 全局事件总线 mitt 库</h3>
<p>在 Vue 3 中，全局事件总线是一种用于在不同组件之间进行通信的机制。它允许你在任何组件中触发事件并在其他组件中监听和响应这些事件。</p>
<blockquote>
<p>https://cn.vuejs.org/api/application.html#app-config-globalproperties</p>
</blockquote>
<p>在 Vue 3 中，可以使用 <code>app.config.globalProperties</code> 来创建一个全局事件总线。通过将事件总线实例添加到全局属性中，你可以在任何组件中访问它，从而实现跨组件的事件通信。</p>
<p>以下是一个示例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建一个名为 <code>createEventBus</code> 的函数来创建事件总线实例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，你可以在任何组件中使用 <code>$bus</code>来触发事件和监听事件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，当点击按钮时，组件 A 使用<code> $bus.emit</code> 发送了一个名为 <code>'message'</code> 的事件，并传递了消息 <code>'Hello from component A'</code>。组件 B 使用 ​<code>$bus.on</code> 监听了 <code>'message' </code>事件，并将接收到的消息显示在页面上。</p>
<p>通过全局事件总线，你可以在不同组件之间进行简单而方便的通信，而无需显式地通过 props 或其他方式传递数据。</p>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202311240000049.png" type="image/png"/>
    </item>
    <item>
      <title>Vite</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/cli/Vite.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/cli/Vite.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Vite</source>
      <description>https://cn.vitejs.dev/guide/ 什么是 Vite Vite（法语意为 &amp;quot;快速的&amp;quot;，发音 /vit/，发音同 &amp;quot;veet&amp;quot;）是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成： 一个开发服务器(dev server)，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）。 一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。 Vite 是一种具有明确建议的工具，具备合理的默认设置。您可以在 功能指南 中了解 Vite 的各种可能性。通过 插件，Vite 支持与其他框架或工具的集成。如有需要，您可以通过 配置部分 自定义适应你的项目。 Vite 还提供了强大的扩展性，可通过其 插件 API 和 JavaScript API 进行扩展，并提供完整的类型支持。 Vite作为一个基于浏览器原生ESM的构建工具，它省略了开发环境的打包过程，利用浏览器去解析imports，在服务端按需编译返回。同时，在开发环境拥有速度快到惊人的模块热更新，且热更新的速度不会随着模块增多而变慢。因此，使用Vite进行开发，至少会比Webpack快10倍左右。 你可以在 为什么选 Vite 部分深入了解该项目的设计理念。</description>
      <pubDate>Wed, 22 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>https://cn.vitejs.dev/guide/</p>
</blockquote>
<h2> 什么是 Vite</h2>
<ul>
<li>Vite（法语意为 "快速的"，发音 <code>/vit/</code>，发音同 "veet"）是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成：
<ul>
<li>一个开发服务器(dev server)，它基于 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="noopener noreferrer">原生 ES 模块</a> 提供了 <a href="https://cn.vitejs.dev/guide/features.html" target="_blank" rel="noopener noreferrer">丰富的内建功能</a>，如速度快到惊人的 <a href="https://cn.vitejs.dev/guide/features.html#hot-module-replacement" target="_blank" rel="noopener noreferrer">模块热更新（HMR）</a>。</li>
<li>一套构建指令，它使用 <a href="https://rollupjs.org/" target="_blank" rel="noopener noreferrer">Rollup</a> 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。</li>
</ul>
</li>
<li>Vite 是一种具有明确建议的工具，具备合理的默认设置。您可以在 <a href="https://cn.vitejs.dev/guide/features.html" target="_blank" rel="noopener noreferrer">功能指南</a> 中了解 Vite 的各种可能性。通过 <a href="https://cn.vitejs.dev/guide/using-plugins.html" target="_blank" rel="noopener noreferrer">插件</a>，Vite 支持与其他框架或工具的集成。如有需要，您可以通过 <a href="https://cn.vitejs.dev/config/" target="_blank" rel="noopener noreferrer">配置部分</a> 自定义适应你的项目。</li>
<li>Vite 还提供了强大的扩展性，可通过其 <a href="https://cn.vitejs.dev/guide/api-plugin.html" target="_blank" rel="noopener noreferrer">插件 API</a> 和 <a href="https://cn.vitejs.dev/guide/api-javascript.html" target="_blank" rel="noopener noreferrer">JavaScript API</a> 进行扩展，并提供完整的类型支持。</li>
<li>Vite作为一个基于浏览器原生ESM的构建工具，它省略了开发环境的打包过程，利用浏览器去解析imports，在服务端按需编译返回。同时，在开发环境拥有速度快到惊人的模块热更新，且热更新的速度不会随着模块增多而变慢。因此，使用Vite进行开发，至少会比Webpack快10倍左右。</li>
<li>你可以在 <a href="https://cn.vitejs.dev/guide/why.html" target="_blank" rel="noopener noreferrer">为什么选 Vite</a> 部分深入了解该项目的设计理念。</li>
</ul>
<h3> Vite的主要特性</h3>
<ul>
<li>Instant Server Start —— 即时服务启动</li>
<li>Lightning Fast HMR —— 闪电般快速的热更新</li>
<li>Rich Features —— 丰富的功能</li>
<li>Optimized Build —— 经过优化的构建</li>
<li>Universal Plugin Interface —— 通用的Plugin接口</li>
<li>Fully Typed APIs —— 类型齐全的API</li>
</ul>
<h3> 主流构建工具对比</h3>
<p><strong>Browserify</strong></p>
<p>预编译模块化方案（文件打包工具）</p>
<ul>
<li>Browserify基于流方式干净灵活</li>
<li>遵循commonJS规范打包JS</li>
<li>可引入插件打包CSS等其他资源（非原生能力）</li>
</ul>
<p><strong>Gulp</strong></p>
<ul>
<li>基于流的自动化构建工具（工程化）</li>
<li>配置复杂度高，偏向编程式，需要定义task处理构建</li>
<li>支持监听读写文件</li>
<li>可搭配Browserify等模块化工具来使用</li>
</ul>
<p><strong>Parcel</strong></p>
<ul>
<li>极速打包（工程化：极速0配置）</li>
<li>零配置，但造成了配置不灵活，内置常见场景的构建方案及其依赖，无需再次安装（babel等）</li>
<li>以html入口，自动检测和打包依赖</li>
<li>不支持SourceMap</li>
<li>无法Tree-shaking</li>
</ul>
<p><strong>Webpack</strong></p>
<ul>
<li>预编译模块化方案（工程化：大而全）</li>
<li>通过配置文件达到一站式配置</li>
<li>loader进行资源转换，功能全面（css+js+icon+front）</li>
<li>插件丰富，灵活扩展</li>
<li>社群庞大</li>
<li>大型项目构建慢</li>
</ul>
<p><strong>Rollup</strong></p>
<ul>
<li>基于ES6打包（模块打包工具）</li>
<li>Tree-shaking</li>
<li>打包文件小且干净，执行效率更高</li>
<li>更专注于JS打包</li>
</ul>
<p><strong>Snowpack</strong></p>
<ul>
<li>基于ESM运行时编译（工程化：ESM运行时）</li>
<li>无需递归循环依赖组装依赖树</li>
<li>默认输出单独的构建模块（未打包），可选择不同打包器（webpack、rollup等）</li>
</ul>
<p><strong>Vite</strong></p>
<ul>
<li>基于ESM运行时打包</li>
<li>借鉴了Snowpack</li>
<li>生产环境使用Rollup，集成度更高，相比Snowpack支持多页面、库模式、动态导入自动polyfill等</li>
</ul>
<h2> 为什么使用 Vite</h2>
<h3> <strong>开发环境⚡️速度的提升</strong></h3>
<ol>
<li>使用JS开发的工具通常需要很长的时间才能启动开发服务器，且这个启动时间与代码量、代码复杂度正相关。即使使用HMR，文件修改后的效果也要几秒钟才能在浏览器中反应出来，代表如Webpack。那么Vite是如何解决如Webpack这样的构建工具一样，在复杂、多模块项目开发中启动慢、HMR慢的问题呢？</li>
<li>我们详细对比了开发环境中的Vite和Webpack，发现主要有如下不同：</li>
</ol>
<table>
<thead>
<tr>
<th>Webpack</th>
<th>Vite</th>
</tr>
</thead>
<tbody>
<tr>
<td>先打包生成bundle，再启动开发服务器</td>
<td>先启动开发服务器，利用新一代浏览器的ESM能力，无需打包，直接请求所需模块并实时编译</td>
</tr>
<tr>
<td>HMR时需要把改动模块及相关依赖全部编译</td>
<td>HMR时只需让浏览器重新请求该模块，同时利用浏览器的缓存（源码模块协商缓存，依赖模块强缓存）来优化请求</td>
</tr>
<tr>
<td>内存高效利用</td>
<td>-</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>因此，针对开发环境中的启动慢问题，Vite开发环境冷启动无需打包，无需分析模块之间的依赖，同时也无需在启动开发服务器前进行编译，启动时还会使用 <strong>esbuild</strong> 来进行预构建。而Webpack 启动后会做一堆事情，经历一条很长的编译打包链条，从入口开始需要逐步经历语法解析、依赖收集、代码转译、打包合并、代码优化，最终将高版本的、离散的源码编译打包成低版本、高兼容性的产物代码;</li>
<li>针对HMR慢，即使只有很小的改动，Webpack依然需要构建完整的模块依赖图，并根据依赖图来进行转换。而Vite利用了ESM和浏览器缓存技术，更新速度与项目复杂度无关。可以看到，如Snowpack、Vite这类面相非打包的构建工具，在开发环境启动时只需要启动两个Server，一个用于页面加载，一个用于HMR的Websocket。当浏览器发出原生的ESM请求，Server收到请求只需要编译当前文件后返回给浏览器，不需要管理依赖。</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202311221718913.png" alt="image-20231122171817220" tabindex="0" loading="lazy"><figcaption>image-20231122171817220</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202311221718035.png" alt="image-20231122171839049" tabindex="0" loading="lazy"><figcaption>image-20231122171839049</figcaption></figure>
<h3> <strong>使用简单，开箱即用</strong></h3>
<p>相比Webpack需要对entry、loader、plugin等进行诸多配置，Vite的使用可谓是相当简单了。只需执行初始化命令，就可以得到一个预设好的开发环境，开箱即获得一堆功能，包括：CSS预处理、html预处理、异步加载、分包、压缩、HMR等。他使用复杂度介于Parcel和Webpack的中间，只是暴露了极少数的配置项和plugin接口，既不会像Parcel一样配置不灵活，又不会像Webpack一样需要了解庞大的loader、plugin生态，灵活适中、复杂度适中。适合前端新手。</p>
<h2> Vite 的安装与使用</h2>
<h3> 安装</h3>
<blockquote>
<p>Vite 需要 <a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer">Node.js</a> 版本 18+，20+。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。</p>
</blockquote>
<ul>
<li>
<p>首先，我们安装一下vite工具：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>通过vite来启动项目：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<h3> Vite构建Vue3项目</h3>
<p>使用 NPM:</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用 Yarn:</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为我们要构建Vue3的项目，所以这里我们选择Vue就行了，然后下一步选择开发语言</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>cd 进项目路径, <code>npm install</code>, 然后 <code>npm run dev</code> 运行即可</p>
<figure><img src="https://qiniu.waite.wang/7C797674-06CF-4E87-B344-63990EF519B6.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> Vite 支持</h2>
<h3> Css 支持</h3>
<ul>
<li>
<p>vite可以直接支持css的处理</p>
<ul>
<li>直接导入css即可；</li>
</ul>
</li>
<li>
<p>vite可以直接支持css预处理器，比如less</p>
<ul>
<li>直接导入less；</li>
<li>之后安装less编译器；</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>vite直接支持postcss的转换：</li>
<li>只需要安装postcss，并且配置 postcss.config.js 的配置文件即可；</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 全局导入</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 别名</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> Ts 支持</h3>
<ul>
<li>vite对TypeScript是原生支持的，它会直接使用ESBuild来完成编译：
<ul>
<li>只需要直接导入即可；</li>
</ul>
</li>
<li>如果我们查看浏览器中的请求，会发现请求的依然是ts的代码：
<ul>
<li>这是因为vite中的服务器Connect会对我们的请求进行转发；</li>
<li>获取ts编译后的代码，给浏览器返回，浏览器可以直接进行解析；</li>
</ul>
</li>
</ul>
<h3> vue支持</h3>
<ul>
<li>
<p>vite对vue提供第一优先级支持：</p>
<ul>
<li>Vue 3 单文件组件支持：@vitejs/plugin-vue</li>
<li>Vue 3 JSX 支持：@vitejs/plugin-vue-jsx</li>
<li>Vue 2 支持：underfin/vite-plugin-vue2</li>
</ul>
</li>
<li>
<p>安装支持vue的插件：</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>在vite.config.js中配置插件</p>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Vite 原理</h2>
<h3> ESM&amp;esbuild</h3>
<h4> ESM</h4>
<p>在ES6没有出现之前，随着js代码日益膨胀，往往会对资源模块化来提效，这也就出现了多个模块化方案。如CommonJS常用于服务端，AMD、CMD规范常用在客户端。ES6出现后，紧接着出现了ESM。ESM是浏览器支持的一种模块化方案，允许在浏览器实现模块化。</p>
<ul>
<li>CommonJS：模块同步，如Browserify会对代码进行解析，整理出代码中的所有模块依赖关系，然后把nodejs的模块编译成浏览器可用的模块，相关的模块代码都打包在一起，形成一个完整的JS文件，这个文件中不会存在 require 这类的模块化语法，变成可以在浏览器中运行的普通JS，运行时加载</li>
<li>AMD：模块异步，依赖前置，是requireJS在推广过程中对模块定义的规范化产出，加载完依赖后立即执行依赖模块，依赖加载成功后执行回调</li>
<li>CMD：模块异步，延迟执行，是seaJS在推广过程中对模块定义的规范化产出，就近依赖，先加载所有依赖模块，运行时才执行require内容，按顺序执行</li>
</ul>
<p>与CommonJS、AMD不同，ESM的对外接口只是一种静态定义，为编译时加载，遇到模块加载命令import，就会生成一个只读引用。等脚本真正执行时，再根据这个只读引用，到被加载的那个模块内取值。由于ESM编译时就能确定模块的依赖关系，因此能够只包含要运行的代码，可以显著减少文件体积，降低浏览器压力。</p>
<p>由于ESM是一个比较新的模块化方案，目前其浏览器能力支持如下：</p>
<figure><img src="https://qiniu.waite.wang/202311221721568.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<p>可以看到，除了IE、Opera等，新一代浏览器中绝大部分都已支持。</p>
<p>接下来以Vite创建的模板为例，看一下ESM的解析过程：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>当浏览器解析 import HelloWorld from './components/HelloWorld.vue' 时，会向当前域名发送一个请求获取对应的资源（ESM支持解析相对路径）</li>
<li>浏览器下载对应的文件，然后解析成模块记录。接下来会进行实例化，为模块分配内存，然后按照导入、导出语句建立模块和内存的映射关系。最后，运行上述代码，把内存空间填充为真实的值。</li>
</ul>
<h4> esbuild</h4>
<ul>
<li>ESBuild的特点：
<ul>
<li>超快的构建速度，并且不需要缓存；</li>
<li>支持ES6和CommonJS的模块化；</li>
<li>支持ES6的Tree Shaking；</li>
<li>支持Go、JavaScript的API；</li>
<li>支持TypeScript、JSX等语法编译；</li>
<li>支持SourceMap；</li>
<li>支持代码压缩；</li>
<li>支持扩展其他插件；</li>
</ul>
</li>
<li>ESBuild的构建速度和其他构建工具速度对比：</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311221724703.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>
<ul>
<li>ESBuild为什么这么快呢？
<ul>
<li>使用Go语言编写的，可以直接转换成机器代码，而无需经过字节码；</li>
<li>ESBuild可以充分利用CPU的多内核，尽可能让它们饱和运行；</li>
<li>ESBuild的所有内容都是从零开始编写的，而不是使用第三方，所以从一开始就可以考虑各种性能问题；</li>
</ul>
</li>
</ul>
<h3> <strong>依赖处理</strong></h3>
<p>Vite 通过在一开始将应用中的模块区分为 <strong>依赖</strong> 和 <strong>源码</strong> 两类，改进了开发服务器启动时间。<strong>依赖</strong> 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。</p>
<ul>
<li><strong>依赖解析</strong></li>
</ul>
<p>以 Vite 官方 demo 为例，当我们请求 <strong>localhost:3000</strong> 时，Vite 默认返回 <strong>localhost:3000/index.html</strong> 的代码。而后发送请求 <strong>src/main.js</strong>。</p>
<p>main.js 代码如下：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202311222321963.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<p>可以观察到浏览器请求 vue.js 时， 请求路径是 <strong>@modules/vue.js</strong>。在 Vite 中约定若 path 的请求路径满足 <strong>/^/@modules//</strong> 格式时，被认为是一个 node_modules 模块。</p>
<p>平时开发中，webpack &amp; rollup(rollup有对应插件) 等打包工具会帮我们找到模块的路径，但浏览器只能通过相对路径去寻找，而如果是直接使用模块名比如：<strong>import vue from 'vue'</strong>，浏览器就会报错，这个时候就需要一个三方包进行处理。Vite 对ESM形式的 js 文件模块使用了 ES Module Lexer 处理。Lexer 会找到代码中以 import 语法导入的模块并以数组形式返回。Vite 通过该数组的值获取判断是否为一个 node_modules 模块。若是则进行对应改写成 @modules/:id 的写法。</p>
<p>重写完路径后，浏览器会发送 path 为 /@modules/:id 的对应请求，接下来会被 Vite 客户端做一层拦截来解析模块的真实位置。</p>
<p>首先正则匹配请求路径，如果是/@modules开头就进行后续处理，否则就跳过。若是，会设置响应类型为js，读取真实模块路径内容，返回给客户端。</p>
<p>客户端注入本质上是创建一个script标签（type='module'），然后将其插入到head中，这样客户端在解析html是就可以执行代码了</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><strong>依赖预构建</strong></li>
</ul>
<p>依赖预构建主要有两个目的：</p>
<ul>
<li><strong>CommonJS 和 UMD 兼容性:</strong> 开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。</li>
<li><strong>性能：</strong> Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。</li>
</ul>
<p>Vite使用esbuild在初次启动开发服务器前把检测到的依赖进行预构建。Vite 基于ESM，在使用某些模块时，由于模块依赖了另一些模块，依赖的模块又基于另一些模块。会出现页面初始化时一次发送数百个模块请求的情况。</p>
<p>以 lodash-es 为例，代码中以 import { debounce } from 'lodash' 导入一个命名函数时候，并不是只下载包含这个函数的文件，而是有一个依赖图。</p>
<figure><img src="https://qiniu.waite.wang/202311222322996.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<p>Vite 为了优化请求数量和速度，利用esbuild在启动的时候预先把debounce用到的所有内部模块全部打包成一个bundle，这样就浏览器在请求debounce时，便只需要发送一次请求了</p>
<h4> <strong>静态资源加载</strong></h4>
<p>当请求的路径符合 imageRE, mediaRE, fontsRE 或 JSON 格式，会被认为是一个静态资源。静态资源将处理成ESM模块返回。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>vue文件缓存</strong></h4>
<p>当 Vite 遇到一个 .vue 后缀的文件时。由于 .vue 模板文件的特殊性，它被拆分成 template, css, script 模块三个模块进行分别处理。最后会对 script, template, css 发送多个请求获取</p>
<figure><img src="https://qiniu.waite.wang/202311222324430.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h4> <strong>js/ts处理</strong></h4>
<p>Vite使用esbuild将ts转译到js，约是tsc速度的20～30倍，同时HMR更新反应到浏览器的时间会小于50ms。但是，由于esbuild转换ts到js对于类型操作仅仅是擦除，所以完全保证不了类型正确，因此需要额外校验类型，比如使用tsc --noEmit。</p>
<p>将ts转换成js后，浏览器便可以利用ESM直接拿到js资源。</p>
<h3> 热更新原理</h3>
<p>Vite 的热加载原理，其实就是在客户端与服务端建立了一个 websocket 连接，当代码被修改时，服务端发送消息通知客户端去请求修改模块的代码，完成热更新。</p>
<ul>
<li>服务端：服务端做的就是监听代码文件的改变，在合适的时机向客户端发送 websocket 信息通知客户端去请求新的模块代码。</li>
<li>客户端：Vite 中客户端的 websocket 相关代码在处理 html 中时被写入代码中。可以看到在处理 html 时，vite/client 的相关代码已经被插入。</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当request.path 路径是 /vite/client 时，请求获取已经提前写好的关于 websocket 的代码。因此在客户端中我们创建了一个 websocket 服务并与服务端建立了连接。</p>
<p>Vite 会接受到来自客户端的消息。通过不同的消息触发一些事件。做到浏览器端的即时热模块更换（热更新）。包括 connect、vue-reload、vue-rerender 等事件，分别触发组件vue 的重新加载，render等。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202311221718913.png" type="image/png"/>
    </item>
    <item>
      <title>VueCLI</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/cli/vueCli.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/cli/vueCli.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">VueCLI</source>
      <description>https://cli.vuejs.org/zh/ 什么是Vue脚手架？ 我们前面学习了如何通过webpack配置Vue的开发环境，但是在真实开发中我们不可能每一个项目从头来完成 所有的webpack配置，这样显示开发的效率会大大的降低； 所以在真实开发中，我们通常会使用脚手架来创建一个项目，Vue的项目我们使用的就是Vue的脚手架； 脚手架其实是建筑工程中的一个概念，在我们软件工程中也会将一些帮助我们搭建项目的工具称之为脚手架； 我们可以通过CLI选择项目的配置和创建出我们的项目； Vue CLI已经内置了webpack相关的配置，我们不需要从零来配置；</description>
      <pubDate>Wed, 22 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>https://cli.vuejs.org/zh/</p>
</blockquote>
<p>什么是Vue脚手架？</p>
<ul>
<li>我们前面学习了如何通过webpack配置Vue的开发环境，但是在真实开发中我们不可能每一个项目从头来完成 所有的webpack配置，这样显示开发的效率会大大的降低；</li>
<li>所以在真实开发中，我们通常会使用脚手架来创建一个项目，Vue的项目我们使用的就是Vue的脚手架；</li>
<li>脚手架其实是建筑工程中的一个概念，在我们软件工程中也会将一些帮助我们搭建项目的工具称之为脚手架；</li>
<li>我们可以通过CLI选择项目的配置和创建出我们的项目；</li>
<li>Vue CLI已经内置了webpack相关的配置，我们不需要从零来配置；</li>
</ul>
<p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：</p>
<ul>
<li>通过 <code>@vue/cli</code> 实现的交互式的项目脚手架。</li>
<li>通过 <code>@vue/cli</code> + <code>@vue/cli-service-global</code> 实现的零配置原型开发。</li>
<li>一个运行时依赖 (<code>@vue/cli-service</code>)，该依赖：
<ul>
<li>可升级；</li>
<li>基于 webpack 构建，并带有合理的默认配置；</li>
<li>可以通过项目内的配置文件进行配置；</li>
<li>可以通过插件进行扩展。</li>
</ul>
</li>
<li>一个丰富的官方插件集合，集成了前端生态中最好的工具。</li>
<li>一套完全图形化的创建和管理 Vue.js 项目的用户界面。</li>
</ul>
<p>Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需 eject。</p>
<h2> Vue CLI 安装</h2>
<blockquote>
<p>Node 版本要求</p>
<p>Vue CLI 4.x 需要 <a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer">Node.js</a> v8.9 或更高版本 (推荐 v10 以上)。你可以使用 <a href="https://github.com/tj/n" target="_blank" rel="noopener noreferrer">n</a>，<a href="https://github.com/creationix/nvm" target="_blank" rel="noopener noreferrer">nvm</a> 或 <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener noreferrer">nvm-windows</a> 在同一台电脑中管理多个 Node 版本。</p>
</blockquote>
<ul>
<li>可以使用下列任一命令安装这个新的包：</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>安装之后，你就可以在命令行中访问 <code>vue</code> 命令。你可以通过简单运行 <code>vue</code>，看看是否展示出了一份所有可用命令的帮助信息，来验证它是否安装成功。你还可以用这个命令来检查其版本是否正确：</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>如需升级全局的 Vue CLI 包，请运行：</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>上面列出来的命令是用于升级全局的 Vue CLI。如需升级项目中的 Vue CLI 相关模块（以 <code>@vue/cli-plugin-</code> 或 <code>vue-cli-plugin-</code> 开头），请在项目目录下运行 <code>vue upgrade</code>：</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 创建一个项目</h2>
<p>运行以下命令来创建一个新项目：</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol>
<li>选择预设
<ul>
<li>Default ([Vue 3] babel, eslint): 选择 Vue3 版本, 并且默认选择 babel, eslint</li>
<li>Default ([Vue 2] babel, eslint): 选择 Vue2 版本, 并且默认选择 babel, eslint</li>
<li>Manually select features: 手动选择需要获取的特性</li>
</ul>
</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202311221033285.png" alt="image-20231122103332793" tabindex="0" loading="lazy"><figcaption>image-20231122103332793</figcaption></figure>
<ol start="2">
<li>我们选择 <code>Manually select features</code>
<ul>
<li>Babel: Babel是一个JavaScript编译器，用于将新版本的JavaScript代码转换为向后兼容的旧版本，以便在不同浏览器和环境中运行。</li>
<li>TypeScript: TypeScript是一种静态类型的JavaScript超集，它添加了类型注解和其他特性，以提供更强大的开发工具和更可靠的代码。</li>
<li>Progressive Web App (PWA) Support: PWA是一种使用现代Web技术构建的应用程序，可以在各种设备和平台上提供类似原生应用的体验。</li>
<li>Router: Vue Router是Vue.js官方提供的路由管理器，用于实现单页面应用程序（SPA）中的导航和路由功能。</li>
<li>Vuex: Vuex是Vue.js官方提供的状态管理库，用于在大型应用程序中管理和共享状态。</li>
<li>CSS Pre-processors: CSS预处理器（如Sass、Less）允许您在编写CSS时使用变量、嵌套规则、函数等高级功能，以提高样式表的可维护性和可重用性。</li>
<li>Linter / Formatter: 代码检查工具（如ESLint）用于强制执行一致的代码风格和检测潜在的错误。代码格式化工具（如Prettier）可自动格式化代码，使其符合统一的样式规范。</li>
<li>Unit Testing: 单元测试是一种软件测试方法，用于验证应用程序中各个部分的功能是否按预期工作。</li>
<li>E2E Testing: 端到端（End-to-End）测试是一种测试方法，用于模拟用户在应用程序中执行的实际操作，以验证整个应用程序的功能和流程。</li>
</ul>
</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202311221036769.png" alt="image-20231122103618450" tabindex="0" loading="lazy"><figcaption>image-20231122103618450</figcaption></figure>
<ol start="3">
<li>选择 Vue 版本</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202311221036975.png" alt="image-20231122103654515" tabindex="0" loading="lazy"><figcaption>image-20231122103654515</figcaption></figure>
<ol start="4">
<li>
<p>Pick a linter / formatter config: 选择的代码检查和格式化配置</p>
<ul>
<li>ESLint with error prevention only：仅使用ESLint进行错误检查，不应用其他格式化规则。</li>
<li>ESLint + Airbnb config：使用ESLint进行错误检查，并应用Airbnb JavaScript风格指南的格式化规则。</li>
<li>ESLint + Standard config：使用ESLint进行错误检查，并应用JavaScript Standard风格的格式化规则。</li>
<li>ESLint + Prettier：使用ESLint进行错误检查，并与Prettier代码格式化工具集成，以实现一致的代码样式</li>
</ul>
</li>
<li>
<p>Pick additional lint features: 可供选择的附加代码检查功能</p>
<ul>
<li>Lint on save：在保存文件时运行代码检查，以及在编辑器中进行实时错误检测和提示。</li>
<li>Lint and fix on commit：在提交代码时运行代码检查，并自动修复一些常见的问题，以确保提交的代码符合规范。</li>
</ul>
</li>
<li>
<p>Where do you prefer placing config for Babel, ESLint, etc.? 配置文件位置选择</p>
<ul>
<li>In dedicated config files：将Babel、ESLint等配置信息分别保存在它们各自的配置文件中（如.babelrc、.eslintrc等。</li>
<li>In package.json：将Babel、ESLint等配置信息保存在package.json文件的特定字段中，如babel、eslintConfig等。</li>
</ul>
</li>
<li>
<p>Save this as a preset for future projects? (y/N) 这是一个保存预设供以后使用的选项，如果您希望将当前配置保存为预设，以便在将来的项目中重用，可以选择“y”，否则选择“N”。</p>
</li>
</ol>
<blockquote>
<p>您还可以使用图形界面使用以下<code>vue ui</code>命令创建和管理项目：</p>
</blockquote>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://cli.vuejs.org/ui-new-project.png" alt="界面预览" tabindex="0" loading="lazy"><figcaption>界面预览</figcaption></figure>
<h2> 项目结构</h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>在一个 Vue CLI 项目中，<code>@vue/cli-service</code> 安装了一个名为 <code>vue-cli-service</code> 的命令。你可以在 npm scripts 中以 <code>vue-cli-service</code>、或者从终端中以 <code>./node_modules/.bin/vue-cli-service</code> 访问这个命令。</p>
</blockquote>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以通过 npm 或 Yarn 调用这些 script：</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你可以使用 <a href="https://github.com/npm/npx" target="_blank" rel="noopener noreferrer">npx</a> (最新版的 npm 应该已经自带)，也可以直接这样调用命令：</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> vue-cli-service serve</h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>vue-cli-service serve</code> 命令会启动一个开发服务器 (基于 <a href="https://github.com/webpack/webpack-dev-server" target="_blank" rel="noopener noreferrer">webpack-dev-server</a>) 并附带开箱即用的模块热重载 (Hot-Module-Replacement)。</p>
<p>除了通过命令行参数，你也可以使用 <code>vue.config.js</code> 里的 <a href="https://cli.vuejs.org/zh/config/#devserver" target="_blank" rel="noopener noreferrer">devServer</a> 字段配置开发服务器。</p>
<p>命令行参数 <code>[entry]</code> 将被指定为唯一入口 (默认值：<code>src/main.js</code>，TypeScript 项目则为 <code>src/main.ts</code>)，而非额外的追加入口。尝试使用 <code>[entry]</code> 覆盖 <code>config.pages</code> 中的 <code>entry</code> 将可能引发错误。</p>
<h2> <a href="https://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-build" target="_blank" rel="noopener noreferrer">vue-cli-service build</a></h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>vue-cli-service build</code> 会在 <code>dist/</code> 目录产生一个可用于生产环境的包，带有 JS/CSS/HTML 的压缩，和为更好的缓存而做的自动的 vendor chunk splitting。它的 chunk manifest 会内联在 HTML 里。</p>
<p>这里还有一些有用的命令参数：</p>
<ul>
<li><code>--modern</code> 使用<a href="https://cli.vuejs.org/zh/guide/browser-compatibility.html#%E7%8E%B0%E4%BB%A3%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener noreferrer">现代模式</a>构建应用，为现代浏览器交付原生支持的 ES2015 代码，并生成一个兼容老浏览器的包用来自动回退。</li>
<li><code>--target</code> 允许你将项目中的任何组件以一个库或 Web Components 组件的方式进行构建。更多细节请查阅<a href="https://cli.vuejs.org/zh/guide/build-targets.html" target="_blank" rel="noopener noreferrer">构建目标</a>。</li>
<li><code>--report</code> 和 <code>--report-json</code> 会根据构建统计生成报告，它会帮助你分析包中包含的模块们的大小。</li>
</ul>
<h2> vue-cli-service inspect</h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你想要设置 inspect 命令的选项，可以在命令后面添加对应的参数。例如，如果你想要查看生产环境的 webpack 配置，可以运行以下命令：<code>vue-cli-service inspect --mode production</code></p>
<p>你也可以通过在 vue.config.js 文件中配置 configureWebpack 选项来修改 webpack 配置。这个选项允许你返回一个对象或函数来修改默认的 webpack 配置。例如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>你可以使用 <code>vue-cli-service inspect</code> 来审查一个 Vue CLI 项目的 webpack config。更多细节请查阅<a href="https://cli.vuejs.org/zh/guide/webpack.html#%E5%AE%A1%E6%9F%A5%E9%A1%B9%E7%9B%AE%E7%9A%84-webpack-config" target="_blank" rel="noopener noreferrer">审查 webpack config</a>。</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202311221033285.png" type="image/png"/>
    </item>
    <item>
      <title>Webpack_devServer</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/cli/devServer.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/cli/devServer.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Webpack_devServer</source>
      <description>devServer 是指开发服务器，通常用于前端开发环境。在前端开发中，开发者通常需要一个本地服务器来运行他们的应用程序，以便进行测试和调试。Webpack是一个流行的前端构建工具，而devServer就是Webpack提供的一个功能，用于在开发过程中提供一个简单的服务器。 devServer 可以帮助开发者在本地启动一个服务器，监视文件的变化，并在文件发生更改时自动重新加载页面，以提高开发效率。此外，它还支持一些其他功能，比如模块热替换（Hot Module Replacement），允许在不刷新整个页面的情况下更新部分模块。 在使用Webpack配置文件时，你可以配置 devServer 的各种选项，以满足你的开发需求。这包括设置服务器的端口、指定静态资源的路径、配置代理等。</description>
      <pubDate>Sun, 19 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p><code>devServer</code> 是指开发服务器，通常用于前端开发环境。在前端开发中，开发者通常需要一个本地服务器来运行他们的应用程序，以便进行测试和调试。Webpack是一个流行的前端构建工具，而<code>devServer</code>就是Webpack提供的一个功能，用于在开发过程中提供一个简单的服务器。</p>
<p><code>devServer</code> 可以帮助开发者在本地启动一个服务器，监视文件的变化，并在文件发生更改时自动重新加载页面，以提高开发效率。此外，它还支持一些其他功能，比如模块热替换（Hot Module Replacement），允许在不刷新整个页面的情况下更新部分模块。</p>
<p>在使用Webpack配置文件时，你可以配置 <code>devServer</code> 的各种选项，以满足你的开发需求。这包括设置服务器的端口、指定静态资源的路径、配置代理等。</p>
</blockquote>
<ul>
<li>目前我们开发的代码，为了运行需要有两个操作：
<ul>
<li>操作一：npm run build，编译相关的代码；</li>
<li>操作二：通过live server或者直接通过浏览器，打开index.html代码，查看效果；</li>
</ul>
</li>
<li>这个过程经常操作会影响我们的开发效率，我们希望可以做到，当文件发生变化时，可以自动的完成编译和展示；</li>
<li>为了完成自动编译，webpack提供了几种可选的方式：
<ul>
<li><code>webpack watch mode</code>：在文件发生变化时，Webpack会自动重新编译代码。</li>
<li><code>webpack-dev-server</code>（常用）：提供了一个开发服务器，可以在本地运行你的应用程序，并且在文件发生变化时自动重新加载页面。</li>
<li><code>webpack-dev-middleware</code>：结合其他服务器框架使用，将Webpack与服务器集成，实现在文件发生变化时自动重新编译</li>
</ul>
</li>
</ul>
<h2> Webpack watch</h2>
<ul>
<li>
<p>webpack给我们提供了watch模式：</p>
<ul>
<li>在该模式下，webpack依赖图中的所有文件，只要有一个发生了更新，那么代码将被重新编译；</li>
<li>我们不需要手动去运行 npm run build指令了；</li>
</ul>
</li>
<li>
<p>开启watch模式有两种方式：</p>
<ul>
<li>通过在命令行中使用--watch参数来开启watch模式。例如，运行<code>webpack --watch</code>命令即可开启watch模式。</li>
</ul>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>在Webpack配置文件中添加``watch: true`选项来开启watch模式。例如，在Webpack配置文件中添加以下代码：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> webpack-dev-server</h2>
<ul>
<li>上面的方式可以监听到文件的变化，但是事实上它本身是没有自动刷新浏览器的功能的：
<ul>
<li>当然，目前我们可以在 VSCode 中使用 live-server 来完成这样的功能；</li>
<li>但是，我们希望在不适用live-server的情况下，可以具备live reloading（实时重新加载）的功能；</li>
</ul>
</li>
<li>安装webpack-dev-server</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>修改配置文件</li>
</ul>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>运行 <code>npm run serve</code>, 在本地配置一个服务器, 使用 <code>webpack cli</code> 解析/ 启动本地服务</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311191904772.png" alt="image-20231119190420271" tabindex="0" loading="lazy"><figcaption>image-20231119190420271</figcaption></figure>
</li>
</ul>
<blockquote>
<p>在运行 <code>npm run serve</code> 命令时，如果没有指定输出目录，webpack会默认将打包后的文件输出到内存中，而不是硬盘上的某个目录中。因此即使没有指定输出目录，该命令仍然可以正常运行。这种方式称为内存编译，可以提高开发效率，因为不需要每次修改代码后都重新编译和写入磁盘。 使用 <code>memfs</code> 这一个库实现;</p>
</blockquote>
<h2> 认识模块热替换（HMR）</h2>
<ul>
<li>什么是HMR呢？
<ul>
<li>HMR的全称是Hot Module Replacement，翻译为模块热替换；</li>
<li>模块热替换是指在 应用程序运行过程中，<strong>替换、添加、删除模块，而无需重新刷新整个页面</strong>；</li>
</ul>
</li>
<li>HMR通过如下几种方式，来提高开发的速度：
<ul>
<li>不重新加载整个页面，这样可以保留某些应用程序的状态不丢失；</li>
<li>只更新需要变化的内容，节省开发的时间；</li>
<li>修改了css、js源代码，会立即在浏览器更新，相当于直接在浏览器的 devtools 中直接修改样式；</li>
</ul>
</li>
<li>如何使用HMR呢？
<ul>
<li>默认情况下，webpack-dev-server已经支持HMR，我们只需要开启即可；</li>
<li>在不开启HMR的情况下，当我们修改了源代码之后，整个页面会自动刷新，使用的是live reloading；</li>
</ul>
</li>
</ul>
<h3> 开启 HMR</h3>
<ul>
<li>修改webpack的配置：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202311192014822.png" alt="image-20231119201428778" tabindex="0" loading="lazy"><figcaption>image-20231119201428778</figcaption></figure>
<ul>
<li>指定哪些模块发生更新时，进行HMR；</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 框架 的 HMR</h3>
<ul>
<li>
<p>大多数主流框架（如React、Vue和Angular）都对模块热替换（HMR）提供了内置的支持，以便在开发过程中实现更快的热更新。</p>
</li>
<li>
<p>具体而言，这些框架通常会提供开发服务器或开发工具，用于在开发过程中启用HMR功能。通过使用这些工具，你可以在修改代码时实时查看更新后的效果，而无需手动刷新页面。</p>
</li>
<li>
<p>以下是一些常见的框架的HMR支持方式：</p>
<ul>
<li>React：React 框架通常使用Webpack的 <code>react-hot-loader</code> 插件来实现HMR功能。你可以在Webpack配置文件中配置该插件，然后在开发服务器中启用HMR。</li>
<li>Vue：Vue 框架内置了对HMR的支持。你可以使用 <code>vue-loader</code> 和 <code>vue-style-loader</code> 等相关插件，以及在Webpack配置文件中配置HMR选项，来启用Vue的HMR功能。</li>
<li>Angular：Angular 框架使用Webpack的 <code>@angular-builders/custom-webpack</code> 插件来实现HMR功能。你可以在Angular项目的配置文件中进行相应的配置，以启用HMR。</li>
</ul>
</li>
<li>
<p>请注意，每个框架的具体配置方式可能会有所不同。建议查阅相应框架的官方文档或社区资源，以获取更详细的关于HMR的配置和使用说明。</p>
</li>
</ul>
<h3> HMR的原理</h3>
<p>HMR（Hot Module Replacement）的原理是通过在应用程序运行时，通过开发服务器向客户端发送更新的模块代码，然后使用热更新运行时（Hot Update Runtime）来替换旧的模块代码，从而实现模块的热替换，而无需重新加载整个页面。</p>
<ul>
<li>webpack-dev-server会创建两个服务：提供静态资源的服务（express）和Socket服务（net.Socket）；
<ul>
<li>HMR Socket Server，是一个socket的长连接：
<ul>
<li>长连接有一个最好的好处是建立连接后双方可以通信（服务器可以直接发送文件到客户端）；</li>
<li>当服务器监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）；</li>
<li>通过长连接，可以直接将这两个文件主动发送给客户端（浏览器）；</li>
<li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新；</li>
</ul>
</li>
<li>Webpack-dev-server使用Node.js内置的net模块提供WebSocket服务。该服务与静态资源服务配合使用，用于与客户端进行实时通信。当客户端连接到WebSocket服务时，Webpack-dev-server会将更新的模块代码发送到客户端，并触发模块热替换（HMR）功能。客户端接收到更新后，会通过WebSocket与Webpack-dev-server建立连接，并将更新的模块代码应用到正在运行的应用程序中。</li>
</ul>
</li>
<li>express server负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）；
<ul>
<li>Webpack-dev-server使用express框架提供静态资源服务。该服务可以将Webpack打包后的静态资源文件（如HTML、CSS、JavaScript等）提供给浏览器访问。同时，该服务还支持一些特殊的路由，如/__webpack_hmr，用于与客户端建立WebSocket通信。</li>
</ul>
</li>
</ul>
<p>具体而言，HMR的原理可以分为以下几个步骤：</p>
<ol>
<li>构建过程中的注入：在Webpack构建过程中，会将特殊的HMR运行时代码注入到应用程序中的每个模块中。这些HMR运行时代码负责与开发服务器建立连接，并接收来自服务器的更新通知。</li>
<li>开发服务器的更新通知：开发服务器会监视文件的变化，并在文件发生更改时，向连接的客户端发送更新通知。这些更新通知包含了被修改的模块的更新代码。</li>
<li>客户端接收更新：当客户端接收到更新通知时，它会根据更新代码进行处理。这些更新代码会被热更新运行时处理，并将其应用于相应的模块。</li>
<li>模块的热替换：热更新运行时会将新的模块代码与旧的模块代码进行比较，并尽可能地将新代码应用于正在运行的应用程序。如果新代码可以被成功替换，应用程序会保持运行状态，同时显示更新后的效果。</li>
</ol>
<p>总结起来，HMR利用了Webpack的构建能力和热更新运行时，使得在开发过程中可以实时地修改代码并查看更新后的效果，从而提高开发效率。</p>
<figure><img src="https://qiniu.waite.wang/202311192033908.png" alt="image-20231119203330239" tabindex="0" loading="lazy"><figcaption>image-20231119203330239</figcaption></figure>
<h2> devServer 配置信息</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> hotOnly、host 配置</h3>
<ul>
<li>
<p>host设置主机地址：</p>
<ul>
<li>默认值是localhost；</li>
<li>如果希望其他地方也可以访问，可以设置为 0.0.0.0；</li>
</ul>
</li>
<li>
<p>localhost 和 0.0.0.0 的区别：</p>
<ul>
<li><code>localhost</code>：<code>localhost</code>是一个主机名，表示本地计算机或设备自身。它通常映射到回环地址（loopback address）``127.0.0.1<code>，也可以是IPv6的</code>::1<code>。当应用程序绑定到</code>localhost`时，它只能通过本地计算机或设备上的回环接口进行访问。这意味着只有本地计算机或设备上的进程可以访问该应用程序，其他计算机或设备无法直接访问。</li>
<li><code>0.0.0.0</code>：<code>0.0.0.0</code>是一个特殊的IP地址，表示任意主机或所有主机。当应用程序绑定到<code>0.0.0.0</code>时，它将监听所有可用的网络接口，包括本地计算机上的回环接口和其他网络接口。这意味着其他计算机或设备可以通过网络访问该应用程序，前提是网络连接和防火墙允许。</li>
</ul>
</li>
<li>
<p>简而言之，<code>localhost</code>指的是本地计算机或设备自身，只能通过本地访问。而<code>0.0.0.0</code>表示任意主机或所有主机，可以通过网络访问。在开发过程中，通常将应用程序绑定到localhost以进行本地开发和测试，而将其绑定到<code>0.0.0.0</code>可以使其在局域网或公共网络上可访问。</p>
</li>
</ul>
<h3> port、open、compress</h3>
<ul>
<li>port设置监听的端口，默认情况下是8080
<ul>
<li>这个选项用于指定Webpack开发服务器的端口号。通过设置port选项，你可以指定应用程序在开发服务器上监听的端口。</li>
</ul>
</li>
<li>open是否打开浏览器：
<ul>
<li>默认值是false，设置为true会打开浏览器；</li>
<li>这个选项用于指定是否在启动Webpack开发服务器后自动打开浏览器。通过设置open选项为true，开发服务器将在启动后自动打开默认浏览器，并加载应用程序</li>
<li>也可以设置为类似于 Google Chrome等值；</li>
</ul>
</li>
<li>compress是否为静态文件开启gzip compression：
<ul>
<li>默认值是false，可以设置为true；</li>
<li>这个选项用于指定是否启用gzip压缩。通过设置compress选项为true，开发服务器将对传输到浏览器的资源进行gzip压缩，以减小文件大小，提高传输速度。</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Proxy</h3>
<blockquote>
<p>https://webpack.docschina.org/configuration/dev-server#devserverproxy</p>
</blockquote>
<ul>
<li>
<p>proxy是我们开发中非常常用的一个配置选项，它的目的设置代理来解决跨域访问的问题：</p>
<ul>
<li>比如我们的一个api请求是 http://localhost:3000但是本地启动服务器的域名是 http://localhost:8000，这 个时候发送网络请求就会出现跨域的问题；</li>
<li>那么我们可以将请求先发送到一个代理服务器，代理服务器和API服务器没有跨域的问题，就可以解决我们的跨域问题了</li>
</ul>
</li>
<li>
<p>代理（Proxy）是一种常见的网络应用程序架构，它可以将客户端的请求转发到另一个服务器进行处理。在开发环境中，我们通常会将应用程序和API服务分开部署，这时就需要使用代理将客户端的API请求转发到后端API服务器上。</p>
</li>
<li>
<p>在 Webpack 的 devServer 中，可以使用proxy选项来配置代理设置。proxy选项可以是一个对象，也可以是一个函数。对象方式的proxy选项可以指定一个或多个代理规则，每个规则包含了要转发的请求路径和目标服务器地址。例如：</p>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>在这个示例中，我们将所有以<code>/api</code>开头的请求转发到<code>http://localhost:3000</code>服务器上。同时，我们还设置了<code>changeOrigin</code>选项为<code>true</code>，以改变请求头中的<code>Origin</code>字段，并使用<code>pathRewrite</code>选项将请求路径中的<code>/api</code>前缀替换为空。</li>
<li>当 <code>changeOrigin </code>设置为 true 时，代理服务器会将请求头中的 Origin 字段替换为目标服务器的地址，这样目标服务器就可以正确识别请求来源。否则，目标服务器可能会拒绝请求或返回错误的响应。</li>
<li>除了对象方式的<code>proxy</code>选项外，还可以使用函数方式的<code>proxy</code>选项来进行更灵活的配置。例如：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>在这个示例中，我们使用函数方式的<code>proxy</code>选项来动态配置代理规则。如果请求路径以<code>/api</code>开头，则将其转发到<code>http://localhost:3000</code>服务器上，并使用相应的选项进行配置。</p>
</li>
<li>
<p>默认情况下，将不接受在 HTTPS 上运行且证书无效的后端服务器。 如果需要，可以这样修改配置：</p>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> historyApiFallback</h3>
<ul>
<li>
<p><code>historyApiFallback </code>是 <code>webpack-dev-server </code>的一个配置项，用于控制当使用 HTML5 History API 时，如果找不到对应的资源应该返回什么页面。</p>
</li>
<li>
<p>当浏览器使用 HTML5 History API 进行前端路由跳转时，例如从<code> /home</code> 跳转到 <code>/about</code>，浏览器会向服务器发送一个 GET 请求，但是服务器上并没有对应的 <code>/about</code> 路径和资源，此时会返回 404 错误。为了避免这种情况，<code>historyApiFallback</code> 可以设置一个默认的页面，用于代替 404 错误页面。</p>
</li>
<li>
<p>例如，设置 <code>historyApiFallback</code>: true 后，当访问一个不存在的路由时，<code>webpack-dev-server</code> 会返回一个默认的 HTML 页面，通常是 <code>index.html</code>。这个页面会包含前端路由所需的 JavaScript 和 CSS 资源，从而保证前端路由跳转的正常运行。</p>
</li>
<li>
<p>需要注意的是，在生产环境中，historyApiFallback 应该由服务器来处理，而不是由前端框架或工具来处理。</p>
</li>
<li>
<p>https://webpack.docschina.org/configuration/dev-server/#devserverhistoryapifallback</p>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>要将 404 错误跳转到一个名为 <code>404.html </code>的页面，你可以通过 <code>historyApiFallback </code>的 <code>rewrites </code>选项来实现。以下是一个示例配置：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>在上述配置中，我们使用了 <code>rewrites </code>数组来定义重写规则。第一个规则 <code>{ from: /^\/$/, to: '/index.html' }</code> 将根路径 <code>/ </code>重写到 <code>index.html</code> 页面，这样确保了默认路径的正确加载。第二个规则 <code>{ from: /./, to: '/404.html' } </code>将所有其他路径都重写到 <code>404.html</code> 页面，实现了将 404 错误跳转到指定页面的效果。</li>
</ul>
<h2> resolve模块解析</h2>
<blockquote>
<p>https://webpack.docschina.org/configuration/resolve</p>
</blockquote>
<ul>
<li><code>resolve </code>是 <code>webpack</code> 中的一个配置选项，用于配置模块解析的规则。
<ul>
<li>在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库；</li>
<li>resolve可以帮助webpack从每个 require/import 语句中，找到需要引入到合适的模块代码；</li>
<li>webpack 使用 <a href="https://github.com/webpack/enhanced-resolve" target="_blank" rel="noopener noreferrer">enhanced-resolve</a> 来解析文件路径；</li>
</ul>
</li>
</ul>
<ol>
<li>
<p>extensions
<code>extensions </code>用于配置在导入模块时可以省略的文件扩展名。例如，配置了 <code>extensions: ['.js', '.jsx']</code> 后，当导入模块时可以省略文件扩展名，如 <code>import MyComponent from './MyComponent'</code>，<code>webpack</code> 会自动尝试解析 <code>MyComponent.js</code> 或 <code>MyComponent.jsx</code>。</p>
</li>
<li>
<p>alias
<code>alias </code>用于创建模块的别名，可以简化模块导入的路径。例如，配置了 <code>alias: { '@': path.resolve(__dirname, 'src') } </code>后，可以使用<code>import MyComponent from '@/components/MyComponent'</code>来导入位于 <code>src/components/MyComponent</code> 的模块。</p>
</li>
<li>
<p>modules
<code>modules </code>用于配置 <code>webpack </code>在解析模块时搜索的目录。默认情况下，<code>webpack </code>只会搜索 <code>node_modules</code> 目录。通过配置 <code>modules</code>，可以告诉 <code>webpack </code>在其他目录中查找模块。例如，配置了 <code>modules: ['src', 'node_modules']</code> 后，<code>webpack </code>会先在 <code>src </code>目录中查找模块，然后再在 <code>node_modules </code>目录中查找。</p>
</li>
<li>
<p>mainFields
<code>mainFields </code>用于配置在导入模块时，<code>webpack </code>优先使用的字段。当导入一个模块时，它可能在 <code>package.json</code> 文件中定义了多个入口字段（如 main, module, browser 等）。通过配置 <code>mainFields</code>，可以告诉 webpack 使用哪个字段作为模块的主入口。例如，配置了 <code>mainFields: ['browser', 'module', 'main']</code> 后，webpack 会优先使用 <code>browser</code> 字段，然后是 <code>module </code>字段，最后是 <code>main </code>字段。</p>
</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>webpack能解析三种文件路径：
<ul>
<li>绝对路径
<ul>
<li>由于已经获得文件的绝对路径，因此不需要再做进一步解析。</li>
</ul>
</li>
<li>相对路径
<ul>
<li>在这种情况下，使用 import 或 require 的资源文件所处的目录，被认为是上下文目录；</li>
<li>在 import/require 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径；</li>
</ul>
</li>
<li>模块路径
<ul>
<li>在 resolve.modules中指定的所有目录检索模块；
<ul>
<li>默认值是 [‘node_modules’]，所以默认会从node_modules中查找文件；</li>
</ul>
</li>
<li>我们可以通过设置别名的方式来替换初识模块路径，具体后面讲解alias的配置；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2> 区分开发/ 生产环境</h2>
<ul>
<li>目前我们所有的webpack配置信息都是放到一个配置文件中的：webpack.config.js
<ul>
<li>当配置越来越多时，这个文件会变得越来越不容易维护；</li>
<li>并且某些配置是在开发环境需要使用的，某些配置是在生成环境需要使用的，当然某些配置是在开发和生成环 境都会使用的；</li>
<li>所以，我们最好对配置进行划分，方便我们维护和管理；</li>
</ul>
</li>
<li>方案一：编写两个不同的配置文件，开发和生成时，分别加载不同的配置文件即可；</li>
</ul>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202311192229409.png" alt="image-20231119222920881" tabindex="0" loading="lazy"><figcaption>image-20231119222920881</figcaption></figure>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>方式二：使用相同的一个入口配置文件，通过设置参数来区分它们；</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>在命令行中，可以通过 <code>--mode</code> 参数来指定 webpack 的构建模式。例如：</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202311191904772.png" type="image/png"/>
    </item>
    <item>
      <title>Webpack_Babel</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/cli/babel.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/cli/babel.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Webpack_Babel</source>
      <description>什么是 Babel? https://babeljs.io/ Babel 是一个 JavaScript 编译器，可以将 ECMAScript 2015+ 代码转换为向后兼容的 JavaScript 版本，以便在当前和旧版浏览器或环境中运行。它还支持将 JSX 转换为普通 JavaScript 代码。Babel 是一个非常流行的工具，许多现代的 JavaScript 应用程序都使用它来构建和部署。 事实上，在开发中我们很少直接去接触babel，但是babel对于前端开发来说，目前是不可缺少的一部分： 开发中，我们想要使用ES6+的语法，想要使用TypeScript，开发React项目，它们都是离不开Babel的；所以，学习Babel对于我们理解代码从编写到线上的转变过程至关重要；</description>
      <pubDate>Fri, 17 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是 Babel?</h2>
<blockquote>
<p>https://babeljs.io/</p>
</blockquote>
<blockquote>
<ul>
<li>Babel 是一个 JavaScript 编译器，可以将 ECMAScript 2015+ 代码转换为向后兼容的 JavaScript 版本，以便在当前和旧版浏览器或环境中运行。它还支持将 JSX 转换为普通 JavaScript 代码。Babel 是一个非常流行的工具，许多现代的 JavaScript 应用程序都使用它来构建和部署。</li>
<li>事实上，在开发中我们很少直接去接触babel，但是babel对于前端开发来说，目前是不可缺少的一部分：</li>
<li>开发中，我们想要使用ES6+的语法，想要使用TypeScript，开发React项目，它们都是离不开Babel的；所以，学习Babel对于我们理解代码从编写到线上的转变过程至关重要；</li>
</ul>
</blockquote>
<ul>
<li>以下是一个使用 Babel 的示例：</li>
<li>假设我们有一个使用箭头函数和 const 声明的简单 JavaScript 模块：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>如果我们想要在旧版浏览器中运行它，我们可以使用 Babel 将其转换为 ES5：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>这个转换过的代码可以在大多数浏览器中运行，即使它们不支持箭头函数或 const 声明。</li>
</ul>
<h2> Babel 命令行使用</h2>
<ul>
<li>babel本身可以作为一个独立的工具（和postcss一样），不和webpack等构建工具配置来单独使用。</li>
<li>如果我们希望在命令行尝试使用babel，需要安装如下库：
<ul>
<li>@babel/core：babel的核心代码，必须安装；</li>
<li>@babel/cli：可以让我们在命令行使用babel；</li>
</ul>
</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>使用babel来处理我们的源代码：
<ul>
<li>src：是源文件的目录；</li>
<li>–out-dir：指定要输出的文件夹dist；</li>
<li>--out-file: 指定要输出的文件dist；</li>
</ul>
</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 插件</h2>
<ul>
<li>
<p>Babel 的插件是用于转换 JavaScript 代码的小型程序，可以添加到 Babel 配置中。Babel 插件可以执行各种任务，例如：</p>
<ul>
<li>转换语法：将新的 ECMAScript 特性转换为向后兼容的代码。</li>
<li>转换 API：将使用新 API 的代码转换为旧 API。</li>
<li>转换 JSX：将 JSX 转换为普通的 JavaScript 代码。</li>
</ul>
</li>
<li>
<p>以下是一些常见的 Babel 插件：</p>
<ul>
<li>@babel/plugin-transform-arrow-functions: 将箭头函数转换为普通函数。</li>
<li>@babel/plugin-transform-block-scoping: 将 let 和 const 声明转换为 var 声明。</li>
<li>@babel/plugin-transform-classes: 将类转换为 ES5 构造函数。</li>
<li>@babel/plugin-transform-destructuring: 将解构赋值转换为普通赋值。</li>
<li>@babel/plugin-transform-object-assign: 将 Object.assign() 转换为 ES5 兼容的代码。</li>
<li>@babel/plugin-transform-react-jsx: 将 JSX 转换为普通的 JavaScript 代码。</li>
<li>@babel/plugin-transform-runtime: 避免在每个文件中重复使用 Babel 运行时代码。</li>
</ul>
</li>
<li>
<p>如何使用?</p>
<ul>
<li>比如我们需要转换箭头函数, const 转成 var，那么我们就可以使用箭头函数转换相关的插件：</li>
</ul>
</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 预设 preset</h2>
<p>Babel 的预设（preset）是一组预先配置的转换规则，用于将特定版本的 JavaScript 代码转换为向后兼容的旧版本。以下是一些常用的 Babel 预设：</p>
<ol>
<li>@babel/preset-env: 根据目标环境自动确定需要的转换规则。它根据你在 .babelrc 或 babel.config.js 文件中的配置来确定需要转换的 JavaScript 特性。</li>
<li>@babel/preset-react: 用于转换 React JSX 语法的预设。它可以将 JSX 转换为普通的 JavaScript 代码。</li>
<li>@babel/preset-typescript: 用于转换 TypeScript 代码的预设。它可以将 TypeScript 的类型注解和其他特定语法转换为普通的 JavaScript 代码。</li>
<li>@babel/preset-flow: 用于转换 Flow 类型注解的预设。它可以将 Flow 的类型注解转换为普通的 JavaScript 代码。</li>
</ol>
<p>这些预设可以根据你的项目需求进行选择和配置。你可以在 .babelrc 或 babel.config.js 文件中指定所需的预设，例如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 原理</h2>
<h3> 底层原理</h3>
<ul>
<li>
<p>babel是如何做到将我们的一段代码（ES6、TypeScript、React）转成另外一段代码（ES5）的呢？</p>
<ul>
<li>从一种源代码（原生语言）转换成另一种源代码（目标语言），这是什么的工作呢？</li>
<li>就是编译器，事实上我们可以将babel看成就是一个编译器。</li>
<li>Babel编译器的作用就是将我们的源代码，转换成浏览器可以直接识别的另外一段源代码；</li>
</ul>
</li>
<li>
<p>Babel也拥有编译器的工作流程：</p>
<ul>
<li>解析（Parsing）：Babel首先将输入的JavaScript代码解析成抽象语法树（Abstract Syntax Tree，AST）。AST是一个用于表示代码结构的树状数据结构，它能够准确地描述代码的语法和语义。</li>
<li>转换（Transformation）：在AST的基础上，Babel会应用一系列的插件和预设来进行代码转换。这些插件和预设可以执行各种转换操作，例如语法转换、代码优化、添加兼容性处理等。每个插件都负责处理AST中的特定节点，并根据需要进行修改或替换。</li>
<li>生成（Generation）：转换完成后，Babel会将修改后的AST重新生成为JavaScript代码。这些生成的代码可以是与输入代码相同的版本，也可以是经过转换后的新代码。</li>
</ul>
</li>
<li>
<p>https://github.com/jamiebuilds/the-super-tiny-compiler: 非常简单的编译器实现，旨在教授编译器原理和实践。</p>
</li>
</ul>
<h3> 执行原理</h3>
<blockquote>
<p>Babel的执行阶段</p>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202311162053777.png" alt="image-20231116205304599" tabindex="0" loading="lazy"><figcaption>image-20231116205304599</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202311162053832.png" alt="image-20231116205317664" tabindex="0" loading="lazy"><figcaption>image-20231116205317664</figcaption></figure>
<ol>
<li>词法分析（Lexing）：将输入的源代码字符串转换为一个令牌（Token）序列。每个令牌代表源代码中的一个语法单元，例如标识符、运算符、括号等。</li>
<li>语法分析（Parsing）：将令牌序列转换为抽象语法树（AST）。AST是一个用于描述代码结构的树状数据结构，它能够准确地描述源代码的语法和语义。</li>
<li>转换（Transformation）：在AST的基础上，应用一系列的转换规则，以修改和优化AST。这些规则可以执行各种操作，例如语法转换、代码优化、添加兼容性处理等。</li>
<li>代码生成（Code Generation）：将修改后的AST转换为目标语言的代码。在"The Super Tiny Compiler"中，目标语言是JavaScript。</li>
<li>输出：输出生成的目标代码。</li>
</ol>
<h2> babel-loader</h2>
<ul>
<li>babel-loader是一个用于在Webpack构建过程中将JavaScript代码转换的加载器（loader）。它是与Babel配合使用的常用工具之一。</li>
<li>通过配置Webpack的规则，使用babel-loader可以将指定的JavaScript文件传递给Babel进行转换。Babel会根据配置的插件和预设，将源代码转换为目标浏览器或环境所支持的语法。</li>
<li>指定使用的插件</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311162205301.png" alt="image-20231116220536704" tabindex="0" loading="lazy"><figcaption>image-20231116220536704</figcaption></figure>
<ul>
<li>
<p>presets 预设:  如果我们一个个去安装使用插件，那么需要手动来管理大量的babel插件，我们可以直接给webpack提供一个 preset，webpack会根据我们的预设来加载对应的插件列表，并且将其传递给babel。以下使用 <code>@babel/preset-env</code></p>
<ul>
<li>env</li>
<li>react</li>
<li>TypeScript</li>
</ul>
</li>
<li>
<p>使用 babel-loader 的一般步骤如下：</p>
<ol>
<li>安装 babel-loader 和相关的Babel插件和预设：</li>
</ol>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2">
<li>webpack.config.js，在其中配置 babel-loader：</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h2> 配置文件</h2>
<ul>
<li>我们可以将babel的配置信息放到一个独立的文件中，babel给我们提供了两种配置文件的编写：
<ul>
<li>babel.config.json（或者.js，.cjs，.mjs）文件；</li>
<li>babelrc.json（或者.babelrc，.js，.cjs，.mjs）文件；</li>
</ul>
</li>
<li>它们两个有什么区别呢？目前很多的项目都采用了多包管理的方式（babel本身、element-plus、umi等）；
<ul>
<li>.babelrc.json：早期使用较多的配置方式，但是对于配置Monorepos项目是比较麻烦的；</li>
<li>babel.config.json（babel7）：可以直接作用于Monorepos项目的子包，更加推荐；</li>
<li>补充: <em>Monorepo</em> 是一种项目代码管理方式,指单个仓库中管理多个项目,有助于简化代码共享、版本控制、构建和部署等方面的复杂性,并提供更好的可重用性和协作性, 类似 <code>@babel/preset-env</code> 这种写法大概率就是 Monorepo</li>
</ul>
</li>
<li>以下为 <code>babel.config.js</code></li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>这样在 <code>webpack.config.js</code> 中只需要</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 在 Webpack 中使用 Vue</h2>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>此时重新 <code>build</code> 运行后不显示, 报错如下</p>
<p><code>runtime-core.esm-bundler.js:38 [Vue warn]: Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js" at &lt;App&gt;</code> -&gt; <code>runtime-core.esm-bundler.js:38</code></p>
</blockquote>
<blockquote>
<p>这个错误是因为 Vue 3 默认不包含模板编译器，所以当你试图在组件中使用 <code>template</code> 选项时，你会看到这个警告。</p>
<p>要解决这个问题，你需要在 webpack 配置中添加一个别名，将 "vue" 指向 "vue/dist/vue.esm-bundler.js"。这个版本的 Vue 包含了模板编译器。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>Vue打包后不同版本解析</p>
<ul>
<li>vue(.runtime).global(.prod).js 是用于直接在浏览器中引入的全局版本，可以通过 <code>&lt;script&gt;</code> 标签来使用。
+ 我们之前通过CDN引入和下载的Vue版本就是这个版本；
+ 会暴露一个全局的Vue来使用；</li>
<li>vue(.runtime).esm-browser(.prod).js 是用于原生 ES 模块导入的版本，在支持 ES 模块的浏览器中可以使用 <code>&lt;script type='module'&gt;</code> 来引入。</li>
<li>vue(.runtime).esm-bundler.js 是用于构建工具（如webpack、rollup、parcel等）的版本，默认情况下会使用 vue.runtime.esm-bundler.js。如果需要解析模板（template），则需要手动指定 vue.esm-bundler.js。</li>
<li>vue.cjs(.prod).js 是用于服务器端渲染的版本，在 Node.js 中可以使用 require() 来引入。
<ul>
<li><code>require</code> 是 Node.js 中用于导入模块的函数。它是 CommonJS 模块系统的一部分，这是 Node.js 的默认模块系统。以下是一个 <code>require</code> 的基本用法示例：<code>const fs = require('fs');</code>在这个例子中，我们导入了 Node.js 的内置 <code>fs</code>（文件系统）模块。</li>
<li><code>require</code> 函数也可以用来导入你自己的模块。例如，如果你有一个名为 <code>myModule.js</code> 的文件，你可以这样导入它：<code>const myModule = require('./myModule.js');</code> 注意，当导入自己的模块时，你需要提供模块的相对路径（以 <code>./</code> 开头）。</li>
<li>然而，<code>require</code> 并不是 ECMAScript（JavaScript 的标准化规范）的一部分，因此它在浏览器环境中通常不可用。在浏览器环境中，你通常会使用 ECMAScript 的 <code>import</code> 和 <code>export</code> 语句来导入和导出模块。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>接下来我们把 main.js 中的 vue 代码抽离为单文件组件(SFC)</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>重新打包, 报错：我们需要合适的Loader来处理文件。</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>配置 <code>webpack.config.js</code></li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>重新 build 仍然报错 <code>Error:vue-loader requires @vue/compiler present the dependency tree</code>, 打包依然会报错，这是因为我们必须添加@vue/compiler-sfc来对template进行解析：</p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>重新打包即可支持App.vue的写法</p>
</li>
</ul>
<h2> 补充</h2>
<ul>
<li>
<p>当然此时控制台还有如下报错 <code>You are running the csm-bundler bu1ld of Vue, It is recommended to contigure your bundler to expl1citly roplace featur flag globals with boolean literals to get proper tree-shaking in the fina bundle, See http://link,yuejs.org/feature-flags for more details.</code></p>
</li>
<li>
<p>在官方解释如下: https://github.com/vuejs/core/tree/main/packages/vue#bundler-build-feature-flags</p>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311172346161.png" alt="image-20231117234618957" tabindex="0" loading="lazy"><figcaption>image-20231117234618957</figcaption></figure>
<ul>
<li>Bundler Build Feature Flags是构建工具（Bundler）中的一种特性标志，用于控制Vue框架的不同特性的开启和关闭。从Vue 3.0.0-rc.3版本开始，esm-bundler构建工具现在公开了全局特性标志，可以在编译时进行覆盖。其中两个重要的特性标志包括：
<ul>
<li>VUE_OPTIONS_API：启用/禁用Options API支持，默认为true。</li>
<li>VUE_PROD_DEVTOOLS：启用/禁用生产环境下的devtools支持，默认为false。</li>
</ul>
</li>
<li>在没有配置这些特性标志的情况下，构建工具仍然可以正常工作，但强烈建议正确配置它们以便在最终的打包文件中实现正确的树摇效果。要配置这些特性标志：
<ul>
<li>https://webpack.js.org/plugins/define-plugin/</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>开启Bundler Build Feature Flags的好处在于能够更好地控制Vue框架的特性和功能，从而有效地减少最终打包文件的大小。通过正确配置特性标志，可以实现树摇（tree-shaking）效果，即只包含应用程序实际使用的代码，而不包含未使用的代码。这将有助于提高应用程序的性能和加载速度，并减少资源消耗。此外，通过禁用不需要的特性，还可以减少应用程序的复杂性，并提高代码的可维护性。因此，建议开发人员在使用Vue框架时正确配置Bundler Build Feature Flags，以获得更好的开发和部署体验。</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202311162053777.png" type="image/png"/>
    </item>
    <item>
      <title>Webpack</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/cli/Webpack.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/cli/Webpack.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Webpack</source>
      <description>认识webpack 事实上随着前端的快速发展，目前前端的开发已经变的越来越复杂了： 比如开发过程中我们需要通过模块化的方式来开发； 比如也会使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑， 通过sass、less等方式来编写 css 样式代码； 比如开发过程中，我们还希望实时的监听文件的变化来并且反映到浏览器上，提高开发的效率； 比如开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化； 但是对于很多的前端开发者来说，并不需要思考这些问题，日常的开发中根本就没有面临这些问题： 这是因为目前前端开发我们通常都会直接使用三大框架来开发：Vue、React、Angular； 但是事实上，这三大框架的创建过程我们都是借助于脚手架（CLI）的； 事实上Vue-CLI、create-react-app、Angular-CLI都是基于webpack来帮助我们支持模块化、less、 TypeScript、打包优化等的；</description>
      <pubDate>Wed, 15 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 认识webpack</h2>
<ul>
<li>
<p>事实上随着前端的快速发展，目前前端的开发已经变的越来越复杂了：</p>
<ul>
<li>比如开发过程中我们需要通过模块化的方式来开发；</li>
<li>比如也会使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑， 通过sass、less等方式来编写 css 样式代码；</li>
<li>比如开发过程中，我们还希望实时的监听文件的变化来并且反映到浏览器上，提高开发的效率；</li>
<li>比如开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化；</li>
</ul>
</li>
<li>
<p>但是对于很多的前端开发者来说，并不需要思考这些问题，日常的开发中根本就没有面临这些问题：</p>
<ul>
<li>这是因为目前前端开发我们通常都会直接使用三大框架来开发：Vue、React、Angular；</li>
<li>但是事实上，这三大框架的创建过程我们都是借助于脚手架（CLI）的；</li>
<li>事实上Vue-CLI、create-react-app、Angular-CLI都是基于webpack来帮助我们支持模块化、less、 TypeScript、打包优化等的；</li>
</ul>
</li>
</ul>
<h2> Webpack到底是什么呢？</h2>
<blockquote>
<p>https://webpack.docschina.org/</p>
</blockquote>
<blockquote>
<p>本质上，<strong>webpack</strong> 是一个用于现代 JavaScript 应用程序的 <em>静态模块打包工具</em>。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 <a href="https://webpack.docschina.org/concepts/dependency-graph/" target="_blank" rel="noopener noreferrer">依赖图(dependency graph)</a>，然后将你项目中所需的每一个模块组合成一个或多个 <em>bundles</em>，它们均为静态资源，用于展示你的内容。</p>
<ul>
<li>打包bundler：webpack可以将帮助我们进行打包，所以它是一个打包工具</li>
<li>模块化module：webpack默认支持各种模块化开发，ES Module、CommonJS、AMD等；</li>
</ul>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202311021029845.png" alt="image-20231102102926580" tabindex="0" loading="lazy"><figcaption>image-20231102102926580</figcaption></figure>
<h2> Vue项目加载的文件有哪些呢？</h2>
<ul>
<li>JavaScript的打包：
<ul>
<li>将ES6转换成ES5的语法；</li>
<li>TypeScript的处理，将其转换成JavaScript；</li>
</ul>
</li>
<li>Css的处理：
<ul>
<li>CSS文件模块的加载、提取；</li>
<li>Less、Sass等预处理器的处理；</li>
</ul>
</li>
<li>资源文件img、font：
<ul>
<li>图片img文件的加载；</li>
<li>字体font文件的加载；</li>
</ul>
</li>
<li>HTML资源的处理：
<ul>
<li>打包HTML资源文件；</li>
</ul>
</li>
<li>处理vue项目的SFC文件.vue文件</li>
</ul>
<h2> Webpack的使用</h2>
<ul>
<li>webpack的官方文档是<a href="https://webpack.js.org/" target="_blank" rel="noopener noreferrer">webpack</a>
<ul>
<li>webpack的中文官方文档是<a href="https://webpack.docschina.org/" target="_blank" rel="noopener noreferrer">webpack</a></li>
</ul>
</li>
<li>Webpack的运行是依赖Node环境的，所以我们电脑上必须有Node环境
<ul>
<li>所以我们需要先安装Node.js，并且同时会安装npm；</li>
<li>Node官方网站：<a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer">Node.js</a></li>
</ul>
</li>
</ul>
<h3> Webpack的安装</h3>
<ul>
<li>webpack的安装目前分为两个：webpack、webpack-cli</li>
<li>执行webpack命令，会执行node_modules下的.bin目录下的webpack；</li>
<li>webpack在执行时是依赖webpack-cli的，如果没有安装就会报错；</li>
<li>而webpack-cli中代码执行时，才是真正利用webpack进行编译和打包的过程；</li>
<li>所以在安装webpack时，我们需要同时安装webpack-cli（第三方的脚手架事实上是没有使用webpack-cli的，而是类似于自 己的vue-service-cli的东西）</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311051542731.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h3> Webpack的默认打包</h3>
<blockquote>
<p>ES6、CommonJS等模块化语法在浏览器中是不被直接识别的，但是通过使用Webpack的打包功能，可以将这些语法转换为浏览器可以识别的语法。Webpack可以将多个模块打包成一个或多个浏览器可识别的文件，使得在浏览器中可以正常运行这些模块化代码。</p>
</blockquote>
<ul>
<li>
<p>我们可以通过webpack进行打包，之后运行打包之后的代码</p>
<ul>
<li>在目录下直接执行 webpack 命令</li>
</ul>
</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>
<p>生成一个 dist 文件夹，里面存放一个main.js的文件，就是我们打包之后的文件：</p>
<ul>
<li>这个文件中的代码被压缩和丑化了；</li>
<li>另外我们发现代码中依然存在ES6的语法，比如箭头函数、const等，这是因为默认情况下webpack并不清楚我们打包后的文 件是否需要转成ES5之前的语法，后续我们需要通过babel来进行转换和设置；</li>
</ul>
</li>
<li>
<p>我们发现是可以正常进行打包的，但是有一个问题，webpack是如何确定我们的入口的呢？</p>
<ul>
<li>事实上，当我们运行webpack时，webpack会查找当前目录下的 src/index.js作为入口；</li>
<li>所以，如果当前项目中没有存在 src/index.js 文件，那么会报错；</li>
</ul>
</li>
<li>
<p>当然，我们也可以通过配置来指定入口和出口</p>
</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> webpack 局部安装</h3>
<ol>
<li>版本控制：通过在项目中局部安装Webpack，可以确保每个项目使用的Webpack版本是一致的，避免不同项目之间的版本冲突。</li>
<li>简化部署：将Webpack安装在项目的本地目录中，可以简化项目的部署过程。只需要将整个项目目录复制到其他环境中，不需要再次安装全局的Webpack。</li>
<li>隔离环境：每个项目可以拥有自己独立的Webpack配置和插件，不会受到其他项目的影响。这样可以更灵活地根据项目需求进行定制和配置。</li>
<li>可移植性：通过局部安装Webpack，可以将整个项目打包成一个可移植的文件夹，方便在不同环境中进行迁移和共享。</li>
</ol>
<ul>
<li>第一步：创建package.json文件，用于管理项目的信息、库依赖等</li>
</ul>
<div class="language-csharp line-numbers-mode" data-ext="cs"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>第二步：安装局部的webpack</li>
</ul>
<div class="language-csharp line-numbers-mode" data-ext="cs"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>第三步：使用局部的webpack</li>
</ul>
<div class="language-undefined line-numbers-mode" data-ext="undefined"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>第四步：在 package.json 中创建scripts脚本，执行脚本打包即可</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202311052352789.png" alt="image-20231105235229201" tabindex="0" loading="lazy"><figcaption>image-20231105235229201</figcaption></figure>
<h2> Webpack配置</h2>
<h3> Webpack 配置文件</h3>
<ul>
<li>在通常情况下，webpack需要打包的项目是非常复杂的，并且我们需要一系列的配置来满足要求，默认配置必然 是不可以的。</li>
<li>我们可以在根目录下创建一个webpack.config.js文件，来作为webpack的配置文件：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>继续执行webpack命令，依然可以正常打包</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 指定配置文件</h3>
<ul>
<li>
<p>但是如果我们的配置文件并不是webpack.config.js的名字，而是其他的名字呢？</p>
<ul>
<li>比如我们将webpack.config.js修改成了 wk.config.js；</li>
<li>这个时候我们可以通过 --config 来指定对应的配置文件；</li>
</ul>
</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>但是每次这样执行命令来对源码进行编译，会非常繁琐，所以我们可以在package.json中增加一个新的脚本：</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>之后我们执行 npm run build来打包即可。</li>
</ul>
<h2> Webpack的依赖</h2>
<p>Webpack通过以下步骤对项目进行打包：</p>
<ol>
<li>配置：创建一个Webpack配置文件（通常命名为webpack.config.js），在其中定义打包的入口文件、输出文件的路径、加载器和插件等。</li>
<li>入口：在配置文件中指定打包的入口文件，可以是单个文件或多个文件,  从入口开始，会生成一个 依赖关系图，这个依赖关系图会包含应用程序中所需的所有模块（比如 js 文件、css 文件、图片、字体等), 然后遍历图结构，打包一个个模块（根据文件的不同使用不同的loader来解析）；</li>
<li>加载器：根据需要，配置加载器来处理不同类型的文件。例如，使用babel-loader来转换ES6+代码，使用 css-loader 和 style-loader 来处理CSS文件。</li>
<li>插件：根据需要，配置插件来执行额外的任务。例如，使用html-webpack-plugin生成HTML文件，使用mini-css-extract-plugin提取CSS文件。</li>
<li>输出：在配置文件中指定打包输出的路径和文件名。</li>
<li>运行：在命令行中运行webpack命令，Webpack将根据配置文件进行打包，并生成输出文件。</li>
</ol>
<p>在运行Webpack命令时，可以使用不同的参数和选项来控制打包的行为。例如，使用--mode参数指定打包的模式（开发模式或生产模式），使用--watch选项启用监听模式等。</p>
<figure><img src="https://qiniu.waite.wang/202311060009812.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h2> loader的使用</h2>
<blockquote>
<p>https://webpack.docschina.org/loaders/</p>
<p>在 Webpack5 以后会采用 asset module type 来替代 loader</p>
</blockquote>
<blockquote>
<p>在Webpack中，Loader是用于对不同类型的文件进行转换和处理的模块。它们作为Webpack的一部分，用于在打包过程中对文件进行预处理。</p>
<p>Loader可以将不同类型的文件（如JavaScript、CSS、图片等）转换为模块，以便在应用程序中使用。它们可以执行各种任务，例如将ES6+代码转换为ES5语法、处理CSS文件中的样式、压缩和优化图像等。</p>
<p>Loader通常以链式调用的方式使用，可以根据需要配置多个Loader来处理文件。每个Loader都会对文件进行一次转换，并将转换后的结果传递给下一个Loader，直到最后一个Loader将最终的结果返回给Webpack进行打包。</p>
<p>Loader的配置是通过Webpack的配置文件（通常是webpack.config.js）中的module.rules字段来完成。在这个字段中，可以指定不同类型文件的匹配规则和对应的Loader。</p>
</blockquote>
<h3> css-loader 的使用</h3>
<ul>
<li>对于加载css文件来说，我们需要一个可以读取css文件的loader；</li>
<li>这个loader最常用的是css-loader；</li>
<li>css-loader的安装：</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>如何使用这个loader来加载css文件呢？有三种方式：
<ul>
<li>内联方式；</li>
<li>CLI方式（webpack5中不再使用）；</li>
<li>配置方式；</li>
</ul>
</li>
</ul>
<ol>
<li>
<p>内联方式：内联方式使用较少，因为不方便管理；</p>
<ul>
<li>在引入的样式前加上使用的loader，并且使用 ! 分割；</li>
</ul>
</li>
</ol>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2">
<li>配置方式</li>
</ol>
<ul>
<li>配置方式表示的意思是在我们的webpack.config.js文件中写明配置信息：
<ul>
<li>module.rules中允许我们配置多个loader（因为我们也会继续使用其他的loader，来完成其他文件的加载)</li>
<li>这种方式可以更好的表示loader的配置，也方便后期的维护，同时也让你对各个Loader有一个全局的概览</li>
</ul>
</li>
<li>module.rules的配置如下：
<ul>
<li>rules属性对应的值是一个数组：[Rule]</li>
<li>数组中存放的是一个个的Rule，Rule是一个对象，对象中可以设置多个属性：
<ul>
<li>test属性：用于对 resource（资源）进行匹配的，通常会设置成正则表达式；</li>
<li>use属性：对应的值时一个数组：[UseEntry]
<ul>
<li>UseEntry是一个对象，可以通过对象的属性来设置一些其他属性
<ul>
<li>loader：必须有一个 loader属性，对应的值是一个字符串；</li>
<li>options：可选的属性，值是一个字符串或者对象，值会被传入到loader中；</li>
<li>query：目前已经使用options来替代；</li>
</ul>
</li>
<li>传递字符串（如：use: [ 'style-loader' ]）是 loader 属性的简写方式（如：use: [ { loader: 'style-loader'} ]）；</li>
</ul>
</li>
<li>loader属性： Rule.use: [ { loader } ] 的简写</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> style-loader</h3>
<ul>
<li>
<p>我们已经可以通过css-loader来加载css文件了</p>
<ul>
<li>但是你会发现这个css在我们的代码中并没有生效（页面没有效果）。</li>
</ul>
</li>
<li>
<p>因为css-loader只是负责将.css文件进行解析，并不会将解析之后的css插入到页面中；</p>
</li>
<li>
<p>如果我们希望再完成插入style的操作，那么我们还需要另外一个loader，就是style-loader；</p>
</li>
<li>
<p>安装style-loader：</p>
</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>那么我们应该如何使用style-loader：
<ul>
<li>在配置文件中，添加style-loader；</li>
<li>注意：因为loader的执行顺序是从右向左（或者说从下到上，或者说从后到前的），所以我们需要将style-loader写到 css-loader 的前面；</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> Less工具处理</h3>
<ul>
<li>我们可以使用less工具来完成它的编译转换：</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>执行如下命令：</li>
</ul>
<div class="language-cobol line-numbers-mode" data-ext="cobol"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> less-loader处理</h4>
<ul>
<li>
<p>但是在项目中我们会编写大量的css，它们如何可以自动转换呢？</p>
<ul>
<li>这个时候我们就可以使用less-loader，来自动使用less工具转换less到css；</li>
</ul>
</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> postcss-loader(认识)</h3>
<ul>
<li>什么是PostCSS呢？
<ul>
<li>PostCSS是一个通过JavaScript来转换样式的工具；</li>
<li>这个工具可以帮助我们进行一些CSS的转换和适配，比如自动添加浏览器前缀、css样式的重置； p但是实现这些功能，我们需要借助于PostCSS对应的插件；</li>
</ul>
</li>
<li>如何使用PostCSS呢？主要就是两个步骤：
<ul>
<li>第一步：查找PostCSS在构建工具中的扩展，比如webpack中的postcss-loader；</li>
<li>第二步：选择可以添加你需要的PostCSS相关的插件；</li>
</ul>
</li>
</ul>
<h4> 命令行使用postcss</h4>
<ul>
<li>安装一下它们：postcss、postcss-cli</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>我们编写一个需要添加前缀的css：
<ul>
<li><a href="https://autoprefixer.github.io/" target="_blank" rel="noopener noreferrer">Autoprefixer CSS online</a></li>
<li>我们可以在上面的网站中查询一些添加css属性的样式；</li>
<li>在Webpack中，PostCSS通常用于对CSS文件进行预处理和后处理。您可以使用PostCSS来编写现代CSS语法，然后使用各种插件对其进行处理，例如自动添加CSS前缀、压缩CSS等。</li>
</ul>
</li>
</ul>
<h4> 插件autoprefixer</h4>
<ul>
<li>因为我们需要添加前缀，所以要安装autoprefixer：</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>直接使用使用postcss工具，并且制定使用autoprefixer</li>
</ul>
<div class="language-cobol line-numbers-mode" data-ext="cobol"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p>转化的结果如下</p>
</blockquote>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> postcss-loader</h4>
<ul>
<li>
<p>真实开发中我们必然不会直接使用命令行工具来对css进行处理，而是可以借助于构建工具：</p>
<ul>
<li>在webpack中使用postcss就是使用postcss-loader来处理的；</li>
</ul>
</li>
<li>
<p>我们来安装postcss-loader：</p>
</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>因为postcss需要有对应的插件才会起效果，所以我们需要配置它的plugin；</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>我们可以将 postcss 配置分离, 根目录下新建 postcss.config.js</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>这样在 webpack.config 中只需要 添加 <code>postcss-loader</code> 即可</li>
</ul>
<h4> postcss-preset-env</h4>
<blockquote>
<p><code>postcss-preset-env</code> 是一个 PostCSS 插件，它允许您使用最新的 CSS 特性，同时它会根据您的目标环境自动添加必要的回退。</p>
<p>这个插件包含了 autoprefixer（自动添加浏览器前缀），cssnano（压缩 CSS），以及一些其他的 PostCSS 插件。这意味着您可以在 CSS 中使用最新的特性，例如 CSS Grid，CSS Variables，等等，而不需要担心兼容性问题。</p>
<p>在您的 <code>postcss.config.js</code> 文件中，您已经将 <code>postcss-preset-env</code> 添加为一个插件，这意味着当您运行 PostCSS 时，它将使用 <code>postcss-preset-env</code> 来处理您的 CSS 文件。</p>
</blockquote>
<ul>
<li>
<p>事实上，在配置postcss-loader时，我们配置插件并不需要使用autoprefixer。</p>
</li>
<li>
<p>我们可以使用另外一个插件：postcss-preset-env</p>
<ul>
<li>postcss-preset-env也是一个postcss的插件；</li>
<li>它可以帮助我们将一些现代的CSS特性，转成大多数浏览器认识的CSS，并且会根据目标浏览器或者运行时环境 添加所需的polyfill；</li>
<li>也包括会自动帮助我们添加 autoprefixer（所以相当于已经内置了 autoprefixer）；</li>
</ul>
</li>
<li>
<p>首先，我们需要安装 postcss-preset-env：</p>
</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>之后，我们直接修改掉之前的 autoprefixer 即可;</li>
</ul>
<h3> file-loader</h3>
<ul>
<li>
<p>要处理jpg、png等格式的图片，我们也需要有对应的loader：file-loader</p>
<ul>
<li>file-loader的作用就是帮助我们处理import/require()方式引入的一个文件资源，并且会将它放到我们输出的文件夹中；</li>
<li>当然我们待会儿可以学习如何修改它的名字和所在文件夹；</li>
</ul>
</li>
<li>
<p>安装file-loader：</p>
</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>配置处理图片的Rule：</li>
</ul>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> url-loader</h3>
<ul>
<li>
<p>url-loader和file-loader的工作方式是相似的，但是可以将较小的文件，转成base64的URI。</p>
</li>
<li>
<p>安装url-loader：</p>
</li>
</ul>
<div class="language-coffeescript line-numbers-mode" data-ext="coffeescript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>显示结果是一样的，并且图片可以正常显示；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311112113242.png" alt="image-20231111211324041" tabindex="0" loading="lazy"><figcaption>image-20231111211324041</figcaption></figure>
<ul>
<li>但是在dist文件夹中，我们会看不到图片文件：
<ul>
<li>这是因为我的两张图片的大小分别是38kb和295kb；</li>
<li>默认情况下url-loader会将所有的图片文件转成base64编码</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> url-loader的limit</h4>
<ul>
<li>但是开发中我们往往是小的图片需要转换，但是大的图片直接使用图片即可
<ul>
<li>这是因为小的图片转换base64之后可以和页面一起被请求，减少不必要的请求过程；</li>
<li>而大的图片也进行转换，反而会影响页面的请求速度；</li>
</ul>
</li>
<li>那么，我们如何可以限制哪些大小的图片转换和不转换呢？
<ul>
<li>url-loader有一个options属性limit，可以用于设置转换的限制；</li>
<li>下面的代码38kb的图片会进行base64编码，而295kb的不会；</li>
</ul>
</li>
</ul>
<h3> 字体文件加载</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 文件命名规则</h2>
<ul>
<li>有时候我们处理后的文件名称按照一定的规则进行显示：
<ul>
<li>比如保留原来的文件名、扩展名，同时为了防止重复，包含一个hash值等；</li>
</ul>
</li>
<li>这个时候我们可以使用PlaceHolders来完成，webpack给我们提供了大量的PlaceHolders来显示不同的内容：
<ul>
<li>https://webpack.js.org/loaders/file-loader/#placeholders</li>
</ul>
</li>
<li>我们这里介绍几个最常用的placeholder：
<ul>
<li>[ext]： 处理文件的扩展名；</li>
<li>[name]：处理文件的名称；</li>
<li>[hash]：文件的内容，使用MD4的散列函数处理，生成的一个128位的hash值（32个十六进制）；</li>
<li>[contentHash]：在file-loader中和[hash]结果是一致的（在webpack的一些其他地方不一样，后面会讲到）；</li>
<li>[<code>hash:&lt;length&gt;</code>]：截图hash的长度，默认32个字符太长了；</li>
<li>[path]：文件相对于webpack配置文件的路径；</li>
</ul>
</li>
</ul>
<h3> 设置文件名称</h3>
<ul>
<li>那么我们可以按照如下的格式编写：</li>
<li>这个也是vue的写法；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311061505056.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h3> 设置文件的存放路径</h3>
<ul>
<li>刚才通过 img/ 已经设置了文件夹，这个也是vue、react脚手架中常见的设置方式
<ul>
<li>其实按照这种设置方式就可以了；</li>
<li>当然我们也可以通过outputPath来设置输出的文件夹；</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311061506379.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h2> asset module type</h2>
<ul>
<li>我们当前使用的webpack版本是webpack5：
<ul>
<li>在webpack5之前，加载这些资源我们需要使用一些loader，比如raw-loader 、url-loader、file-loader；</li>
<li>在webpack5开始，我们可以直接使用资源模块类型（asset module type），来替代上面的这些loader；</li>
</ul>
</li>
<li>资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：
<ul>
<li>asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现；</li>
<li>asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现；</li>
<li>asset/source 导出资源的源代码。之前通过使用 raw-loader 实现；</li>
<li>asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现；</li>
</ul>
</li>
</ul>
<h3> asset module type的使用</h3>
<ul>
<li>比如加载图片，我们可以使用下面的方式：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Plugin</h2>
<ul>
<li>Loader是用于特定的模块类型进行转换；</li>
<li>Plugin可以用于执行更加广泛的任务，比如打包优化、资源管理、环境变量注入等；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202311121514761.png" alt="image-20231112151429444" tabindex="0" loading="lazy"><figcaption>image-20231112151429444</figcaption></figure>
<h3> CleanWebpackPlugin</h3>
<ul>
<li>每次修改了一些配置，重新打包时，都需要手动删除dist文件夹：</li>
<li>我们可以借助于一个插件来帮助我们完成，这个插件就是CleanWebpackPlugin；</li>
<li>首先，我们先安装这个插件：</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>之后在插件中配置：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> HtmlWebpackPlugin</h3>
<ul>
<li>
<p>我们的HTML文件是编写在根目录下的，而最终打包的dist文件夹中是没有index.html文件的。</p>
</li>
<li>
<p>在进行项目部署的时，必然也是需要有对应的入口文件index.html；</p>
</li>
<li>
<p>所以我们也需要对index.html进行打包处理；</p>
</li>
<li>
<p>对HTML进行打包处理我们可以使用另外一个插件：HtmlWebpackPlugin；</p>
</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 自定义HTML模板</h4>
<ul>
<li>
<p>如果我们想在自己的模块中加入一些比较特别的内容：</p>
<ul>
<li>比如添加一个noscript标签，在用户的JavaScript被关闭时，给予响应的提示；</li>
<li>比如在开发vue或者react项目时，我们需要一个可以挂载后续组件的根标签</li>
</ul>
</li>
<li>
<p>这个我们需要一个属于自己的index.html模块：</p>
</li>
</ul>
<blockquote>
<p>public/index.html</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>上面的代码中，会有一些类似这样的语法&lt;% 变量 %&gt;，这个是EJS模块填充数据的方式。
<ul>
<li>在配置 HtmlWebpackPlugin 时，我们可以添加如下配置：
<ul>
<li>template：指定我们要使用的模块所在的路径；</li>
<li>title：在进行 htmlWebpackPlugin.options.title 读取时，就会读到该信息；</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> DefinePlugin</h3>
<blockquote>
<p>https://github.com/jantimon/html-webpack-plugin</p>
</blockquote>
<ul>
<li>因为在模板中使用了 <code>BASE_URL</code>, 但是我们并没有设置过这个常量值，所以会出现没有定义的错误 - <code>BASE_URL is not defined</code></li>
<li>这个时候我们可以使用DefinePlugin插件</li>
<li>DefinePlugin允许在编译时创建配置的全局常量，是一个webpack内置的插件（不需要单独安装）：</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> CopyWebpackPlugin</h3>
<ul>
<li>
<p><code>CopyWebpackPlugin</code> 是一个用于 webpack 的插件，它的主要功能是将单个文件或整个目录复制到构建目录。</p>
<p>这个插件在以下情况下非常有用：</p>
<ol>
<li>当你有一些静态资源（例如图片、字体或公共库）需要包含在你的构建中，但是这些资源并不需要通过 webpack 处理时。</li>
<li>当你需要将一些文件复制到构建目录，以便在部署应用程序时使用</li>
</ol>
</li>
<li>
<p>安装CopyWebpackPlugin插件：</p>
</li>
</ul>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>接下来配置CopyWebpackPlugin即可：
<ul>
<li>复制的规则在patterns中设置；</li>
<li>from：设置从哪一个源中开始复制；</li>
<li>to：复制到的位置，可以省略，会默认复制到打包的目录下；</li>
<li>globOptions：设置一些额外的选项，其中可以编写需要忽略的文件：
<ul>
<li>.DS_Store：mac目录下回自动生成的一个文件；</li>
<li>index.html：也不需要复制，因为我们已经通过HtmlWebpackPlugin完成了index.html的生成；</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Mode配置列表</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202311021029845.png" type="image/png"/>
    </item>
    <item>
      <title>认识组件化开发</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/components/%E8%AE%A4%E8%AF%86%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/components/%E8%AE%A4%E8%AF%86%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">认识组件化开发</source>
      <description>认识组件化开发 人面对复杂问题的处理方式： 任何一个人处理信息的逻辑能力都是有限的 所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。 但是，我们人有一种天生的能力，就是将问题进行拆解。 如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，你会发现大的问题也会迎刃而解。 组件化也是类似的思想： 如果我们将一个页面中所有的处理逻辑 全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展； 但如果，我们讲一个页面拆分成一个个 小的功能块，每个功能块完成属于自己 这部分独立的功能，那么之后整个页面 的管理和维护就变得非常容易了； 如果我们将一个个功能块拆分后，就可 以像搭建积木一下来搭建我们的项目； 现在可以说整个的大前端开发都是组件化的天下，无论从三大框架（Vue、React、Angular），还是跨平台方案 的Flutter，甚至是移动端都在转向组件化开发，包括小程序的开发也是采用组件化开发的思想 所以，学习组件化最重要的是它的思想，每个框架或者平台可能实现方法不同，但是思想都是一样的。 我们需要通过组件化的思想来思考整个应用程序： 我们将一个完整的页面分成很多个组件； 每个组件都用于实现页面的一个功能块； 而每一个组件又可以进行细分； 而组件本身又可以在多个地方进行复用；</description>
      <pubDate>Tue, 31 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 认识组件化开发</h2>
<ul>
<li>人面对复杂问题的处理方式：
<ul>
<li>任何一个人处理信息的逻辑能力都是有限的</li>
<li>所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。</li>
<li>但是，我们人有一种天生的能力，就是将问题进行拆解。</li>
<li>如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，你会发现大的问题也会迎刃而解。</li>
</ul>
</li>
<li>组件化也是类似的思想：
<ul>
<li>如果我们将一个页面中所有的处理逻辑 全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展；</li>
<li>但如果，我们讲一个页面拆分成一个个 小的功能块，每个功能块完成属于自己 这部分独立的功能，那么之后整个页面 的管理和维护就变得非常容易了；</li>
<li>如果我们将一个个功能块拆分后，就可 以像搭建积木一下来搭建我们的项目；</li>
</ul>
</li>
<li>现在可以说整个的大前端开发都是组件化的天下，无论从三大框架（Vue、React、Angular），还是跨平台方案 的Flutter，甚至是移动端都在转向组件化开发，包括小程序的开发也是采用组件化开发的思想</li>
<li>所以，学习组件化最重要的是它的思想，每个框架或者平台可能实现方法不同，但是思想都是一样的。</li>
<li>我们需要通过组件化的思想来思考整个应用程序：
<ul>
<li>我们将一个完整的页面分成很多个组件；</li>
<li>每个组件都用于实现页面的一个功能块；</li>
<li>而每一个组件又可以进行细分；</li>
<li>而组件本身又可以在多个地方进行复用；</li>
</ul>
</li>
</ul>
<h2> Vue的组件化</h2>
<ul>
<li>vue 项目起始文件 <code>createApp</code> 函数传入了一个对象App，这个对象其实本质上就是一个组件，也是我们应用程序的根 组件；</li>
<li>组件化提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用；</li>
<li>任何的应用都会被抽象成一颗组件树；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310312042389.png" alt="image-20231031204213497" tabindex="0" loading="lazy"><figcaption>image-20231031204213497</figcaption></figure>
<h2> 组件名称</h2>
<ul>
<li>在通过 <code>app.componen</code> t注册一个组件的时候，第一个参数是组件的名称，定义组件名的方式有两种：</li>
<li>方式一：使用 kebab-case（短横线分割符）
<ul>
<li>当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case， 例如 <code>&lt;my-component-name&gt;</code>;</li>
</ul>
</li>
<li>方式二：使用 PascalCase（驼峰标识符）
<ul>
<li>当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也 就是说  <code>&lt;my-component-name&gt;</code>和 <code>MyComponentName</code>  都是可接受的；</li>
</ul>
</li>
<li>在单文件组件和内联字符串模板中，我们都推荐这样做。但是，PascalCase 的标签名在 DOM 模板中是不可用的，详情参见 <a href="https://cn.vuejs.org/guide/essentials/component-basics.html#in-dom-template-parsing-caveats" target="_blank" rel="noopener noreferrer">DOM 内模板解析注意事项</a>。</li>
<li>为了方便，Vue 支持将模板中使用 kebab-case 的标签解析为使用 PascalCase 注册的组件。这意味着一个以 <code>MyComponent</code> 为名注册的组件，在模板中可以通过 <code>&lt;MyComponent&gt;</code> 或 <code>&lt;my-component&gt;</code> 引用。这让我们能够使用同样的 JavaScript 组件注册代码来配合不同来源的模板。</li>
</ul>
<h2> 注册组件的方式</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/components/registration.html#component-registration</p>
</blockquote>
<ul>
<li>如果我们现在有一部分内容（模板、逻辑等），我们希望将这部分内容抽取到一个独立的组件中去维护，这个时候 如何注册一个组件呢？</li>
<li>我们先从简单的开始谈起，比如下面的模板希望抽离到一个单独的组件：</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>注册组件分成两种：
<ul>
<li>全局组件：在任何其他的组件中都可以使用的组件；</li>
<li>局部组件：只有在注册的组件中才能使用的组件；</li>
</ul>
</li>
</ul>
<h3> 注册全局组件</h3>
<ul>
<li>全局组件需要使用我们全局创建的app来注册组件；</li>
<li>通过component方法传入组件名称、组件对象即可注册一个全局组件了；</li>
<li>之后，我们可以在App组件的template中直接使用这个全局组件：</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>也可以</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 注册局部组件</h3>
<p>全局注册虽然很方便，但有以下几个问题：</p>
<ol>
<li>全局注册，但并没有被使用的组件无法在生产打包时被自动移除 (也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。</li>
<li>全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。</li>
</ol>
<p>相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。</p>
<p>局部注册需要使用 <code>components</code> 选项：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于每个 <code>components</code> 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>请注意：<strong>局部注册的组件在后代组件中并不可用</strong>。在这个例子中，<code>ComponentA</code> 注册后仅在当前组件可用，而在任何的子组件或更深层的子组件中都不可用。</p>
</blockquote>
<ul>
<li>全局组件往往是在应用程序一开始就会全局组件完成，那么就意味着如果某些组件我们并没有用到，也会一起被注 册：
<ul>
<li>比如我们注册了三个全局组件：ComponentA、ComponentB、ComponentC；</li>
<li>在开发中我们只使用了ComponentA、ComponentB，如果ComponentC没有用到但是我们依然在全局进行 了注册，那么就意味着类似于webpack这种打包工具在打包我们的项目时，我们依然会对其进行打包；</li>
<li>这样最终打包出的JavaScript包就会有关于ComponentC的内容，用户在下载对应的JavaScript时也会增加包 的大小；</li>
</ul>
</li>
<li>所以在开发中我们通常使用组件的时候采用的都是局部注册：
<ul>
<li>局部注册是在我们需要使用到的组件中，通过components属性选项来进行注册；</li>
<li>比如之前的App组件中，我们有data、computed、methods等选项了，事实上还可以有一个components选项；</li>
<li>该components选项对应的是一个对象，对象中的键值对是 组件的名称: 组件对象；</li>
</ul>
</li>
</ul>
<h2> Vue的开发模式</h2>
<ul>
<li>目前我们使用vue的过程都是在html文件中，通过template编写自己的模板、脚本逻辑、样式等。</li>
<li>但是随着项目越来越复杂，我们会采用组件化的方式来进行开发：
<ul>
<li>这就意味着每个组件都会有自己的模板、脚本逻辑、样式等；</li>
<li>当然我们依然可以把它们抽离到单独的js、css文件中，但是它们还是会分离开来；</li>
<li>也包括我们的script是在一个全局的作用域下，很容易出现命名冲突的问题；</li>
<li>并且我们的代码为了适配一些浏览器，必须使用ES5的语法；</li>
<li>在我们编写代码完成之后，依然需要通过工具对代码进行构建、代码；</li>
</ul>
</li>
<li>所以在真实开发中，我们可以通过一个后缀名为 .vue 的single-file components (单文件组件) 来解决，并且可以使用 webpack 或者 vite 或者 rollup 等构建工具来对其进行处理。</li>
</ul>
<blockquote>
<p>比如: 我们可以单独抽离组件 componentA</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>在这个组件中我们可以获得非常多的特性：</p>
<ul>
<li>代码的高亮；</li>
<li>ES6、CommonJS的模块化能力；</li>
<li>组件作用域的CSS；</li>
<li>可以使用预处理器来构建更加丰富的组件，比如TypeScript、Babel、Less、Sass等；</li>
</ul>
</blockquote>
<h2> 如何支持SFC</h2>
<ul>
<li>如果我们想要使用这一 componentA.vue 文件，比较常见的是两种方式：
<ul>
<li>方式一：使用Vue CLI来创建项目，项目会默认帮助我们配置好所有的配置选项，可以在其中直接使用.vue文件；</li>
<li>方式二：自己使用webpack或rollup或 vite 这类打包工具，对其进行打包处理；</li>
</ul>
</li>
</ul>
<h2> 组件实例</h2>
<h3> <code>$refs</code></h3>
<blockquote>
<p>https://cn.vuejs.org/api/component-instance.html#refs</p>
</blockquote>
<ul>
<li>某些情况下，我们在组件中想要直接获取到元素对象或者子组件实例：
<ul>
<li>在Vue开发中我们是不推荐进行DOM操作的；</li>
<li>这个时候，我们可以给元素或者组件绑定一个ref的attribute属性；</li>
<li>在Vue 3中，$refs属性用于访问父组件中的子组件或DOM元素。它允许您以编程方式直接引用和操作这些组件或元素。</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，我们通过使用ref属性给子组件命名为<code>childRef</code>，然后可以通过<code>this.$refs.childRef</code>来访问和操作子组件。在点击"Log Child Ref"按钮时，会将子组件实例打印到控制台。</p>
<p>###<code> $parent, $root</code></p>
<blockquote>
<p>https://cn.vuejs.org/api/component-instance.html#parent</p>
</blockquote>
<p>在Vue中，<code>$parent</code>和<code>$root</code>都是用于访问组件层级关系的特殊属性。</p>
<ul>
<li><code>$parent</code>属性用于访问当前组件的父组件实例。通过<code>this.$parent</code>可以访问父组件的属性和方法。</li>
<li><code>$root</code>属性用于访问根组件实例。根组件是Vue应用的最顶层组件，通过<code>this.$root</code>可以访问根组件的属性和方法。</li>
</ul>
<p>这些属性在处理组件之间的通信或访问全局状态时非常有用。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，父组件中通过使用<code>$parent</code>属性访问了父组件实例，使用​<code>$root</code>属性访问了根组件实例，并将它们打印到控制台。</p>
<h2> 组件的 v-model</h2>
<blockquote>
<p>https://cn.vuejs.org/guide/components/v-model.html#component-v-model</p>
</blockquote>
<p><code>v-model</code> 可以在组件上使用以实现双向绑定。</p>
<p>首先让我们回忆一下 <code>v-model</code> 在原生元素上的用法：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在代码背后，模板编译器会对 <code>v-model</code> 进行更冗长的等价展开。因此上面的代码其实等价于下面这段：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而当使用在一个组件上时，<code>v-model</code> 会被展开为如下的形式：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要让这个例子实际工作起来，<code>&lt;CustomInput&gt;</code> 组件内部需要做两件事：</p>
<ol>
<li>将内部原生 <code>&lt;input&gt;</code> 元素的 <code>value</code> attribute 绑定到 <code>modelValue</code> prop</li>
<li>当原生的 <code>input</code> 事件触发时，触发一个携带了新值的 <code>update:modelValue</code> 自定义事件</li>
</ol>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在 <code>v-model</code> 可以在这个组件上正常工作了：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>另一种在组件内实现 <code>v-model</code> 的方式是使用一个可写的，同时具有 getter 和 setter 的 <code>computed</code> 属性。<code>get</code> 方法需返回 <code>modelValue</code> prop，而 <code>set</code> 方法需触发相应的事件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 多个 <code>v-model</code> 绑定</h3>
<p>利用刚才在 <a href="https://cn.vuejs.org/guide/components/v-model.html#v-model-arguments" target="_blank" rel="noopener noreferrer"><code>v-model</code> 参数</a>小节中学到的指定参数与事件名的技巧，我们可以在单个组件实例上创建多个 <code>v-model</code> 双向绑定。</p>
<p>组件上的每一个 <code>v-model</code> 都会同步不同的 prop，而无需额外的选项：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310312042389.png" type="image/png"/>
    </item>
    <item>
      <title>Js 的浅拷贝与深拷贝</title>
      <link>https://brain.sunguoqi.com/web/js/Js%20%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D.html</link>
      <guid>https://brain.sunguoqi.com/web/js/Js%20%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Js 的浅拷贝与深拷贝</source>
      <description>数据类型 在探讨深浅拷贝之前，我们先梳理一下js中的数据类型，js的数据类型分为两类：基本数据类型和引用数据类型 前者是存储在栈内存中，后者是将其地址存在栈内存中，而真实数据存储在堆内存中。 如下图所示，基本类型如number、string、boolean、Null和 undefined 等存储在栈内存中，而引用数据类型如 Array、Object 和函数等则是分别存储数据1的地址、数据2的地址和数据3的地址。</description>
      <pubDate>Mon, 30 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 数据类型</h2>
<ol>
<li>在探讨深浅拷贝之前，我们先梳理一下js中的数据类型，js的数据类型分为两类：基本数据类型和引用数据类型</li>
<li>前者是存储在栈内存中，后者是将其地址存在栈内存中，而真实数据存储在堆内存中。</li>
<li>如下图所示，基本类型如number、string、boolean、Null和 undefined 等存储在栈内存中，而引用数据类型如 Array、Object 和函数等则是分别存储数据1的地址、数据2的地址和数据3的地址。</li>
</ol>
<figure><img src="https://qiniu.waite.wang/202310301908367.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 深浅拷贝</h2>
<blockquote>
<p>js中的基本数据类型：<code>String Number Boolean Null Undefined</code>，在赋值的过程中都是深拷贝。</p>
<p>例如，let a = 10 ; b = a , 修改其中一个变量的值，不会影响到另一个变量的值。</p>
</blockquote>
<h3> 概念</h3>
<ol>
<li>浅拷贝：会在栈中开辟另一块空间，并将被拷贝对象的栈内存数据完全拷贝到该块空间中，即基本数据类型的值会被完全拷贝，而引用类型的值则是拷贝了“指向堆内存的地址”。因此，当修改其中一个变量的值时，会影响到另一个变量的值。</li>
<li>深拷贝：不仅会在栈中开辟另一块空间，若被拷贝对象中有引用类型，则还会在堆内存中开辟另一块空间存储引用类型的真实数据。因此，当修改其中一个变量的值时，不会影响到另一个变量的值。</li>
</ol>
<blockquote>
<p>两者示意图如下：</p>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202310301911328.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址</p>
<p>深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址</p>
</blockquote>
<h2> Js 中的深浅拷贝</h2>
<h3> 浅拷贝</h3>
<blockquote>
<p>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p>
<p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址</p>
</blockquote>
<h4> 手写递归</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 展开语法</h4>
<blockquote>
<p>展开语法(spread syntax)允许一个表达式在期望多个参数(用于函数调用)或多个元素(用于数组字面量)或多个变量(用于解构赋值)的位置扩展。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Object.assign()</h4>
<blockquote>
<p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> slice()</h4>
<blockquote>
<p>slice() 方法可从已有的数组中返回选定的元素。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> concat()</h4>
<blockquote>
<p>concat() 方法用于连接两个或多个数组。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310301917518.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 深拷贝</h3>
<blockquote>
<p>深拷贝开辟一个新的栈，两个对象属性完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p>
</blockquote>
<h4> 手写递归</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Object.entries(obj) 遍历对象</h4>
<blockquote>
<p>Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组</p>
<p>比如：Object.entries({ foo: 'bar', baz: 42 }); // [ ['foo', 'bar'], ['baz', 42] ]</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> JSON.parse(JSON.stringify(待拷贝对象) -&gt; 常用</h4>
<blockquote>
<p>JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串。</p>
<p>比如: JSON.stringify({ x: 5, y: 6 }); // "{"x":5,"y":6}" -&gt; string</p>
<p>JSON.parse() 方法用于将一个 JSON 字符串转换为对象。</p>
<p>比如: JSON.parse('{"name":"cxk","age":18}'); // {name: "cxk", age: 18} -&gt; object</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 其他方法</h4>
<ul>
<li>_.cloneDeep()</li>
<li>jQuery.extend()</li>
<li>手写循环递归</li>
</ul>
<h2> Vue 中的深拷贝实现</h2>
<blockquote>
<p>引入loadsh,提供 cloneDeep 实现深拷贝</p>
</blockquote>
<ol>
<li>安装loadsh    npm i --save lodash</li>
<li>引入loadsh    import _ from 'lodash'</li>
<li>直接调用 loadsh 库的方法 <code>const newObj = _.cloneDeep(this.obj)</code></li>
</ol>
<blockquote>
<p>_clone 实现浅拷贝</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310301908367.png" type="image/png"/>
    </item>
    <item>
      <title>Vue3 基本指令</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/Vue3%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/Vue3%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Vue3 基本指令</source>
      <description>VSCode 代码片段 我们在前面练习Vue的过程中，有些代码片段是需要经常写的，我们再VSCode中我们可以生成一个代码片段，方便我们快速生成。 VSCode中的代码片段有固定的格式，所以我们一般会借助于一个在线工具来完成。 具体的步骤如下： 第一步，复制自己需要生成代码片段的代码； 第二步，https://snippet-generator.app/在该网站中生成代码片段； 第三步，在VSCode中配置代码片段； 直接 Tab trigger 即可自动填充</description>
      <pubDate>Thu, 07 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> VSCode 代码片段</h2>
<ul>
<li>我们在前面练习Vue的过程中，有些代码片段是需要经常写的，我们再VSCode中我们可以生成一个代码片段，方便我们快速生成。</li>
<li>VSCode中的代码片段有固定的格式，所以我们一般会借助于一个在线工具来完成。</li>
<li>具体的步骤如下：
<ul>
<li>第一步，复制自己需要生成代码片段的代码；</li>
<li>第二步，https://snippet-generator.app/在该网站中生成代码片段；</li>
<li>第三步，在VSCode中配置代码片段；</li>
</ul>
</li>
<li>直接 Tab trigger 即可自动填充</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310162330091.png" alt="image-20231016233051010" tabindex="0" loading="lazy"><figcaption>image-20231016233051010</figcaption></figure>
<h2> 模板语法</h2>
<ul>
<li>React的开发模式[了解]
<ul>
<li>React使用的jsx,所以对应的代码都是编写的类似于js的一种语法</li>
<li>之后通过Babe将js编译成 React. create Element函数调用</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>vue也支持 jsx 的开发模式:
<ul>
<li>但是大多数情况下,使用基于HTML的模板语法</li>
<li>在模板中,允许开发者以声明式的方式将 DOM 和底层组件实例的数据绑定在-起;口在底层的实现中,vue将模板编译成虚拟DOM渲染函数</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Mustache 语法 双大括号语法</h2>
<ul>
<li>如果我们希望把数据显示到模板（template）中，使用最多的语法是 “Mustache”语法 (双大括号) 的文本插值。
<ul>
<li>并且我们前端提到过，data返回的对象是有添加到Vue的响应式系统中；</li>
<li>当data中的数据发生改变时，对应的内容也会发生更新。</li>
<li>当然，Mustache中不仅仅可以是data中的属性，也可以是一个JavaScript的表达式。</li>
</ul>
</li>
<li>mustache的使用
1. 基本使用
2. 表达式
3. 函数
4. 三元运算符</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>以下为错误写法</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 不常用指令</h2>
<h3> v-once指令</h3>
<ul>
<li>
<p>v-once用于指定元素或者组件只渲染一次</p>
<ul>
<li>
<p>当数据发生变化时,元素或者组件以及其所有的子元素将视为静态内容并且跳过;</p>
</li>
<li>
<p>该指令可以用于性能优化;</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p>如果是子节点的化，也只能渲染一次</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<blockquote>
<p>完整代码</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-html</h3>
<ul>
<li>默认情况下，如果我们展示的内容本身是 html 的，那么vue并不会对其进行特殊的解析。
<ul>
<li>如果我们希望这个内容被Vue可以解析出来，那么可以使用 v-html 来展示</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310180836759.png" alt="image-20231018083558572" tabindex="0" loading="lazy"><figcaption>image-20231018083558572</figcaption></figure>
<h3> v-text</h3>
<ul>
<li>用于更新元素的 textContent</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-pre</h3>
<ul>
<li>v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签：
<ul>
<li>跳过不需要编译的节点，加快编译的速度</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-cloak</h3>
<ul>
<li>用于隐藏尚未完成编译的 DOM 模板。
<ul>
<li><strong>无需传入</strong></li>
<li><strong>详细信息</strong></li>
</ul>
</li>
<li><strong>该指令只在没有构建步骤的环境下需要使用。</strong>
<ul>
<li>当使用直接在 DOM 中书写的模板时，可能会出现一种叫做“未编译模板闪现”的情况：用户可能先看到的是还没编译完成的双大括号标签，直到挂载的组件将它们替换为实际渲染的内容。</li>
<li><code>v-cloak</code> 会保留在所绑定的元素上，直到相关组件实例被挂载后才移除。配合像 <code>[v-cloak] { display: none }</code> 这样的 CSS 规则，它可以在组件编译完毕前隐藏原始模板。</li>
</ul>
</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>直到编译完成前，<code>&lt;div&gt;</code> 将不可见。</p>
</blockquote>
<h2> v-bind</h2>
<p>动态的绑定一个或多个 attribute，也可以是组件的 prop。</p>
<ul>
<li>
<p><strong>缩写：</strong><code>:</code> 或者 <code>.</code> (当使用 <code>.prop</code> 修饰符)</p>
</li>
<li>
<p><strong>期望：</strong><code>any (带参数) | Object (不带参数)</code></p>
</li>
<li>
<p><strong>参数：</strong><code>attrOrProp (可选的)</code></p>
</li>
<li>
<p><strong>修饰符</strong></p>
<ul>
<li><code>.camel</code> - 将短横线命名的 attribute 转变为驼峰式命名。</li>
<li><code>.prop</code> - 强制绑定为 DOM property。<code>3.2+</code></li>
<li><code>.attr</code> - 强制绑定为 DOM attribute。<code>3.2+</code></li>
</ul>
</li>
<li>
<p><strong>用途</strong></p>
<p>当用于绑定 <code>class</code> 或 <code>style</code> attribute，<code>v-bind</code> 支持额外的值类型如数组或对象。详见下方的指南链接。</p>
<p>在处理绑定时，Vue 默认会利用 <code>in</code> 操作符来检查该元素上是否定义了和绑定的 key 同名的 DOM property。如果存在同名的 property，则 Vue 会将它作为 DOM property 赋值，而不是作为 attribute 设置。这个行为在大多数情况都符合期望的绑定值类型，但是你也可以显式用 <code>.prop</code> 和 <code>.attr</code> 修饰符来强制绑定方式。有时这是必要的，特别是在和<a href="https://cn.vuejs.org/guide/extras/web-components.html#passing-dom-properties" target="_blank" rel="noopener noreferrer">自定义元素</a>打交道时。</p>
<p>当用于组件 props 绑定时，所绑定的 props 必须在子组件中已被正确声明。</p>
<p>当不带参数使用时，可以用于绑定一个包含了多个 attribute 名称-绑定值对的对象。</p>
</li>
<li>
<p><strong>用法</strong></p>
<ul>
<li>动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</li>
</ul>
</li>
</ul>
<blockquote>
<p>小知识: vue3 是允许template中有多个根元素</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 基本使用</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 绑定 class</h3>
<ul>
<li>在开发中,有时候我们的元素 class也是动态的,比如
<ul>
<li>当数据为某个状态时,字体显示红色。</li>
<li>当数据另一个状态时,字体显示黑色</li>
</ul>
</li>
<li>绑定class有两种方式：
<ul>
<li>对象语法</li>
<li>数组语法</li>
</ul>
</li>
</ul>
<h4> 对象语法</h4>
<ul>
<li>对象语法：我们可以传给 :class (v-bind:class 的简写) 一个对象，以动态地切换 class</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 数组语法</h4>
<ul>
<li>绑定class – 数组语法
<ul>
<li>数组语法：我们可以把一个数组传给 :class，以应用一个 class 列表</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 绑定 style</h3>
<ul>
<li>我们可以利用 <code>v-bind:style</code> 来绑定一些CSS内联样式
<ul>
<li>这次因为某些样式我们需要根据数据动态来决定</li>
<li>比如某段文字的颜色，大小等等</li>
</ul>
</li>
<li>CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名</li>
<li>绑定class有两种方式
<ul>
<li>对象语法</li>
<li>数组语法</li>
</ul>
</li>
</ul>
<blockquote>
<p>CSS property 名短横线分隔 (kebab-case，记得用引号括起来)</p>
</blockquote>
<h4> 对象语法</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 数组语法</h4>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 动态绑定属性</h3>
<ul>
<li>在某些情况下，我们属性的名称可能也不是固定的
<ul>
<li>前端我们无论绑定src、href、class、style，属性名称都是固定的</li>
<li>如果属性名称不是固定的，我们可以使用 :[属性名]=“值” 的格式来定义</li>
<li>这种绑定的方式，我们称之为 <code>动态绑定属性</code>；如下:</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 属性直接绑定一个对象</h3>
<ul>
<li>如果我们希望将一个对象的所有属性，绑定到元素上的所有属性，应该怎么做呢？
<ul>
<li>非常简单，我们可以直接使用 v-bind 绑定一个 对象</li>
</ul>
</li>
<li>案例：info对象会被拆解成div的各个属性</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> v-on</h2>
<ul>
<li>
<p>v-on绑定事件</p>
<ul>
<li>前面我们绑定了元素的内容和属性，在前端开发中另外一个非常重要的特性就是交互。</li>
<li>在前端开发中，我们需要经常和用户进行各种各样的交互
<ul>
<li>这个时候，我们就必须监听用户发生的事件，比如点击、拖拽、键盘事件等等</li>
<li>在Vue中如何监听事件呢？使用v-on指令。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>v-on的用法</p>
<ul>
<li>缩写：@</li>
<li>预期：Function | Inline Statement | Object</li>
<li>参数：event p 修饰符：
<ul>
<li>.stop - 调用 event.stopPropagation()。</li>
<li>.prevent - 调用 event.preventDefault()。</li>
<li>.capture - 添加事件侦听器时使用 capture 模式。</li>
<li>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>
<li>.{keyAlias} - 仅当事件是从特定键触发时才触发回调。</li>
<li>.once - 只触发一次回调。</li>
<li>.left - 只当点击鼠标左键时触发。</li>
<li>.right - 只当点击鼠标右键时触发。</li>
<li>.middle - 只当点击鼠标中键时触发。</li>
<li>.passive - { passive: true } 模式添加侦听器</li>
</ul>
</li>
</ul>
<ul>
<li>用法：绑定事件监听</li>
</ul>
</li>
</ul>
<blockquote>
<p>event 事件可以参考 https://developer.mozilla.org/en-US/docs/Web/Events</p>
</blockquote>
<h3> 基本使用</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 参数传递</h3>
<ul>
<li>当通过methods中定义方法，以供 <code>@click</code>调用时，需要注意参数问题：</li>
<li>情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。
<ul>
<li>但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去</li>
</ul>
</li>
<li>情况二：如果需要同时传入某个参数，同时需要 <code>event</code> 时，可以通过 <code>$event</code> 传入事件。</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310190046946.png" alt="image-20231019004604619" tabindex="0" loading="lazy"><figcaption>image-20231019004604619</figcaption></figure>
<h3> v-on <strong>的修饰符</strong></h3>
<ul>
<li>v-on支持修饰符，修饰符相当于对事件进行了一些特殊的处理：
<ul>
<li>.stop - 调用 event.stopPropagation()。</li>
<li>.prevent - 调用 event.preventDefault()。</li>
<li>.capture - 添加事件侦听器时使用 capture 模式。</li>
<li>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>
<li>.{keyAlias} - 仅当事件是从特定键触发时才触发回调。</li>
<li>.once - 只触发一次回调。</li>
<li>.left - 只当点击鼠标左键时触发。</li>
<li>.right - 只当点击鼠标右键时触发。</li>
<li>.middle - 只当点击鼠标中键时触发。</li>
<li>.passive - { passive: true } 模式添加侦听器</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>stopPropagation</code> 是一个事件修饰符，用于阻止事件冒泡。在 Vue.js 中，当一个元素上的事件被触发时，它会先执行该元素上的事件处理函数，然后再冒泡到该元素的父元素，继续执行父元素的事件处理函数。使用 <code>stopPropagation</code> 可以阻止事件继续冒泡到父元素。在给元素绑定事件时，可以使用 <code>@click.stop</code> 来阻止 <code>click</code> 事件冒泡到父元素。</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310190052768.png" alt="image-20231019005251770" tabindex="0" loading="lazy"><figcaption>image-20231019005251770</figcaption></figure>
<h2> 条件渲染</h2>
<ul>
<li>在某些情况下，我们需要根据当前的条件决定某些元素或组件是否渲染，这个时候我们就需要进行条件判断了。
<ul>
<li>Vue提供了下面的指令来进行条件判断：
<ul>
<li>v-if</li>
<li>v-else</li>
<li>v-else-if</li>
<li>v-show</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3> 基本使用</h3>
<ul>
<li>v-if、v-else、v-else-if用于根据条件来渲染某一块的内容：
<ul>
<li>这些内容只有在条件为true时，才会被渲染出来；</li>
<li>这三个指令与JavaScript的条件语句if、else、else if类似；</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> template 和  v-if  结合使用</h3>
<ul>
<li>v-if的渲染原理：
<ul>
<li>v-if是惰性的；</li>
<li>当条件为false时，其判断的内容完全不会被渲染或者会被销毁掉；</li>
<li>当条件为true时，才会真正渲染条件块中的内容;</li>
</ul>
</li>
<li>template元素
<ul>
<li>因为v-if是一个指令，所以必须将其添加到一个元素上：
<ul>
<li>但是如果我们希望切换的是多个元素呢？</li>
<li>此时我们渲染div，但是我们并不希望div这种元素被渲染；</li>
<li>这个时候，我们可以选择使用template；</li>
</ul>
</li>
<li>template元素可以当做不可见的包裹元素，并且在v-if上使用，但是最终template不会被渲染出来：
<ul>
<li>有点类似于小程序中的block</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-show</h3>
<ul>
<li>v-show和v-if的用法看起来是一致的，也是根据一个条件决定是否显示元素或者组件</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-show和v-if的区别</h3>
<ul>
<li>首先，在用法上的区别：
<ul>
<li>v-show是不支持template；</li>
<li>v-show不可以和v-else一起使用；</li>
</ul>
</li>
<li>其次，本质的区别：
<ul>
<li>v-show元素无论是否需要显示到浏览器上，它的DOM实际都是有渲染的，只是通过CSS的display属性来进行 切换；</li>
<li>v-if当条件为false时，其对应的元素压根不会被渲染到DOM中；</li>
</ul>
</li>
<li>开发中如何进行选择呢？
<ul>
<li>如果我们的元素需要在显示和隐藏之间频繁的切换，那么使用v-show；</li>
<li>如果不会频繁的发生切换，那么使用v-if；</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310192228448.png" alt="image-20231019222841008" tabindex="0" loading="lazy"><figcaption>image-20231019222841008</figcaption></figure>
<h2> 列表渲染</h2>
<ul>
<li>在真实开发中，我们往往会从服务器拿到一组数据，并且需要对其进行渲染。
<ul>
<li>这个时候我们可以使用v-for来完成；</li>
<li>v-for类似于JavaScript的for循环，可以用于遍历一组数据；</li>
</ul>
</li>
</ul>
<h3> 基本使用</h3>
<ul>
<li>
<p>n v-for的基本格式是 "item in 数组"：</p>
<ul>
<li>数组通常是来自data或者prop，也可以是其他方式；</li>
<li>item是我们给每项元素起的一个别名，这个别名可以自定来定义；</li>
</ul>
</li>
<li>
<p>我们知道，在遍历一个数组的时候会经常需要拿到数组的索引：</p>
<ul>
<li>如果我们需要索引，可以使用格式： "(item, index) in 数组"；</li>
<li>注意上面的顺序：数组元素项item是在前面的，索引项index是在后面的；</li>
</ul>
</li>
<li>
<p>v-for支持的类型</p>
<ul>
<li>v-for也支持遍历对象，并且支持有一二三个参数：
<ul>
<li>一个参数： "value in object";</li>
<li>二个参数： "(value, key) in object";</li>
<li>三个参数： "(value, key, index) in object";</li>
</ul>
</li>
<li>v-for同时也支持数字的遍历：
<ul>
<li>每一个item都是一个数字；</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> template元素使用</h3>
<ul>
<li>类似于v-if，你可以使用 template 元素来循环渲染一段包含多个元素的内容：
<ul>
<li>我们使用template来对多个元素进行包裹，而不是使用div来完成；</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 数组更新检测</h3>
<ul>
<li>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
</li>
<li>替换数组的方法
<ul>
<li>上面的方法会直接修改原来的数组，但是某些方法不会替换原来的数组，而是会生成新的数组，比如 filter()、 concat() 和 slice()。</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> v-for 中的 key 是什么作用？</h3>
<blockquote>
<p>https://cn.vuejs.org/api/built-in-special-attributes.html#key</p>
</blockquote>
<ul>
<li>
<p>在使用v-for进行列表渲染时，我们通常会给元素或者组件绑定一个key属性。</p>
</li>
<li>
<p>这个key属性有什么作用呢？我们先来看一下官方的解释：</p>
<ul>
<li>
<p>key属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes；</p>
</li>
<li>
<p>如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法；</p>
</li>
<li>
<p>而使用key时，它会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素；</p>
</li>
</ul>
</li>
<li>
<p>官方的解释对于初学者来说并不好理解，比如下面的问题：</p>
<ul>
<li>什么是新旧nodes，什么是VNode？</li>
<li>没有key的时候，如何尝试修改和复用的？</li>
<li>有key的时候，如何基于key重新排列的？</li>
</ul>
</li>
</ul>
<h4> 认识 VNode</h4>
<ul>
<li>我们先来解释一下VNode的概念：
<ul>
<li>因为目前我们还没有比较完整的学习组件的概念，所以目前我们先理解HTML元素创建出来的VNode；</li>
<li>VNode的全称是Virtual Node，也就是虚拟节点；</li>
<li>事实上，无论是组件还是元素，它们最终在Vue中表示出来的都是一个个VNode；</li>
<li>VNode的本质是一个JavaScript的对象；可以用于描述某一个标签/ 元素 的样子</li>
<li>好处: 多平台的渲染, 跨平台(主要好处)</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310201628396.png" alt="image-20231020162812819" tabindex="0" loading="lazy"><figcaption>image-20231020162812819</figcaption></figure>
<h4> 虚拟 DOM</h4>
<ul>
<li>如果我们不只是一个简单的div，而是有一大堆的元素，那么它们应该会形成一个 VNode Tree</li>
<li>虚拟 DOM 与 真实 DOM 不一定一一对应</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310201631261.png" alt="image-20231020163154944" tabindex="0" loading="lazy"><figcaption>image-20231020163154944</figcaption></figure>
<h4> 插入 F 的案例</h4>
<ul>
<li>
<p>我们先来看一个案例：这个案例是当我点击按钮时会在中间插入一个f；</p>
</li>
<li>
<p>我们可以确定的是，这次更新对于ul和button是不需要进行更新，需要更新的是我们 li 的列表：</p>
<ul>
<li>
<p>在Vue中，对于相同父元素的子元素节点并不会重新渲染整个列 表；</p>
</li>
<li>
<p>因为对于列表中 a、b、c、d它们都是没有变化的；</p>
</li>
<li>
<p>在操作真实DOM的时候，我们只需要在中间插入一个 f 的 li 即可；</p>
</li>
</ul>
</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>那么Vue中对于列表的更新究竟是如何操作的呢？
<ul>
<li>Vue事实上会对于有key和没有key会调用两个不同的方法；</li>
</ul>
</li>
</ul>
<h5> Vue源码对于key的判断</h5>
<ul>
<li>有key，那么就使用 patchKeyedChildren方法；</li>
<li>没有key，那么久使用 patchUnkeyedChildren方法；</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310201647317.png" alt="image-20231020164733530" tabindex="0" loading="lazy"><figcaption>image-20231020164733530</figcaption></figure>
<blockquote>
<p>diff算法: diff 算法是指生成更新补丁的方式,主要应用于虚拟 DOM 树变化后,更新真实 DOM。所以 diff 算法一定存在这样一个过程:触发更新 → 生成补丁 → 应用补丁。</p>
</blockquote>
<ul>
<li>没有key的操作过程</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310221823690.png" alt="image-20231022182341619" tabindex="0" loading="lazy"><figcaption>image-20231022182341619</figcaption></figure>
<ul>
<li>我们会发现上面的diff算法效率并不高：
<ul>
<li>c和d来说它们事实上并不需要有任何的改动；</li>
<li>但是因为我们的c被f所使用了，所有后续所有的内容都要一次进行改动，并且最后进行新增；</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310221820519.png" alt="image-20231022182012027" tabindex="0" loading="lazy"><figcaption>image-20231022182012027</figcaption></figure>
<ul>
<li>有key的操作过程-diff算法
<ul>
<li>第一步的操作是从头开始进行遍历、比较：
<ul>
<li>a和b是一致的会继续进行比较；</li>
<li>c和f因为key不一致，所以就会break跳出循环</li>
</ul>
</li>
<li>第二步的操作是从尾部开始进行遍历、比较</li>
<li>第三步是如果旧节点遍历完毕，但是依然有新的节点，那么就新增节点：</li>
<li>第四步是如果新的节点遍历完毕，但是依然有旧的节点，那么就移除旧节点：</li>
<li>第五步是最特色的情况，中间还有很多未知的或者乱序的节点：</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310221822567.png" alt="image-20231022182232738" tabindex="0" loading="lazy"><figcaption>image-20231022182232738</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202310221821946.png" alt="image-20231022182140133" tabindex="0" loading="lazy"><figcaption>image-20231022182140133</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202310221822262.png" alt="image-20231022182241976" tabindex="0" loading="lazy"><figcaption>image-20231022182241976</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202310221822079.png" alt="image-20231022182251535" tabindex="0" loading="lazy"><figcaption>image-20231022182251535</figcaption></figure>
<figure><img src="https://qiniu.waite.wang/202310221823627.png" alt="image-20231022182300781" tabindex="0" loading="lazy"><figcaption>image-20231022182300781</figcaption></figure>
<h5> 有无key的结论</h5>
<ul>
<li>有无key的结论
<ul>
<li>所以我们可以发现，Vue在进行diff算法的时候，会尽量利用我们的key来进行优化操作：
<ul>
<li>在没有key的时候我们的效率是非常低效的；</li>
<li>在进行插入或者重置顺序的时候，保持相同的key可以让diff算法更加的高效；</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310162330091.png" type="image/png"/>
    </item>
    <item>
      <title>Vue 的Options API</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/Vue3%E7%9A%84Options-API.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/Vue3%E7%9A%84Options-API.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">Vue 的Options API</source>
      <description>Computed 认识计算属性 我们知道，在模板中可以直接通过插值语法显示一些data中的数据。 但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示； 比如我们需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示； 在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算； 在模板中放入太多的逻辑会让模板过重和难以维护； 并且如果多个地方都使用到，那么会有大量重复的代码；</description>
      <pubDate>Tue, 31 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Computed</h2>
<h3> 认识计算属性</h3>
<p>我们知道，在模板中可以直接通过插值语法显示一些data中的数据。</p>
<p>但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示；</p>
<ul>
<li>比如我们需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示；</li>
<li>在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算；</li>
<li>在模板中放入太多的逻辑会让模板过重和难以维护；</li>
<li>并且如果多个地方都使用到，那么会有大量重复的代码；</li>
</ul>
<p>我们有没有什么方法可以将逻辑抽离出去呢？</p>
<ul>
<li>可以，其中一种方式就是将逻辑抽取到一个method中，放到methods的options中；</li>
<li>但是，这种做法有一个直观的弊端，就是所有的data使用过程都会变成了一个方法的调用；</li>
<li>另外一种方式就是使用计算属性computed；</li>
</ul>
<p>什么是计算属性呢？</p>
<ul>
<li>https://cn.vuejs.org/api/reactivity-core.html#computed</li>
<li>官方并没有给出直接的概念解释；</li>
<li>而是说：对于任何包含响应式数据的复杂逻辑，你都应该使用<strong>计算属性</strong>；</li>
<li>计算属性将被混入到组件实例中。所有 getter 和 setter 的 <code>this</code> 上下文自动地绑定为组件实例；</li>
</ul>
<h3> 基本使用</h3>
<p>计算属性的用法：</p>
<ul>
<li><strong>选项：</strong> computed</li>
<li><strong>类型：</strong><code>{ [key: string]: Function | { get: Function, set: Function } }</code></li>
</ul>
<p>我们来看三个案例：</p>
<ul>
<li>我们有两个变量：firstName 和 lastName，希望它们拼接之后在界面上显示；</li>
<li>我们有一个分数：score
<ul>
<li>当score大于60的时候，在界面上显示及格；</li>
<li>当score小于60的时候，在界面上显示不及格；</li>
</ul>
</li>
<li>我们有一个变量message，记录一段文字：比如Hello World
<ul>
<li>某些情况下我们是直接显示这段文字；</li>
<li>某些情况下我们需要对这段文字进行反转；</li>
</ul>
</li>
<li>我们可以有三种实现思路：
<ul>
<li>思路一：在模板语法中直接使用表达式；</li>
<li>思路二：使用method对逻辑进行抽取；</li>
<li>思路三：使用计算属性computed；</li>
</ul>
</li>
</ul>
<h4> 在模板语法中直接使用表达式</h4>
<ul>
<li>缺点一：模板中存在大量的复杂逻辑，不便于维护（模板中表达式的初衷是用于简单的计算）；</li>
<li>缺点二：当有多次一样的逻辑时，存在重复的代码；</li>
<li>缺点三：多次使用的时候，很多运算也需要多次执行，没有缓存；</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 使用method对逻辑进行抽取</h4>
<ul>
<li>缺点一：我们事实上先显示的是一个结果，但是都变成了一种方法的调用；</li>
<li>缺点二：多次使用方法的时候，没有缓存，也需要多次计算；</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> computed 实现</h4>
<ul>
<li>注意：计算属性看起来像是一个函数，但是我们在使用的时候不需要加()，这个后面讲setter和getter时会讲到；</li>
<li>我们会发现无论是直观上，还是效果上计算属性都是更好的选择；</li>
<li>并且计算属性是有缓存的；</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 计算属性 vs methods</h3>
<p>在上面的实现思路中，我们会发现计算属性和methods的实现看起来是差别是不大的，而且我们多次提到计算属性有缓存。</p>
<p>接下来我们来看一下同一个计算多次使用，计算属性和methods的差异：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>打印结果如下：</p>
<ul>
<li>我们会发现methods在多次使用时，会调用多次；</li>
<li>而计算属性虽然使用了多次，但是计算的过程只调用了一次；</li>
<li>这是因为计算属性会基于它们的依赖关系进行缓存；</li>
<li>在数据不发生变化时，计算属性是不需要重新计算的；</li>
<li>但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算；如下:</li>
</ul>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>当 score 变化, console 输出如下:</p>
</blockquote>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 计算属性的 setter 和 getter</h3>
<p>计算属性在大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数。</p>
<p>但是，如果我们确实想设置计算属性的值呢？</p>
<ul>
<li>这个时候我们也可以给计算属性设置一个setter的方法；</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>以下为内部判断</p>
</blockquote>
<figure><img src="https://qiniu.waite.wang/202310251728011.jpeg" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>
<h2> 侦听器 watch</h2>
<blockquote>
<p>用于声明在数据更改时调用的侦听回调。<code>watch</code> 选项期望接受一个对象，其中键是需要侦听的响应式组件实例属性 (例如，通过 <code>data</code> 或 <code>computed</code> 声明的属性)——值是相应的回调函数。该回调函数接受被侦听源的新值和旧值。</p>
</blockquote>
<ul>
<li>什么是侦听器？
<ul>
<li>开发中我们在data返回的对象中定义了数据，这个数据通过插值语法等方式绑定到template中;</li>
<li>当数据变化时，template会自动进行更新来显示最新的数据;</li>
<li>但是在某些情况下，我们希望在代码逻辑中监听某个数据的变化，这个时候就需要用侦听器watch来完成了;</li>
</ul>
</li>
<li>用法如下：
<ul>
<li>选项：watch</li>
<li>类型: <code>{[key: string]: string | Function | Object | Array}</code></li>
</ul>
</li>
</ul>
<h3> 简单案例</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 配置选项</h3>
<ul>
<li><code>watch</code> 默认是浅层的：被侦听的属性，仅在被赋新值时，才会触发回调函数——而嵌套属性的变化不会触发。如果想侦听所有嵌套的变更，你需要深层侦听器：</li>
<li>以下为不使用深度监听, 当 info.name 在方法中被赋值改变时, 页面会改变, 但是watch不会侦听到, 理由如上</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>将 watch 中更改如下, 不管多深都会侦听到</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>immediate: true</code> 立即执行,  这个时候无论后面数据是否有变化，侦听的函数都会有限执行一次；即当刷新页面时会立刻执行一次, 回调函数的初次执行就发生在 <code>created</code> 钩子之前。Vue 此时已经处理了 <code>data</code>、<code>computed</code> 和 <code>methods</code> 选项，所以这些属性在第一次调用时就是可用的。</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p>注意: 引用对象 or watch 不能侦听到旧值, 可以利用 计算属性 缓存旧值, 或者自己深拷贝一份作为保存</p>
</blockquote>
<h3> 其他方式</h3>
<blockquote>
<p>https://cn.vuejs.org/api/options-state.html#watch</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> $watch 的API：</h4>
<ul>
<li>https://cn.vuejs.org/api/component-instance.html#watch</li>
</ul>
<ul>
<li>我们可以在created的生命周期（后续会讲到）中，使用 this.$watchs 来侦听；</li>
<li>
<ul>
<li>第一个参数是要侦听的源；</li>
<li>第二个参数是侦听的回调函数callback；</li>
<li>第三个参数是额外的其他选项，比如deep、immediate；</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 阶段案例</h2>
<blockquote>
<p>现在我们来做一个相对综合一点的练习：书籍购物车</p>
</blockquote>
<ul>
<li>css</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>index</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> v-model</h2>
<ul>
<li>
<p><code>v-model</code> 可以在组件上使用以实现双向绑定。</p>
</li>
<li>
<p>首先让我们回忆一下 <code>v-model</code> 在原生元素上的用法：</p>
<p>template</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>在代码背后，模板编译器会对 <code>v-model</code> 进行更冗长的等价展开。因此上面的代码其实等价于下面这段：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>而当使用在一个组件上时，<code>v-model</code> 会被展开为如下的形式：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>要让这个例子实际工作起来，<code>&lt;CustomInput&gt;</code> 组件内部需要做两件事：</p>
<ol>
<li>将内部原生 <code>&lt;input&gt;</code> 元素的 <code>value</code> attribute 绑定到 <code>modelValue</code> prop</li>
<li>当原生的 <code>input</code> 事件触发时，触发一个携带了新值的 <code>update:modelValue</code> 自定义事件</li>
</ol>
</li>
</ul>
<h3> 内部实现</h3>
<figure><img src="https://qiniu.waite.wang/202310311437450.jpeg" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>
<h3> 绑定其他表单</h3>
<blockquote>
<p>具体可以看: https://cn.vuejs.org/guide/essentials/forms.html#modifiers</p>
</blockquote>
<blockquote>
<p>在 HTML 中，<code>&lt;label&gt;</code> 标签的 <code>for</code> 属性被用来关联 <code>&lt;label&gt;</code> 标签和表单控件（如 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 等）。<code>for</code> 属性的值应该是你想要关联的表单控件的 <code>id</code>。 当 <code>&lt;label&gt;</code> 被点击时，与其关联的表单控件会获得焦点。</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://qiniu.waite.wang/202310312002330.png" alt="image-20231031200224648" tabindex="0" loading="lazy"><figcaption>image-20231031200224648</figcaption></figure>
<p>目前我们在前面的案例中大部分的值都是在template中固定好的：</p>
<ul>
<li>比如gender的两个输入框值male、female；</li>
<li>比如hobbies的三个输入框值basketball、football、tennis；</li>
</ul>
<p>在真实开发中，我们的数据可能是来自服务器的，那么我们就可以先将值请求下来，绑定到data返回的对象中，再通过v-bind来进行值的绑定，这个过程就是值绑定。</p>
<h3> 修饰符</h3>
<h4> 内置修饰符</h4>
<h5> <code>.lazy</code></h5>
<p>默认情况下，<code>v-model</code> 会在每次 <code>input</code> 事件后更新数据 (<a href="https://cn.vuejs.org/guide/essentials/forms.html#vmodel-ime-tip" target="_blank" rel="noopener noreferrer">IME 拼字阶段的状态</a>例外)。你可以添加 <code>lazy</code> 修饰符来改为在每次 <code>change</code> 事件后更新数据：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5> <a href="https://cn.vuejs.org/guide/essentials/forms.html#number" target="_blank" rel="noopener noreferrer"><code>.number</code></a></h5>
<p>如果你想让用户输入自动转换为数字，你可以在 <code>v-model</code> 后添加 <code>.number</code> 修饰符来管理输入：</p>
<p>另外，在我们进行逻辑判断时，如果是一个string类型，在可以转化的情况下会进行隐式转换的：</p>
<ul>
<li>下面的score在进行判断的过程中会进行隐式转化的；</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果该值无法被 <code>parseFloat()</code> 处理，那么将返回原始值。</p>
<p><code>number</code> 修饰符会在输入框有 <code>type="number"</code> 时自动启用。</p>
<h5> <a href="https://cn.vuejs.org/guide/essentials/forms.html#trim" target="_blank" rel="noopener noreferrer"><code>.trim</code></a></h5>
<p>如果你想要默认自动去除用户输入内容中两端的空格，你可以在 <code>v-model</code> 后添加 <code>.trim</code> 修饰符：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 自定义的修饰符</h4>
<p>在某些场景下，你可能想要一个自定义组件的 <code>v-model</code> 支持自定义的修饰符。</p>
<p>我们来创建一个自定义的修饰符 <code>capitalize</code>，它会自动将 <code>v-model</code> 绑定输入的字符串值第一个字母转为大写：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>组件的 <code>v-model</code> 上所添加的修饰符，可以通过 <code>modelModifiers</code> prop 在组件内访问到。在下面的组件中，我们声明了 <code>modelModifiers</code> 这个 prop，它的默认值是一个空对象：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意这里组件的 <code>modelModifiers</code> prop 包含了 <code>capitalize</code> 且其值为 <code>true</code>，因为它在模板中的 <code>v-model</code> 绑定 <code>v-model.capitalize="myText"</code> 上被使用了。</p>
<p>有了这个 prop，我们就可以检查 <code>modelModifiers</code> 对象的键，并编写一个处理函数来改变抛出的值。在下面的代码里，我们就是在每次 <code>&lt;input /&gt;</code> 元素触发 <code>input</code> 事件时将值的首字母大写：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 多个 <code>v-model</code> 绑定</h3>
<p>我们可以在单个组件实例上创建多个 <code>v-model</code> 双向绑定。</p>
<p>组件上的每一个 <code>v-model</code> 都会同步不同的 prop，而无需额外的选项：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310251728011.jpeg" type="image/jpeg"/>
    </item>
    <item>
      <title>邂逅Vue3开发</title>
      <link>https://brain.sunguoqi.com/web/vue/learn/essential/%E9%82%82%E9%80%85%20Vue%20%E5%BC%80%E5%8F%91.html</link>
      <guid>https://brain.sunguoqi.com/web/vue/learn/essential/%E9%82%82%E9%80%85%20Vue%20%E5%BC%80%E5%8F%91.html</guid>
      <source url="https://brain.sunguoqi.com/rss.xml">邂逅Vue3开发</source>
      <description>认识 Vue 什么是 Vue Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。 全程是Vue.js或者Vuejs； 什么是渐进式框架呢？表示我们可以在项目中一点点来引入和使用Vue，而不一定需要全部使用Vue来开发整个 项目； Vue3带来的变化 源码通过monorepo的形式来管理源代码： Mono：单个 Repo：repository仓库 主要是将许多项目的代码存储在同一个 repository 中； 这样做的目的是多个包本身相互独立，可以有自己的功能逻辑、单元测试等，同时又在同一个仓库下方便管理； 而且模块划分的更加清晰，可维护性、可扩展性更强； 源码使用TypeScript来进行重写： 在Vue2.x的时候，Vue使用 Flow 来进行类型检测； 在Vue3.x的时候，Vue的源码全部使用 TypeScript 来进行重构，并且 Vue 本身对 TypeScript 支持也更好了；</description>
      <pubDate>Thu, 07 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 认识 Vue</h2>
<h3> 什么是 Vue</h3>
<ul>
<li>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。
<ul>
<li>全程是Vue.js或者Vuejs；</li>
<li>什么是渐进式框架呢？表示我们可以在项目中一点点来引入和使用Vue，而不一定需要全部使用Vue来开发整个 项目；</li>
</ul>
</li>
</ul>
<h3> Vue3带来的变化</h3>
<ul>
<li>源码通过monorepo的形式来管理源代码：
<ul>
<li>Mono：单个</li>
<li>Repo：repository仓库</li>
<li>主要是将许多项目的代码存储在同一个 repository 中；</li>
<li>这样做的目的是多个包本身相互独立，可以有自己的功能逻辑、单元测试等，同时又在同一个仓库下方便管理；</li>
<li>而且模块划分的更加清晰，可维护性、可扩展性更强；</li>
</ul>
</li>
<li>源码使用TypeScript来进行重写：
<ul>
<li>在Vue2.x的时候，Vue使用 Flow 来进行类型检测；</li>
<li>在Vue3.x的时候，Vue的源码全部使用 TypeScript 来进行重构，并且 Vue 本身对 TypeScript 支持也更好了；</li>
</ul>
</li>
</ul>
<h4> 性能方面</h4>
<ul>
<li>使用Proxy进行数据劫持
<ul>
<li>在 Vue2.x 的时候，Vue2 是使用 <code>Object.defineProperty</code> 来劫持数据的 getter 和 setter 方法的；</li>
<li>这种方式一致存在一个缺陷就是当给对象添加或者删除属性时，是无法劫持和监听的；</li>
<li>所以在 Vue2.x 的时候，不得不提供一些特殊的API，比如 <code>$set</code> 或 <code>$delete</code> ，事实上都是一些 hack 方法，也增加了 开发者学习新的API的成本；</li>
<li>而在 Vue3.x 开始，Vue 使用 Proxy 来实现数据的劫持</li>
</ul>
</li>
<li>删除了一些不必要的API：
<ul>
<li>移除了实例上的 <code>$on</code> , <code>$off</code>  和  <code>$once</code>；</li>
<li>移除了一些特性：如filter、内联模板等；</li>
</ul>
</li>
<li>包括编译方面的优化：
<ul>
<li>生成Block Tree、Slot编译优化、diff算法优化；</li>
</ul>
</li>
</ul>
<h4> 新的API</h4>
<ul>
<li>由Options API 到 Composition API：
<ul>
<li>在 Vue2.x 的时候，我们会通过 Options API 来描述组件对象；</li>
<li>Options API 包括data、props、methods、computed、生命周期等等这些选项；</li>
<li>存在比较大的问题是多个逻辑可能是在不同的地方：
<ul>
<li>比如created中会使用某一个method来修改data的数据，代码的内聚性非常差；</li>
</ul>
</li>
<li>Composition API可以将 相关联的代码 放到同一处 进行处理，而不需要在多个Options之间寻找；</li>
</ul>
</li>
<li>Hooks函数增加代码的复用性：
<ul>
<li>在Vue2.x的时候，我们通常通过mixins在多个组件之间共享逻辑；但是有一个很大的缺陷就是 mixins也是由一大堆的Options组成的，并且多个mixins会存在命名冲突的问题；</li>
<li>在Vue3.x中，我们可以通过Hook函数，来将一部分独立的逻辑抽取出去，并且它们还可以做到是响应式的；</li>
</ul>
</li>
</ul>
<h2> 如何使用 Vue</h2>
<ol>
<li>方式一：在页面中通过CDN的方式来引入；</li>
<li>方式二：下载Vue的JavaScript文件，并且自己手动引入；</li>
<li>方式三：通过npm包管理工具安装使用它；</li>
<li>方式四：直接通过Vue CLI创建项目，并且使用它；</li>
</ol>
<h3> CDN 引入</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 下载和引入</h3>
<ul>
<li>下载Vue的源码，可以直接打开CDN的链接：
<ul>
<li>打开链接，复制其中所有的代码；</li>
<li>创建一个新的文件，比如vue.js，将代码复制到其中；</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 声明式编程和命令式编程</h2>
<ul>
<li>原生开发和Vue开发的模式和特点,我们会发现是完全不同的,这里其实涉及到两种不同的编程范式命令式编程和声明式编程</li>
<li>命令式编程关注的是“ how to do”,声明式编程关注的是" what to do",由框架(机器)完成"how"的过程</li>
</ul>
<h2> MVVM模型</h2>
<ul>
<li>MVC和MVVM都是一种软件的体系结构
<ul>
<li>MVC是 Model-View-Controller的简称,是在前期被使用非常框架的架构模式,比如iS、前端</li>
<li>MVVM是 Model-View- ViewMode的简称,是目前非常流行的架构模式</li>
</ul>
</li>
<li>通常情况下,我们也经常称vue是一个MVVM的框架
<ul>
<li>vue官方其实有说明,vue虽然并没有完全遵守MVVM的模型,但是整个设计是受到它的启发的</li>
</ul>
</li>
</ul>
<figure><img src="https://qiniu.waite.wang/202310161331268.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> template属性</h2>
<ul>
<li>在使用 createApp的时候,我们传入了一个对象,接下来我们详细解析一下之前传入的属性分别代表什么含义。
<ul>
<li>template属性:表示的是Vue需要帮助我们渲染的模板信息</li>
<li>目前我们看到它里面有很多的HTML标签,这些标签会替换掉我们挂载到的元素(比如id为app的dⅳv)的innerHTML</li>
<li>模板中有一些奇怪的语法,比如{},比如@ )click,这些都是模板特有的语法</li>
</ul>
</li>
<li>但是这个模板的写法有点过于别扭了,并且IDE很有可能没有任何提示,阻碍我们编程的效率</li>
<li>vue提供了两种方式:</li>
<li>方式一:使用 script标签,并且标记它的类型为 X-template;</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>方式二:使用任意标签(通常使用 template标签,因为不会被浏览器渲染),设置id;v template元素是一种用于保存客户端内容的机制,该内容再加载页面时不会被呈现,但随后可以在运行时使用 JavaScript 实例化</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> data属性</h2>
<ul>
<li>
<p>data属性是传入一个函数,并且该函数需要返回一个对象</p>
<ul>
<li>在Vue2x的时候,也可以传入一个对象(虽然官方推荐是一个函数);</li>
<li>在Vue3x的时候,必须传入一个函数,否则就会直接在浏览器中报错</li>
</ul>
</li>
<li>
<p>data中返回的对象会被vue的响应式系统劫持,之后对该对象的修改或者访问都会在劫持中被处理</p>
<ul>
<li>所以我们在 template中通过{ counter} 访问 counter,可以从对象中获取到数据</li>
<li>所以我们修改 counter的值时, template中的{ counter)也会发生改变;</li>
</ul>
</li>
</ul>
<h2> methods属性（重点）</h2>
<ul>
<li>
<p>methods属性是一个对象,通常我们会在这个对象中定义很多的方法</p>
<ul>
<li>这些方法可以被绑定到 template模板中;</li>
<li>在该方法中,我们可以使用this关键字来直接访问到data中返回的对象的属性;</li>
</ul>
</li>
<li>
<p>问题：官方文档有这个描述，即不能使用箭头函数</p>
</li>
<li>
<p>为什么不能使用箭头函数(VUE3.0)？</p>
</li>
<li>
<p>我们在methods中要使用data返回对象中的数据：</p>
<ul>
<li>那么这个this是必须有值的，并且应该可以通过this获取到data返回对象中的数据。</li>
</ul>
</li>
<li>
<p>那么我们这个this能不能是window呢？</p>
<ul>
<li>不可以是window，因为window中我们无法获取到data返回对象中的数据；</li>
<li>但是如果我们使用箭头函数，那么这个this就会是window了；</li>
</ul>
</li>
<li>
<p>为什么是window呢？</p>
<ul>
<li>这里涉及到箭头函数使用this的查找规则，它会在自己的上层作用于中来查找this；</li>
<li>最终刚好找到的是script作用于中的this，所以就是window；</li>
</ul>
</li>
<li>
<p>this到底是如何查找和绑定的呢？</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA" target="_blank" rel="noopener noreferrer">前端面试之彻底搞懂this指向</a></li>
</ul>
</li>
<li>
<p><strong>不使用箭头函数的情况下，this到底指向什么</strong></p>
<ul>
<li>事实上Vue的源码当中就是对methods中的所有函数进行了遍历，并且通过 bind 绑定了 this</li>
</ul>
</li>
</ul>
<blockquote>
<p>具体看 https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 编写DOM元素的模板方式</h2>
<ol>
<li>方式一：template模板的方式：使用 <code>&lt;template&gt;</code> 标签编写模板。这种方式是之前经常使用的方式。</li>
</ol>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>方式二：render函数的方式：使用h函数来编写渲染的内容。在这种方式中，h函数可以直接返回一个虚拟节点（Vnode节点）。</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>方式三：通过.vue文件中的template来编写模板：在.vue文件中使用<code>&lt;template&gt;</code>标签编写模板。这种方式需要通过特定的代码来对模板进行解析：</li>
</ol>
<ul>
<li>对于方式三，即.vue文件中的template，可以通过vue-loader对其进行编译和处理。</li>
<li>对于方式一，即template模板，我们必须通过源码中的一部分代码来进行编译。</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，Vue在让我们选择版本时，提供了"运行时+编译器"和"仅运行时"两种选项：</p>
<ul>
<li><strong>运行时+编译器</strong>：这个版本包含了Vue的完整功能，包括对template模板的编译代码。在使用这个版本时，我们可以直接在代码中使用template模板，并且Vue会在运行时将其编译成渲染函数。这使得我们可以在开发过程中更方便地编写和调试模板。然而，由于包含了编译代码，这个版本的文件体积相对较大。</li>
<li><strong>仅运行时</strong>：这个版本不包含对template模板的编译代码。它更小巧，文件体积更小。在使用这个版本时，我们需要使用render函数来手动编写渲染逻辑，而不是直接使用template模板。这意味着我们需要更多的代码来实现相同的功能，但也带来了更好的性能和更小的文件大小。</li>
<li>选择哪个版本取决于项目的需求和优化目标。如果我们需要更完整的功能，并且对文件大小没有太大的担忧，可以选择运行时+编译器版本。如果我们对文件大小敏感，并且愿意手动编写渲染逻辑，可以选择仅运行时版本。</li>
</ul>
<h2> VSCode对SFC文件的支持</h2>
<blockquote>
<p>Vue 的单文件组件 (即 *.vue 文件，英文 Single-File Component，简称 SFC) 是一种特殊的文件格式，使我们能够将一个 Vue 组件的模板、逻辑与样式封装在单个文件中。下面是一个单文件组件的示例：</p>
</blockquote>
<blockquote>
<p>为什么要使用 SFC​
使用 SFC 必须使用构建工具，但作为回报带来了以下优点：</p>
<ul>
<li>
<p>使用熟悉的 HTML、CSS 和 JavaScript 语法编写模块化的组件</p>
</li>
<li>
<p>让本来就强相关的关注点自然内聚</p>
</li>
<li>
<p>预编译模板，避免运行时的编译开销</p>
</li>
<li>
<p>组件作用域的 CSS</p>
</li>
<li>
<p>在使用组合式 API 时语法更简单</p>
</li>
<li>
<p>通过交叉分析模板和逻辑代码能进行更多编译时优化</p>
</li>
<li>
<p>更好的 IDE 支持，提供自动补全和对模板中表达式的类型检查</p>
</li>
<li>
<p>开箱即用的模块热更新 (HMR) 支持</p>
</li>
<li>
<p>SFC 是 Vue 框架提供的一个功能，并且在下列场景中都是官方推荐的项目组织方式：</p>
</li>
<li>
<p>单页面应用 (SPA)</p>
</li>
<li>
<p>静态站点生成 (SSG)</p>
</li>
<li>
<p>任何值得引入构建步骤以获得更好的开发体验 (DX) 的项目</p>
</li>
</ul>
<p>https://cn.vuejs.org/guide/scaling-up/sfc.html</p>
</blockquote>
<ol>
<li>插件一：Vetur，从Vue2开发就一直在使用的VSCode支持Vue的插件；</li>
<li>插件二：Volar，官方推荐的插件（后续会基于Volar开发官方的VSCode插件）；</li>
</ol>
<h2> 如何阅读Vue源码</h2>
<ul>
<li>需要的环境 npm，yarn</li>
<li>操作步骤
<ol>
<li>安装yarn npm install yarn -g</li>
<li>在项目中配置yarn yarn install</li>
<li>在package.json中的dev后加上--sourcemap</li>
<li>打包项目 yarn dev （在vue/dist文件夹下有两个文件，vue.global.js和vue.global.js.map）</li>
<li>在vue/examplex新建自己的文件夹以及测试demo</li>
<li>在demo中打下断点—debugger</li>
<li>在浏览器中打开调试面板，选择其中的source面板，查看执行对应的源码</li>
</ol>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://qiniu.waite.wang/202310161331268.png" type="image/png"/>
    </item>
  </channel>
</rss>