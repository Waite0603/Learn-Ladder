const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}W(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f==null||f.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":92,\"nextId\":92,\"documentIds\":{\"0\":\"v-2e689c92\",\"1\":\"v-2e689c92#数据类型\",\"2\":\"v-2e689c92#深浅拷贝\",\"3\":\"v-2e689c92#概念\",\"4\":\"v-2e689c92#js-中的深浅拷贝\",\"5\":\"v-2e689c92#浅拷贝\",\"6\":\"v-2e689c92#手写递归\",\"7\":\"v-2e689c92#展开语法\",\"8\":\"v-2e689c92#object-assign\",\"9\":\"v-2e689c92#slice\",\"10\":\"v-2e689c92#concat\",\"11\":\"v-2e689c92#深拷贝\",\"12\":\"v-2e689c92#手写递归-1\",\"13\":\"v-2e689c92#object-entries-obj-遍历对象\",\"14\":\"v-2e689c92#json-parse-json-stringify-待拷贝对象-常用\",\"15\":\"v-2e689c92#其他方法\",\"16\":\"v-2e689c92#vue-中的深拷贝实现\",\"17\":\"v-65bb3ddf\",\"18\":\"v-65bb3ddf#vscode-代码片段\",\"19\":\"v-65bb3ddf#模板语法\",\"20\":\"v-65bb3ddf#mustache-语法-双大括号语法\",\"21\":\"v-65bb3ddf#不常用指令\",\"22\":\"v-65bb3ddf#v-once指令\",\"23\":\"v-65bb3ddf#v-html\",\"24\":\"v-65bb3ddf#v-text\",\"25\":\"v-65bb3ddf#v-pre\",\"26\":\"v-65bb3ddf#v-cloak\",\"27\":\"v-65bb3ddf#v-bind\",\"28\":\"v-65bb3ddf#基本使用\",\"29\":\"v-65bb3ddf#绑定-class\",\"30\":\"v-65bb3ddf#对象语法\",\"31\":\"v-65bb3ddf#数组语法\",\"32\":\"v-65bb3ddf#绑定-style\",\"33\":\"v-65bb3ddf#对象语法-1\",\"34\":\"v-65bb3ddf#数组语法-1\",\"35\":\"v-65bb3ddf#动态绑定属性\",\"36\":\"v-65bb3ddf#属性直接绑定一个对象\",\"37\":\"v-65bb3ddf#v-on\",\"38\":\"v-65bb3ddf#基本使用-1\",\"39\":\"v-65bb3ddf#参数传递\",\"40\":\"v-65bb3ddf#v-on-的修饰符\",\"41\":\"v-65bb3ddf#条件渲染\",\"42\":\"v-65bb3ddf#基本使用-2\",\"43\":\"v-65bb3ddf#template-和-v-if-结合使用\",\"44\":\"v-65bb3ddf#v-show\",\"45\":\"v-65bb3ddf#v-show和v-if的区别\",\"46\":\"v-65bb3ddf#列表渲染\",\"47\":\"v-65bb3ddf#基本使用-3\",\"48\":\"v-65bb3ddf#template元素使用\",\"49\":\"v-65bb3ddf#数组更新检测\",\"50\":\"v-65bb3ddf#v-for-中的-key-是什么作用\",\"51\":\"v-65bb3ddf#认识-vnode\",\"52\":\"v-65bb3ddf#虚拟-dom\",\"53\":\"v-65bb3ddf#插入-f-的案例\",\"54\":\"v-65bb3ddf#vue源码对于key的判断\",\"55\":\"v-65bb3ddf#有无key的结论\",\"56\":\"v-735040ba\",\"57\":\"v-735040ba#computed\",\"58\":\"v-735040ba#认识计算属性\",\"59\":\"v-735040ba#基本使用\",\"60\":\"v-735040ba#在模板语法中直接使用表达式\",\"61\":\"v-735040ba#使用method对逻辑进行抽取\",\"62\":\"v-735040ba#computed-实现\",\"63\":\"v-735040ba#计算属性-vs-methods\",\"64\":\"v-735040ba#计算属性的-setter-和-getter\",\"65\":\"v-735040ba#侦听器-watch\",\"66\":\"v-735040ba#简单案例\",\"67\":\"v-735040ba#配置选项\",\"68\":\"v-735040ba#其他方式\",\"69\":\"v-735040ba#watch-的api\",\"70\":\"v-735040ba#阶段案例\",\"71\":\"v-735040ba#v-model\",\"72\":\"v-45b1c858\",\"73\":\"v-45b1c858#认识-vue\",\"74\":\"v-45b1c858#什么是-vue\",\"75\":\"v-45b1c858#vue3带来的变化\",\"76\":\"v-45b1c858#性能方面\",\"77\":\"v-45b1c858#新的api\",\"78\":\"v-45b1c858#如何使用-vue\",\"79\":\"v-45b1c858#cdn-引入\",\"80\":\"v-45b1c858#下载和引入\",\"81\":\"v-45b1c858#声明式编程和命令式编程\",\"82\":\"v-45b1c858#mvvm模型\",\"83\":\"v-45b1c858#template属性\",\"84\":\"v-45b1c858#data属性\",\"85\":\"v-45b1c858#methods属性-重点\",\"86\":\"v-45b1c858#如何阅读vue源码\",\"87\":\"v-9a3f249c\",\"88\":\"v-744e6dd4\",\"89\":\"v-44825889\",\"90\":\"v-659323e8\",\"91\":\"v-ad9a6986\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2],\"1\":[1,20],\"2\":[1,16],\"3\":[1,22],\"4\":[2],\"5\":[1,7],\"6\":[1,32],\"7\":[1,26],\"8\":[3,19],\"9\":[2,17],\"10\":[2,20],\"11\":[1,5],\"12\":[1,35],\"13\":[4,37],\"14\":[6,36],\"15\":[1,5],\"16\":[2,20],\"17\":[2],\"18\":[2,23],\"19\":[1,33],\"20\":[3,80],\"21\":[1],\"22\":[2,50],\"23\":[2,47],\"24\":[2,13],\"25\":[2,17],\"26\":[2,33],\"27\":[2,93],\"28\":[1,45],\"29\":[2,11],\"30\":[1,68],\"31\":[1,46],\"32\":[2,22],\"33\":[1,57],\"34\":[1,41],\"35\":[1,56],\"36\":[1,52],\"37\":[2,61],\"38\":[1,62],\"39\":[1,68],\"40\":[3,92],\"41\":[1,8],\"42\":[1,46],\"43\":[5,60],\"44\":[2,17],\"45\":[3,36],\"46\":[1,9],\"47\":[1,86],\"48\":[1,54],\"49\":[1,84],\"50\":[6,34],\"51\":[2,19],\"52\":[2,12],\"53\":[3,71],\"54\":[1,49],\"55\":[1,8],\"56\":[3],\"57\":[1],\"58\":[1,45],\"59\":[1,36],\"60\":[1,35],\"61\":[1,55],\"62\":[2,56],\"63\":[3,95],\"64\":[4,62],\"65\":[2,30],\"66\":[1,65],\"67\":[1,103],\"68\":[1,62],\"69\":[3,35],\"70\":[1,176],\"71\":[2,4],\"72\":[1],\"73\":[2],\"74\":[2,13],\"75\":[1,30],\"76\":[1,47],\"77\":[1,37],\"78\":[2,12],\"79\":[2,10],\"80\":[1,14],\"81\":[1,13],\"82\":[1,16],\"83\":[1,81],\"84\":[1,20],\"85\":[3,58],\"86\":[1,26],\"87\":[1],\"88\":[1],\"89\":[1],\"90\":[1],\"91\":[1]},\"averageFieldLength\":[1.6956521739130435,39.40710386964492],\"storedFields\":{\"0\":{\"h\":\"Js 的浅拷贝与深拷贝\"},\"1\":{\"h\":\"数据类型\",\"t\":[\"在探讨深浅拷贝之前，我们先梳理一下js中的数据类型，js的数据类型分为两类：基本数据类型和引用数据类型\",\"前者是存储在栈内存中，后者是将其地址存在栈内存中，而真实数据存储在堆内存中。\",\"如下图所示，基本类型如number、string、boolean、Null和 undefined 等存储在栈内存中，而引用数据类型如 Array、Object 和函数等则是分别存储数据1的地址、数据2的地址和数据3的地址。\"]},\"2\":{\"h\":\"深浅拷贝\",\"t\":[\"js中的基本数据类型：String Number Boolean Null Undefined，在赋值的过程中都是深拷贝。\",\"例如，let a = 10 ; b = a , 修改其中一个变量的值，不会影响到另一个变量的值。\"]},\"3\":{\"h\":\"概念\",\"t\":[\"浅拷贝：会在栈中开辟另一块空间，并将被拷贝对象的栈内存数据完全拷贝到该块空间中，即基本数据类型的值会被完全拷贝，而引用类型的值则是拷贝了“指向堆内存的地址”。因此，当修改其中一个变量的值时，会影响到另一个变量的值。\",\"深拷贝：不仅会在栈中开辟另一块空间，若被拷贝对象中有引用类型，则还会在堆内存中开辟另一块空间存储引用类型的真实数据。因此，当修改其中一个变量的值时，不会影响到另一个变量的值。\",\"两者示意图如下：\",\"浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址\",\"深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址\"]},\"4\":{\"h\":\"Js 中的深浅拷贝\"},\"5\":{\"h\":\"浅拷贝\",\"t\":[\"浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝\",\"如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址\"]},\"6\":{\"h\":\"手写递归\",\"t\":[\"function shallowClone(obj) { if (typeof obj !== 'object') return; let newObj = obj instanceof Array ? [] : {}; for (let key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = obj[key]; } } return newObj; } const person = { name: 'cxk', hobby: ['sing', 'rap', 'basketball'] } const person1 = shallowClone(person); person1.name = 'xkc'; person1.hobby[0] = 'dance'; console.log(person); // {name: \\\"cxk\\\", hobby: [\\\"dance\\\", \\\"rap\\\", \\\"basketball\\\"]} console.log(person1); // {name: \\\"xkc\\\", hobby: [\\\"dance\\\", \\\"rap\\\", \\\"basketball\\\"]} \"]},\"7\":{\"h\":\"展开语法\",\"t\":[\"展开语法(spread syntax)允许一个表达式在期望多个参数(用于函数调用)或多个元素(用于数组字面量)或多个变量(用于解构赋值)的位置扩展。\",\"let obj = { name: \\\"cxk\\\", lessons: [\\\"语文\\\", \\\"数学\\\", \\\"英语\\\"] } let hd1 = { ...obj }; hd1.name = \\\"hdx\\\"; hd1.lessons[0] = \\\"物理\\\"; console.log(obj); // {name: \\\"cxk\\\", lessons: [\\\"物理\\\", \\\"数学\\\", \\\"英语\\\"]} console.log(hd1); // {name: \\\"hdx\\\", lessons: [\\\"物理\\\", \\\"数学\\\", \\\"英语\\\"]} \"]},\"8\":{\"h\":\"Object.assign()\",\"t\":[\"Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。\",\"let info = { name: 'cxk', hobbies: ['唱', '跳', '篮球'] }; let obj = Object.assign({}, info); obj.hobbies[0] = 'rap'; console.log(info); console.log(obj); // {name: \\\"cxk\\\", hobbies: [\\\"rap\\\", \\\"跳\\\", \\\"篮球\\\"]} \"]},\"9\":{\"h\":\"slice()\",\"t\":[\"slice() 方法可从已有的数组中返回选定的元素。\",\"let arr1 = [1, 42, [3, 4]] let arr1Copy = arr1.slice() arr1Copy[0] = 10 arr1Copy[2][0] = 100 console.log(arr1) // [1, 42, [100, 4]] console.log(arr1Copy) // [10, 42, [100, 4]] \"]},\"10\":{\"h\":\"concat()\",\"t\":[\"concat() 方法用于连接两个或多个数组。\",\"let arr2 = ['cat', 'dog', 'pig', { 'name': 'xia', 'age': 18 }] let arr2Copy = [].concat(arr2) arr2Copy[2] = 'big pig' arr2Copy[3]['name'] = 'aa' console.log(arr2) console.log(arr2Copy) \"]},\"11\":{\"h\":\"深拷贝\",\"t\":[\"深拷贝开辟一个新的栈，两个对象属性完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性\"]},\"12\":{\"h\":\"手写递归\",\"t\":[\"function deepClone(obj) { let newObj = obj instanceof Array ? [] : {}; for (let i in obj) { if (obj.hasOwnProperty(i)) { if (obj[i] && typeof obj[i] == 'object') { // 若对象属性还是引用类型，进行递归 newObj[i] = deepClone(obj[i]); } else { // 对象属性为基础数据类型，直接赋值 newObj[i] = obj[i]; } } } return newObj; } const obj = { name: 'zs', hobby: ['排球', '网球', '乒乓球'], }; const newObj = deepClone(obj); newObj.name = 'lisi'; newObj.hobby[0] = '篮球'; console.log(obj); // { name: 'zs', hobby: [ '排球', '网球', '乒乓球' ] } console.log(newObj); // { name: 'lisi', hobby: [ '篮球', '网球', '乒乓球' ] } \"]},\"13\":{\"h\":\"Object.entries(obj) 遍历对象\",\"t\":[\"Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组\",\"比如：Object.entries({ foo: 'bar', baz: 42 }); // [ ['foo', 'bar'], ['baz', 42] ]\",\"function deepClone(obj) { let newObj = obj instanceof Array ? [] : {}; for (const [k, v] of Object.entries(obj)) { newObj[k] = typeof v == 'object' ? deepClone(v) : v; } return newObj; } const obj = { name: 'zs', hobby: ['排球', '网球', '乒乓球'], }; const newObj = deepClone(obj); newObj.name = 'lisi'; newObj.hobby[0] = '篮球'; console.log(obj); console.log(newObj); \"]},\"14\":{\"h\":\"JSON.parse(JSON.stringify(待拷贝对象) -> 常用\",\"t\":[\"JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串。\",\"比如: JSON.stringify({ x: 5, y: 6 }); // \\\"{\\\"x\\\":5,\\\"y\\\":6}\\\" -> string\",\"JSON.parse() 方法用于将一个 JSON 字符串转换为对象。\",\"比如: JSON.parse('{\\\"name\\\":\\\"cxk\\\",\\\"age\\\":18}'); // {name: \\\"cxk\\\", age: 18} -> object\",\"const obj = { name: 'zs', hobby: ['排球', '网球', '乒乓球'], }; const newObj = JSON.parse(JSON.stringify(obj)); newObj.name = 'lisi'; newObj.hobby[0] = '篮球'; console.log(obj); console.log(newObj); \"]},\"15\":{\"h\":\"其他方法\",\"t\":[\"_.cloneDeep()\",\"jQuery.extend()\",\"手写循环递归\"]},\"16\":{\"h\":\"Vue 中的深拷贝实现\",\"t\":[\"引入loadsh,提供 cloneDeep 实现深拷贝\",\"安装loadsh npm i --save lodash\",\"引入loadsh import _ from 'lodash'\",\"直接调用 loadsh 库的方法 const newObj = _.cloneDeep(this.obj)\"]},\"17\":{\"h\":\"Vue3 基本指令\"},\"18\":{\"h\":\"VSCode 代码片段\",\"t\":[\"我们在前面练习Vue的过程中，有些代码片段是需要经常写的，我们再VSCode中我们可以生成一个代码片段，方便我们快速生成。\",\"VSCode中的代码片段有固定的格式，所以我们一般会借助于一个在线工具来完成。\",\"具体的步骤如下： \",\"第一步，复制自己需要生成代码片段的代码；\",\"第二步，https://snippet-generator.app/在该网站中生成代码片段；\",\"第三步，在VSCode中配置代码片段；\",\"直接 Tab trigger 即可自动填充\",\"image-20231016233051010\"]},\"19\":{\"h\":\"模板语法\",\"t\":[\"React的开发模式[了解] \",\"React使用的jsx,所以对应的代码都是编写的类似于js的一种语法\",\"之后通过Babe将js编译成 React. create Element函数调用\",\"function () { return <div></div> } \",\"vue也支持 jsx 的开发模式: \",\"但是大多数情况下,使用基于HTML的模板语法\",\"在模板中,允许开发者以声明式的方式将 DOM 和底层组件实例的数据绑定在-起;口在底层的实现中,vue将模板编译成虚拟DOM渲染函数\",\"<template> <div @click v-bind v-once> {{}} </div> </template> \"]},\"20\":{\"h\":\"Mustache 语法 双大括号语法\",\"t\":[\"如果我们希望把数据显示到模板（template）中，使用最多的语法是 “Mustache”语法 (双大括号) 的文本插值。 \",\"并且我们前端提到过，data返回的对象是有添加到Vue的响应式系统中；\",\"当data中的数据发生改变时，对应的内容也会发生更新。\",\"当然，Mustache中不仅仅可以是data中的属性，也可以是一个JavaScript的表达式。\",\"mustache的使用 1. 基本使用 2. 表达式 3. 函数 4. 三元运算符\",\"<template id=\\\"my-app\\\"> <!-- 1.mustache的基本使用 --> <h2>{{message}} - {{message}}</h2> <!-- 2.是一个表达式 --> <h2>{{counter * 10}}</h2> <h2>{{ message.split(\\\" \\\").reverse().join(\\\" \\\") }}</h2> <!-- 3.也可以调用函数 --> <!-- 可以使用computed(计算属性) --> <h2>{{getReverseMessage()}}</h2> <!-- 4.三元运算符 --> <h2>{{ isShow ? \\\"哈哈哈\\\": \\\"\\\" }}</h2> <button @click=\\\"toggle\\\">切换</button> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { message: \\\"Hello World\\\", counter: 100, isShow: true } }, methods: { getReverseMessage() { return this.message.split(\\\" \\\").reverse().join(\\\" \\\"); }, toggle() { this.isShow = !this.isShow; } } } Vue.createApp(App).mount('#app'); </script> \",\"以下为错误写法\",\"<!-- 错误用法 --> var name = \\\"abc\\\" ; <h2>{{var name = \\\"abc\\\"}}</h2> <h2>{{ if(isShow) { return \\\"哈哈哈\\\" } }}</h2> \"]},\"21\":{\"h\":\"不常用指令\"},\"22\":{\"h\":\"v-once指令\",\"t\":[\"v-once用于指定元素或者组件只渲染一次\",\"当数据发生变化时,元素或者组件以及其所有的子元素将视为静态内容并且跳过;\",\"该指令可以用于性能优化;\",\"<h2 v-once>{{counter}}</h2> <button @click=\\\"increment\\\">+1</button> \",\"如果是子节点的化，也只能渲染一次\",\"<div v-once> <h2>{{counter}}</h2> <h2>{{message}}</h2> </div> <button @click=\\\"increment\\\">+1</button> \",\"完整代码\",\"<div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <h2>{{counter}}</h2> <div v-once> <h2>{{counter}}</h2> <h2>{{message}}</h2> </div> <button @click=\\\"increment\\\">+1</button> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { counter: 100, message: \\\"abc\\\" } }, methods: { increment() { this.counter++; } } } Vue.createApp(App).mount('#app'); </script> \"]},\"23\":{\"h\":\"v-html\",\"t\":[\"默认情况下，如果我们展示的内容本身是 html 的，那么vue并不会对其进行特殊的解析。 \",\"如果我们希望这个内容被Vue可以解析出来，那么可以使用 v-html 来展示\",\"<template id=\\\"my-app\\\"> <div>{{msg}}</div> <div v-html=\\\"msg\\\"></div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { msg: '<span style=\\\"color:red; background: blue;\\\">哈哈哈</span>' } } } Vue.createApp(App).mount('#app'); </script> \",\"image-20231018083558572\"]},\"24\":{\"h\":\"v-text\",\"t\":[\"用于更新元素的 textContent\",\" <h2 v-text=\\\"message\\\"></h2> <!-- 等价于 --> <h2>{{message}}</h2> \"]},\"25\":{\"h\":\"v-pre\",\"t\":[\"v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签： \",\"跳过不需要编译的节点，加快编译的速度\",\" <template id=\\\"my-app\\\"> <h2 v-pre>{{message}}</h2> </template> <!-- {{message}} --> \"]},\"26\":{\"h\":\"v-cloak\",\"t\":[\"用于隐藏尚未完成编译的 DOM 模板。 \",\"无需传入\",\"详细信息\",\"该指令只在没有构建步骤的环境下需要使用。\",\"当使用直接在 DOM 中书写的模板时，可能会出现一种叫做“未编译模板闪现”的情况：用户可能先看到的是还没编译完成的双大括号标签，直到挂载的组件将它们替换为实际渲染的内容。\",\"v-cloak 会保留在所绑定的元素上，直到相关组件实例被挂载后才移除。配合像 [v-cloak] { display: none } 这样的 CSS 规则，它可以在组件编译完毕前隐藏原始模板。\",\"[v-cloak] { display: none; } \",\"<div v-cloak> {{ message }} </div> \",\"直到编译完成前，<div> 将不可见。\"]},\"27\":{\"h\":\"v-bind\",\"t\":[\"动态的绑定一个或多个 attribute，也可以是组件的 prop。\",\"缩写：: 或者 . (当使用 .prop 修饰符)\",\"期望：any (带参数) | Object (不带参数)\",\"参数：attrOrProp (可选的)\",\"修饰符\",\".camel - 将短横线命名的 attribute 转变为驼峰式命名。\",\".prop - 强制绑定为 DOM property。3.2+\",\".attr - 强制绑定为 DOM attribute。3.2+\",\"用途\",\"当用于绑定 class 或 style attribute，v-bind 支持额外的值类型如数组或对象。详见下方的指南链接。\",\"在处理绑定时，Vue 默认会利用 in 操作符来检查该元素上是否定义了和绑定的 key 同名的 DOM property。如果存在同名的 property，则 Vue 会将它作为 DOM property 赋值，而不是作为 attribute 设置。这个行为在大多数情况都符合期望的绑定值类型，但是你也可以显式用 .prop 和 .attr 修饰符来强制绑定方式。有时这是必要的，特别是在和自定义元素打交道时。\",\"当用于组件 props 绑定时，所绑定的 props 必须在子组件中已被正确声明。\",\"当不带参数使用时，可以用于绑定一个包含了多个 attribute 名称-绑定值对的对象。\",\"用法\",\"动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。\",\"小知识: vue3 是允许template中有多个根元素\",\"<!-- vue2 template模板中只能有一个根元素 --> <!-- vue3 是允许template中有多个根元素 --> <template id=\\\"my-app\\\"> <!-- 1.v-bind的基本使用 --> <img v-bind:src=\\\"imgUrl\\\" alt=\\\"\\\"> <a v-bind:href=\\\"link\\\">百度一下</a> <!-- 2.v-bind提供一个语法糖 : --> <img :src=\\\"imgUrl\\\" alt=\\\"\\\"> <img src=\\\"imgUrl\\\" alt=\\\"\\\"> </template> \"]},\"28\":{\"h\":\"基本使用\",\"t\":[\"<template id=\\\"my-app\\\"> <!-- 1.v-bind的基本使用 --> <img v-bind:src=\\\"imgUrl\\\" alt=\\\"\\\"> <a v-bind:href=\\\"link\\\">百度一下</a> <!-- 2.v-bind提供一个语法糖 : --> <img :src=\\\"imgUrl\\\" alt=\\\"\\\"> <!-- 以下报错 --> <img src=\\\"imgUrl\\\" alt=\\\"\\\"> </template> <script> const App = { template: '#my-app', data() { return { imgUrl: \\\"https://avatars.githubusercontent.com/u/10335230?s=60&v=4\\\", link: \\\"https://www.baidu.com\\\" } } } Vue.createApp(App).mount('#app'); </script> \"]},\"29\":{\"h\":\"绑定 class\",\"t\":[\"在开发中,有时候我们的元素 class也是动态的,比如 \",\"当数据为某个状态时,字体显示红色。\",\"当数据另一个状态时,字体显示黑色\",\"绑定class有两种方式： \",\"对象语法\",\"数组语法\"]},\"30\":{\"h\":\"对象语法\",\"t\":[\"对象语法：我们可以传给 :class (v-bind:class 的简写) 一个对象，以动态地切换 class\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <div :class=\\\"className\\\">哈哈哈哈</div> <!-- 对象语法: {'active': boolean} --> <div :class=\\\"{'active': isActive}\\\">呵呵呵呵</div> <button @click=\\\"toggle\\\">切换</button> <!-- 也可以有多个键值对 --> <div :class=\\\"{active: isActive, title: true}\\\">呵呵呵呵</div> <!-- 默认的class和动态的class结合 --> <div class=\\\"abc cba\\\" :class=\\\"{active: isActive, title: true}\\\"> 呵呵呵呵 </div> <!-- 将对象放到一个单独的属性中 --> <div class=\\\"abc cba\\\" :class=\\\"classObj\\\">呵呵呵呵</div> <!-- 将返回的对象放到一个methods(computed)方法中 --> <div class=\\\"abc cba\\\" :class=\\\"getClassObj()\\\">呵呵呵呵</div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: \\\"#my-app\\\", data() { return { className: \\\"why\\\", isActive: true, title: \\\"abc\\\", classObj: { active: true, title: true }, }; }, methods: { toggle() { this.isActive = !this.isActive; this.classObj.active = !this.classObj.active; }, getClassObj() { return this.classObj; } }, }; Vue.createApp(App).mount(\\\"#app\\\"); </script> <style> .active { color: red; } </style> </body> \"]},\"31\":{\"h\":\"数组语法\",\"t\":[\"绑定class – 数组语法 \",\"数组语法：我们可以把一个数组传给 :class，以应用一个 class 列表\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <div :class=\\\"['abc', title]\\\">哈哈哈哈</div> <!-- class=\\\"abc cba active\\\" --> <div :class=\\\"['abc', title, isActive ? 'active': '']\\\">哈哈哈哈</div> <!-- 可以嵌套对象语法 --> <div :class=\\\"['abc', title, {active: isActive}]\\\">哈哈哈哈</div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { message: \\\"Hello World\\\", title: \\\"cba\\\", isActive: true } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"32\":{\"h\":\"绑定 style\",\"t\":[\"我们可以利用 v-bind:style 来绑定一些CSS内联样式 \",\"这次因为某些样式我们需要根据数据动态来决定\",\"比如某段文字的颜色，大小等等\",\"CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名\",\"绑定class有两种方式 \",\"对象语法\",\"数组语法\",\"CSS property 名短横线分隔 (kebab-case，记得用引号括起来)\"]},\"33\":{\"h\":\"对象语法\",\"t\":[\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <!-- :style=\\\"{cssPropertyName: cssPropertyValue}\\\" --> <div :style=\\\"{color: finalColor, 'font-size': '30px'}\\\">哈哈哈哈</div> <div :style=\\\"{color: finalColor, fontSize: '30px'}\\\">哈哈哈哈</div> <div :style=\\\"{color: finalColor, fontSize: finalFontSize + 'px'}\\\">哈哈哈哈</div> <!-- 绑定一个data中的属性值, 并且是一个对象 --> <div :style=\\\"finalStyleObj\\\">呵呵呵呵</div> <!-- 调用一个方法 --> <div :style=\\\"getFinalStyleObj()\\\">呵呵呵呵</div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { message: \\\"Hello World\\\", finalColor: 'red', finalFontSize: 50, finalStyleObj: { 'font-size': '50px', fontWeight: 700, backgroundColor: 'red' } } }, methods: { getFinalStyleObj() { return { 'font-size': '50px', fontWeight: 700, backgroundColor: 'red' } } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"34\":{\"h\":\"数组语法\",\"t\":[\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <div :style=\\\"[style1Obj, style2Obj]\\\">哈哈哈</div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { message: \\\"Hello World\\\", style1Obj: { color: 'red', fontSize: '30px' }, style2Obj: { textDecoration: \\\"underline\\\" } } } } Vue.createApp(App).mount('#app'); </script> </body \"]},\"35\":{\"h\":\"动态绑定属性\",\"t\":[\"在某些情况下，我们属性的名称可能也不是固定的 \",\"前端我们无论绑定src、href、class、style，属性名称都是固定的\",\"如果属性名称不是固定的，我们可以使用 :[属性名]=“值” 的格式来定义\",\"这种绑定的方式，我们称之为 动态绑定属性；如下:\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <!-- <div cba=\\\"kobe\\\">哈哈哈</div> --> <div :[name]=\\\"value\\\">哈哈哈</div> <img :src=\\\"\\\" alt=\\\"\\\"> <a :href=\\\"\\\"></a> <div :class></div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { name: \\\"cba\\\", value: \\\"kobe\\\" } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"36\":{\"h\":\"属性直接绑定一个对象\",\"t\":[\"如果我们希望将一个对象的所有属性，绑定到元素上的所有属性，应该怎么做呢？ \",\"非常简单，我们可以直接使用 v-bind 绑定一个 对象\",\"案例：info对象会被拆解成div的各个属性\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <!-- <div name=\\\"why\\\" age=\\\"18\\\" height=\\\"1.88\\\">哈哈哈哈</div> --> <div v-bind=\\\"info\\\">哈哈哈哈</div> <div :=\\\"info\\\">哈哈哈哈</div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { info: { name: \\\"why\\\", age: 18, height: 1.88 } } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"37\":{\"h\":\"v-on\",\"t\":[\"v-on绑定事件\",\"前面我们绑定了元素的内容和属性，在前端开发中另外一个非常重要的特性就是交互。\",\"在前端开发中，我们需要经常和用户进行各种各样的交互 \",\"这个时候，我们就必须监听用户发生的事件，比如点击、拖拽、键盘事件等等\",\"在Vue中如何监听事件呢？使用v-on指令。\",\"v-on的用法\",\"缩写：@\",\"预期：Function | Inline Statement | Object\",\"参数：event p 修饰符： \",\".stop - 调用 event.stopPropagation()。\",\".prevent - 调用 event.preventDefault()。\",\".capture - 添加事件侦听器时使用 capture 模式。\",\".self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。\",\".{keyAlias} - 仅当事件是从特定键触发时才触发回调。\",\".once - 只触发一次回调。\",\".left - 只当点击鼠标左键时触发。\",\".right - 只当点击鼠标右键时触发。\",\".middle - 只当点击鼠标中键时触发。\",\".passive - { passive: true } 模式添加侦听器\",\"用法：绑定事件监听\",\"event 事件可以参考 https://developer.mozilla.org/en-US/docs/Web/Events\"]},\"38\":{\"h\":\"基本使用\",\"t\":[\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <!-- 完整写法: v-on:监听的事件=\\\"methods中方法\\\" --> <button v-on:click=\\\"btn1Click\\\">按钮1</button> <div class=\\\"area\\\" v-on:mousemove=\\\"mouseMove\\\">div</div> <!-- 语法糖 --> <button @click=\\\"btn1Click\\\">按钮1</button> <!-- 绑定一个表达式: inline statement --> <button @click=\\\"counter++\\\">{{counter}}</button> <!-- 绑定一个对象 --> <div class=\\\"area\\\" v-on=\\\"{click: btn1Click, mousemove: mouseMove}\\\"></div> <div class=\\\"area\\\" @=\\\"{click: btn1Click, mousemove: mouseMove}\\\"></div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { message: \\\"Hello World\\\", counter: 100 } }, methods: { btn1Click() { console.log(\\\"按钮1发生了点击\\\"); }, mouseMove() { console.log(\\\"鼠标移动\\\"); } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"39\":{\"h\":\"参数传递\",\"t\":[\"当通过methods中定义方法，以供 @click调用时，需要注意参数问题：\",\"情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。 \",\"但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去\",\"情况二：如果需要同时传入某个参数，同时需要 event 时，可以通过 $event 传入事件。\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <!-- 默认传入event对象, 可以在方法中获取 --> <button @click=\\\"btn1Click\\\">按钮1</button> <!-- $event可以获取到事件发生时的事件对象 --> <button @click=\\\"btn2Click($event, 'coderwhy', 18)\\\">按钮2</button> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { message: \\\"Hello World\\\" } }, methods: { btn1Click(event) { console.log(event); }, btn2Click(event, name, age) { console.log(name, age, event); } } } Vue.createApp(App).mount('#app'); </script> </body> \",\"image-20231019004604619\"]},\"40\":{\"h\":\"v-on 的修饰符\",\"t\":[\"v-on支持修饰符，修饰符相当于对事件进行了一些特殊的处理： \",\".stop - 调用 event.stopPropagation()。\",\".prevent - 调用 event.preventDefault()。\",\".capture - 添加事件侦听器时使用 capture 模式。\",\".self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。\",\".{keyAlias} - 仅当事件是从特定键触发时才触发回调。\",\".once - 只触发一次回调。\",\".left - 只当点击鼠标左键时触发。\",\".right - 只当点击鼠标右键时触发。\",\".middle - 只当点击鼠标中键时触发。\",\".passive - { passive: true } 模式添加侦听器\",\"stopPropagation 是一个事件修饰符，用于阻止事件冒泡。在 Vue.js 中，当一个元素上的事件被触发时，它会先执行该元素上的事件处理函数，然后再冒泡到该元素的父元素，继续执行父元素的事件处理函数。使用 stopPropagation 可以阻止事件继续冒泡到父元素。在给元素绑定事件时，可以使用 @click.stop 来阻止 click 事件冒泡到父元素。\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <div @click=\\\"divClick\\\"> <button @click=\\\"btnClick\\\">按钮</button> <button @click.stop=\\\"btnClick\\\">按钮</button> </div> <input type=\\\"text\\\" @keyup.enter=\\\"enterKeyup\\\"> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { message: \\\"Hello World\\\" } }, methods: { divClick() { console.log(\\\"divClick\\\"); }, btnClick() { console.log('btnClick'); }, enterKeyup(event) { console.log(\\\"keyup\\\", event.target.value); } } } Vue.createApp(App).mount('#app'); </script> </body> \",\"image-20231019005251770\"]},\"41\":{\"h\":\"条件渲染\",\"t\":[\"在某些情况下，我们需要根据当前的条件决定某些元素或组件是否渲染，这个时候我们就需要进行条件判断了。 \",\"Vue提供了下面的指令来进行条件判断： \",\"v-if\",\"v-else\",\"v-else-if\",\"v-show\"]},\"42\":{\"h\":\"基本使用\",\"t\":[\"v-if、v-else、v-else-if用于根据条件来渲染某一块的内容： \",\"这些内容只有在条件为true时，才会被渲染出来；\",\"这三个指令与JavaScript的条件语句if、else、else if类似；\",\" <template id=\\\"my-app\\\"> <input type=\\\"text\\\" v-model=\\\"score\\\"> <h2 v-if=\\\"score > 90\\\">优秀</h2> <h2 v-else-if=\\\"score > 60\\\">良好</h2> <h2 v-else>不及格</h2> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { score: 95 } } } Vue.createApp(App).mount('#app'); </script> \"]},\"43\":{\"h\":\"template 和 v-if 结合使用\",\"t\":[\"v-if的渲染原理： \",\"v-if是惰性的；\",\"当条件为false时，其判断的内容完全不会被渲染或者会被销毁掉；\",\"当条件为true时，才会真正渲染条件块中的内容;\",\"template元素 \",\"因为v-if是一个指令，所以必须将其添加到一个元素上： \",\"但是如果我们希望切换的是多个元素呢？\",\"此时我们渲染div，但是我们并不希望div这种元素被渲染；\",\"这个时候，我们可以选择使用template；\",\"template元素可以当做不可见的包裹元素，并且在v-if上使用，但是最终template不会被渲染出来： \",\"有点类似于小程序中的block\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <template v-if=\\\"isShowHa\\\"> <h2>哈哈哈哈</h2> <h2>哈哈哈哈</h2> <h2>哈哈哈哈</h2> </template> <template v-else> <h2>呵呵呵呵</h2> <h2>呵呵呵呵</h2> <h2>呵呵呵呵</h2> </template> <button @click=\\\"isShowHa = !isShowHa\\\">切换</button> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { isShowHa: true } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"44\":{\"h\":\"v-show\",\"t\":[\"v-show和v-if的用法看起来是一致的，也是根据一个条件决定是否显示元素或者组件\",\" <template id=\\\"my-app\\\"> <h2 v-show=\\\"isShow\\\">哈哈哈哈</h2> </template> \"]},\"45\":{\"h\":\"v-show和v-if的区别\",\"t\":[\"首先，在用法上的区别： \",\"v-show是不支持template；\",\"v-show不可以和v-else一起使用；\",\"其次，本质的区别： \",\"v-show元素无论是否需要显示到浏览器上，它的DOM实际都是有渲染的，只是通过CSS的display属性来进行 切换；\",\"v-if当条件为false时，其对应的元素压根不会被渲染到DOM中；\",\"开发中如何进行选择呢？ \",\"如果我们的元素需要在显示和隐藏之间频繁的切换，那么使用v-show；\",\"如果不会频繁的发生切换，那么使用v-if；\",\"<template id=\\\"my-app\\\"> <h2 v-if=\\\"isShow\\\">哈哈哈哈</h2> <h2 v-show=\\\"isShow\\\">呵呵呵呵</h2> </template> \",\"image-20231019222841008\"]},\"46\":{\"h\":\"列表渲染\",\"t\":[\"在真实开发中，我们往往会从服务器拿到一组数据，并且需要对其进行渲染。 \",\"这个时候我们可以使用v-for来完成；\",\"v-for类似于JavaScript的for循环，可以用于遍历一组数据；\"]},\"47\":{\"h\":\"基本使用\",\"t\":[\"n v-for的基本格式是 \\\"item in 数组\\\"：\",\"数组通常是来自data或者prop，也可以是其他方式；\",\"item是我们给每项元素起的一个别名，这个别名可以自定来定义；\",\"我们知道，在遍历一个数组的时候会经常需要拿到数组的索引：\",\"如果我们需要索引，可以使用格式： \\\"(item, index) in 数组\\\"；\",\"注意上面的顺序：数组元素项item是在前面的，索引项index是在后面的；\",\"v-for支持的类型\",\"v-for也支持遍历对象，并且支持有一二三个参数： \",\"一个参数： \\\"value in object\\\";\",\"二个参数： \\\"(value, key) in object\\\";\",\"三个参数： \\\"(value, key, index) in object\\\";\",\"v-for同时也支持数字的遍历： \",\"每一个item都是一个数字；\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <h2>电影列表</h2> <ul> <!-- 遍历数组 --> <li v-for=\\\"(movie, index) in movies\\\">{{index+1}}.{{movie}}</li> </ul> <h2>个人信息</h2> <ul> <!-- 遍历对象 --> <li v-for=\\\"(value, key, index) in info\\\">{{value}}-{{key}}-{{index}}</li> </ul> <h2>遍历数字</h2> <ul> <li v-for=\\\"(num, index) in 10\\\">{{num}}-{{index}}</li> </ul> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { movies: [ \\\"星际穿越\\\", \\\"盗梦空间\\\", \\\"大话西游\\\", \\\"教父\\\", \\\"少年派\\\" ], info: { name: \\\"why\\\", age: 18, height: 1.88 } } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"48\":{\"h\":\"template元素使用\",\"t\":[\"类似于v-if，你可以使用 template 元素来循环渲染一段包含多个元素的内容： \",\"我们使用template来对多个元素进行包裹，而不是使用div来完成；\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <ul> <template v-for=\\\"(value, key) in info\\\"> <li>{{key}}</li> <li>{{value}}</li> <li class=\\\"divider\\\"></li> </template> </ul> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { info: { name: \\\"why\\\", age: 18, height: 1.88 } } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"49\":{\"h\":\"数组更新检测\",\"t\":[\"Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括： \",\"push()\",\"pop()\",\"shift()\",\"unshift()\",\"splice()\",\"sort()\",\"reverse()\",\"替换数组的方法 \",\"上面的方法会直接修改原来的数组，但是某些方法不会替换原来的数组，而是会生成新的数组，比如 filter()、 concat() 和 slice()。\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <h2>电影列表</h2> <ul> <li v-for=\\\"(movie, index) in movies\\\">{{index+1}}.{{movie}}</li> </ul> <input type=\\\"text\\\" v-model=\\\"newMovie\\\"> <button @click=\\\"addMovie\\\">添加电影</button> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { newMovie: \\\"\\\", movies: [ \\\"星际穿越\\\", \\\"盗梦空间\\\", \\\"大话西游\\\", \\\"教父\\\", \\\"少年派\\\" ] } }, methods: { addMovie() { this.movies.push(this.newMovie); this.newMovie = \\\"\\\"; // filter 是过滤的意思, 下文中的代码的意思是: 过滤掉长度小于等于2的电影 // this.movies = this.movies.filter(item => item.length > 2); } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"50\":{\"h\":\"v-for 中的 key 是什么作用？\",\"t\":[\"https://cn.vuejs.org/api/built-in-special-attributes.html#key\",\"在使用v-for进行列表渲染时，我们通常会给元素或者组件绑定一个key属性。\",\"这个key属性有什么作用呢？我们先来看一下官方的解释：\",\"key属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes；\",\"如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法；\",\"而使用key时，它会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素；\",\"官方的解释对于初学者来说并不好理解，比如下面的问题：\",\"什么是新旧nodes，什么是VNode？\",\"没有key的时候，如何尝试修改和复用的？\",\"有key的时候，如何基于key重新排列的？\"]},\"51\":{\"h\":\"认识 VNode\",\"t\":[\"我们先来解释一下VNode的概念： \",\"因为目前我们还没有比较完整的学习组件的概念，所以目前我们先理解HTML元素创建出来的VNode；\",\"VNode的全称是Virtual Node，也就是虚拟节点；\",\"事实上，无论是组件还是元素，它们最终在Vue中表示出来的都是一个个VNode；\",\"VNode的本质是一个JavaScript的对象；可以用于描述某一个标签/ 元素 的样子\",\"好处: 多平台的渲染, 跨平台(主要好处)\",\"image-20231020162812819\"]},\"52\":{\"h\":\"虚拟 DOM\",\"t\":[\"如果我们不只是一个简单的div，而是有一大堆的元素，那么它们应该会形成一个 VNode Tree\",\"虚拟 DOM 与 真实 DOM 不一定一一对应\",\"image-20231020163154944\"]},\"53\":{\"h\":\"插入 F 的案例\",\"t\":[\"我们先来看一个案例：这个案例是当我点击按钮时会在中间插入一个f；\",\"我们可以确定的是，这次更新对于ul和button是不需要进行更新，需要更新的是我们 li 的列表：\",\"在Vue中，对于相同父元素的子元素节点并不会重新渲染整个列 表；\",\"因为对于列表中 a、b、c、d它们都是没有变化的；\",\"在操作真实DOM的时候，我们只需要在中间插入一个 f 的 li 即可；\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <ul> <li v-for=\\\"item in letters\\\" :key=\\\"item\\\">{{item}}</li> </ul> <button @click=\\\"insertF\\\">插入F元素</button> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { letters: ['a', 'b', 'c', 'd'] } }, methods: { insertF() { this.letters.splice(2, 0, 'f') } } } Vue.createApp(App).mount('#app'); </script> </body> \",\"那么Vue中对于列表的更新究竟是如何操作的呢？ \",\"Vue事实上会对于有key和没有key会调用两个不同的方法；\"]},\"54\":{\"h\":\"Vue源码对于key的判断\",\"t\":[\"有key，那么就使用 patchKeyedChildren方法；\",\"没有key，那么久使用 patchUnkeyedChildren方法；\",\"image-20231020164733530\",\"diff算法: diff 算法是指生成更新补丁的方式,主要应用于虚拟 DOM 树变化后,更新真实 DOM。所以 diff 算法一定存在这样一个过程:触发更新 → 生成补丁 → 应用补丁。\",\"没有key的操作过程\",\"image-20231022182341619\",\"我们会发现上面的diff算法效率并不高： \",\"c和d来说它们事实上并不需要有任何的改动；\",\"但是因为我们的c被f所使用了，所有后续所有的内容都要一次进行改动，并且最后进行新增；\",\"image-20231022182012027\",\"有key的操作过程-diff算法 \",\"第一步的操作是从头开始进行遍历、比较： \",\"a和b是一致的会继续进行比较；\",\"c和f因为key不一致，所以就会break跳出循环\",\"第二步的操作是从尾部开始进行遍历、比较\",\"第三步是如果旧节点遍历完毕，但是依然有新的节点，那么就新增节点：\",\"第四步是如果新的节点遍历完毕，但是依然有旧的节点，那么就移除旧节点：\",\"第五步是最特色的情况，中间还有很多未知的或者乱序的节点：\",\"image-20231022182232738\",\"image-20231022182140133\",\"image-20231022182241976\",\"image-20231022182251535\",\"image-20231022182300781\"]},\"55\":{\"h\":\"有无key的结论\",\"t\":[\"有无key的结论 \",\"所以我们可以发现，Vue在进行diff算法的时候，会尽量利用我们的key来进行优化操作： \",\"在没有key的时候我们的效率是非常低效的；\",\"在进行插入或者重置顺序的时候，保持相同的key可以让diff算法更加的高效；\"]},\"56\":{\"h\":\"Vue 的Options API\"},\"57\":{\"h\":\"Computed\"},\"58\":{\"h\":\"认识计算属性\",\"t\":[\"我们知道，在模板中可以直接通过插值语法显示一些data中的数据。\",\"但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示；\",\"比如我们需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示；\",\"在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算；\",\"在模板中放入太多的逻辑会让模板过重和难以维护；\",\"并且如果多个地方都使用到，那么会有大量重复的代码；\",\"我们有没有什么方法可以将逻辑抽离出去呢？\",\"可以，其中一种方式就是将逻辑抽取到一个method中，放到methods的options中；\",\"但是，这种做法有一个直观的弊端，就是所有的data使用过程都会变成了一个方法的调用；\",\"另外一种方式就是使用计算属性computed；\",\"什么是计算属性呢？\",\"https://cn.vuejs.org/api/reactivity-core.html#computed\",\"官方并没有给出直接的概念解释；\",\"而是说：对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性；\",\"计算属性将被混入到组件实例中。所有 getter 和 setter 的 this 上下文自动地绑定为组件实例；\"]},\"59\":{\"h\":\"基本使用\",\"t\":[\"计算属性的用法：\",\"选项： computed\",\"类型：{ [key: string]: Function | { get: Function, set: Function } }\",\"我们来看三个案例：\",\"我们有两个变量：firstName 和 lastName，希望它们拼接之后在界面上显示；\",\"我们有一个分数：score \",\"当score大于60的时候，在界面上显示及格；\",\"当score小于60的时候，在界面上显示不及格；\",\"我们有一个变量message，记录一段文字：比如Hello World \",\"某些情况下我们是直接显示这段文字；\",\"某些情况下我们需要对这段文字进行反转；\",\"我们可以有三种实现思路： \",\"思路一：在模板语法中直接使用表达式；\",\"思路二：使用method对逻辑进行抽取；\",\"思路三：使用计算属性computed；\"]},\"60\":{\"h\":\"在模板语法中直接使用表达式\",\"t\":[\"缺点一：模板中存在大量的复杂逻辑，不便于维护（模板中表达式的初衷是用于简单的计算）；\",\"缺点二：当有多次一样的逻辑时，存在重复的代码；\",\"缺点三：多次使用的时候，很多运算也需要多次执行，没有缓存；\",\"<template id=\\\"my-app\\\"> <!-- 1.实现思路一: --> <h2>{{ firstName + lastName }}</h2> <h2>{{ score >= 60 ? \\\"及格\\\": \\\"不及格\\\" }}</h2> <h2>{{ message.split(\\\"\\\").reverse().join(\\\" \\\") }}</h2> </template> \"]},\"61\":{\"h\":\"使用method对逻辑进行抽取\",\"t\":[\"缺点一：我们事实上先显示的是一个结果，但是都变成了一种方法的调用；\",\"缺点二：多次使用方法的时候，没有缓存，也需要多次计算；\",\"<template id=\\\"my-app\\\"> <h2>{{getFullName()}}</h2> <h2>{{getResult()}}</h2> <h2>{{getReverseMessage()}}</h2> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { firstName: \\\"Kobe\\\", lastName: \\\"Bryant\\\", score: 80, message: \\\"Hello World\\\" } }, methods: { getFullName() { return this.firstName + \\\" \\\" + this.lastName; }, getResult() { return this.score >= 60 ? \\\"及格\\\": \\\"不及格\\\"; }, getReverseMessage() { return this.message.split(\\\" \\\").reverse().join(\\\" \\\"); } } } Vue.createApp(App).mount('#app'); </script> \"]},\"62\":{\"h\":\"computed 实现\",\"t\":[\"注意：计算属性看起来像是一个函数，但是我们在使用的时候不需要加()，这个后面讲setter和getter时会讲到；\",\"我们会发现无论是直观上，还是效果上计算属性都是更好的选择；\",\"并且计算属性是有缓存的；\",\"<template id=\\\"my-app\\\"> <h2>{{fullName}}</h2> <h2>{{result}}</h2> <h2>{{reverseMessage}}</h2> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { firstName: \\\"Kobe\\\", lastName: \\\"Bryant\\\", score: 80, message: \\\"Hello World\\\" } }, computed: { // 定义了一个计算属性叫fullname fullName() { return this.firstName + \\\" \\\" + this.lastName; }, result() { return this.score >= 60 ? \\\"及格\\\": \\\"不及格\\\"; }, reverseMessage() { return this.message.split(\\\" \\\").reverse().join(\\\" \\\"); } } } Vue.createApp(App).mount('#app'); </script> \"]},\"63\":{\"h\":\"计算属性 vs methods\",\"t\":[\"在上面的实现思路中，我们会发现计算属性和methods的实现看起来是差别是不大的，而且我们多次提到计算属性有缓存。\",\"接下来我们来看一下同一个计算多次使用，计算属性和methods的差异：\",\"<template id=\\\"my-app\\\"> <button @click=\\\"changeFirstName\\\">修改firstName</button> <h2>{{fullName}}</h2> <h2>{{fullName}}</h2> <h2>{{fullName}}</h2> <h2>{{fullName}}</h2> <h2>{{fullName}}</h2> <h2>{{fullName}}</h2> <h2>{{fullName}}</h2> <h2>{{fullName}}</h2> <h2>{{getFullName()}}</h2> <h2>{{getFullName()}}</h2> <h2>{{getFullName()}}</h2> <h2>{{getFullName()}}</h2> <h2>{{getFullName()}}</h2> <h2>{{getFullName()}}</h2> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { firstName: \\\"Kobe\\\", lastName: \\\"Bryant\\\" } }, computed: { // 计算属性是有缓存的, 当我们多次使用计算属性时, 计算属性中的运算只会执行一次. // 计算属性会随着依赖的数据(firstName)的改变, 而进行重新计算. fullName() { console.log(\\\"computed的fullName中的计算\\\"); return this.firstName + \\\" \\\" + this.lastName; } }, methods: { getFullName() { console.log(\\\"methods的getFullName中的计算\\\"); return this.firstName + \\\" \\\" + this.lastName; }, changeFirstName() { this.firstName = \\\"Coder\\\" } } } Vue.createApp(App).mount('#app'); </script> \",\"打印结果如下：\",\"我们会发现methods在多次使用时，会调用多次；\",\"而计算属性虽然使用了多次，但是计算的过程只调用了一次；\",\"这是因为计算属性会基于它们的依赖关系进行缓存；\",\"在数据不发生变化时，计算属性是不需要重新计算的；\",\"但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算；如下:\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <input type=\\\"text\\\" v-model=\\\"score\\\"> <!-- 1.使用methods --> <h2>{{getResult()}}</h2> <h2>{{getResult()}}</h2> <h2>{{getResult()}}</h2> <!-- 2.使用computed --> <h2>{{result}}</h2> <h2>{{result}}</h2> <h2>{{result}}</h2> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { score: 90 } }, computed: { result() { console.log(\\\"调用了计算属性result的getter\\\"); return this.score >= 60 ? \\\"及格\\\": \\\"不及格\\\"; } }, methods: { getResult() { console.log(\\\"调用了getResult方法\\\"); return this.score >= 60 ? \\\"及格\\\": \\\"不及格\\\"; } } } Vue.createApp(App).mount('#app'); </script> </body> \",\"当 score 变化, console 输出如下:\",\"调用了getResult方法 调用了getResult方法 调用了getResult方法 调用了计算属性result的getter \"]},\"64\":{\"h\":\"计算属性的 setter 和 getter\",\"t\":[\"计算属性在大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数。\",\"但是，如果我们确实想设置计算属性的值呢？\",\"这个时候我们也可以给计算属性设置一个setter的方法；\",\"<template id=\\\"my-app\\\"> <button @click=\\\"changeFullName\\\">修改fullName</button> <h2>{{fullName}}</h2> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { firstName: \\\"Kobe\\\", lastName: \\\"Bryant\\\" } }, computed: { // fullName 的 getter方法 fullName() { return this.firstName + \\\" \\\" + this.lastName; }, // fullName的getter和setter方法 fullName: { get: function() { return this.firstName + \\\" \\\" + this.lastName; }, set: function(newValue) { console.log(newValue); const names = newValue.split(\\\" \\\"); this.firstName = names[0]; this.lastName = names[1]; } } }, methods: { changeFullName() { this.fullName = \\\"Coder Why\\\"; } } } Vue.createApp(App).mount('#app'); </script> \",\"以下为内部判断\",\"图片\"]},\"65\":{\"h\":\"侦听器 watch\",\"t\":[\"用于声明在数据更改时调用的侦听回调。watch 选项期望接受一个对象，其中键是需要侦听的响应式组件实例属性 (例如，通过 data 或 computed 声明的属性)——值是相应的回调函数。该回调函数接受被侦听源的新值和旧值。\",\"什么是侦听器？ \",\"开发中我们在data返回的对象中定义了数据，这个数据通过插值语法等方式绑定到template中;\",\"当数据变化时，template会自动进行更新来显示最新的数据;\",\"但是在某些情况下，我们希望在代码逻辑中监听某个数据的变化，这个时候就需要用侦听器watch来完成了;\",\"用法如下： \",\"选项：watch\",\"类型: {[key: string]: string | Function | Object | Array}\"]},\"66\":{\"h\":\"简单案例\",\"t\":[\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> 您的问题: <input type=\\\"text\\\" v-model=\\\"question\\\"> <button @click=\\\"queryAnswer\\\">查找答案</button> <p>您的问题是: {{ question }}</p> <p>答案是: {{ anwser }}</p> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { // 侦听question的变化时, 去进行一些逻辑的处理(JavaScript, 网络请求) question: \\\"Hello World\\\", anwser: \\\"\\\" } }, watch: { // question侦听的data中的属性的名称 // newValue变化后的新值 // oldValue变化前的旧值 question: function(newValue, oldValue) { console.log(\\\"新值: \\\", newValue, \\\"旧值\\\", oldValue); this.queryAnswer(); } }, methods: { queryAnswer() { // console.log(`你的问题${this.question}的答案是哈哈哈哈哈`); this.anwser = `你的问题${this.question}的答案是哈哈哈哈哈`; } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"67\":{\"h\":\"配置选项\",\"t\":[\"watch 默认是浅层的：被侦听的属性，仅在被赋新值时，才会触发回调函数——而嵌套属性的变化不会触发。如果想侦听所有嵌套的变更，你需要深层侦听器：\",\"以下为不使用深度监听, 当 info.name 在方法中被赋值改变时, 页面会改变, 但是watch不会侦听到, 理由如上\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <h2>{{info.name}}</h2> <button @click=\\\"changeInfo\\\">改变info</button> <!-- 页面会改变, 但是watch不会侦听到 --> <button @click=\\\"changeInfoName\\\">改变info.name</button> <button @click=\\\"changeInfoNbaName\\\">改变info.nba.name</button> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { info: { name: \\\"why\\\", age: 18, nba: {name: 'kobe'} } } }, watch: { // 默认情况下我们的侦听器只会针对监听的数据本身的改变(内部发生的改变是不能侦听) info(newInfo, oldInfo) { console.log(\\\"newValue:\\\", newInfo, \\\"oldValue:\\\", oldInfo); } }, methods: { changeInfo() { this.info = {name: \\\"kobe\\\"}; }, changeInfoName() { this.info.name = \\\"kobe\\\"; }, changeInfoNbaName() { this.info.nba.name = \\\"james\\\"; } } } Vue.createApp(App).mount('#app'); </script> </body> \",\"将 watch 中更改如下, 不管多深都会侦听到\",\"watch: { // 深度侦听/立即执行(一定会执行一次) info: { handler: function(newInfo, oldInfo) { console.log(\\\"newValue:\\\", newInfo, \\\"oldValue:\\\", oldInfo); }, deep: true, // 深度侦听 // immediate: true // 立即执行 } } \",\"immediate: true 立即执行, 这个时候无论后面数据是否有变化，侦听的函数都会有限执行一次；即当刷新页面时会立刻执行一次, 回调函数的初次执行就发生在 created 钩子之前。Vue 此时已经处理了 data、computed 和 methods 选项，所以这些属性在第一次调用时就是可用的。\",\"newValue: Proxy(Object) {name: 'why', age: 18, nba: {…}} oldValue: undefined \",\"注意: 引用对象 or watch 不能侦听到旧值, 可以利用 计算属性 缓存旧值, 或者自己深拷贝一份作为保存\"]},\"68\":{\"h\":\"其他方式\",\"t\":[\"https://cn.vuejs.org/api/options-state.html#watch\",\"export default { data() { return { a: 1, b: 2, c: { d: 4 }, e: 5, f: 6 } }, watch: { // 侦听根级属性 a(val, oldVal) { console.log(`new: ${val}, old: ${oldVal}`) }, // 字符串方法名称 b: 'someMethod', // 该回调将会在被侦听的对象的属性改变时调动，无论其被嵌套多深 c: { handler(val, oldVal) { console.log('c changed') }, deep: true }, // 侦听单个嵌套属性： 'c.d': function (val, oldVal) { // do something }, // 该回调将会在侦听开始之后立即调用 e: { handler(val, oldVal) { console.log('e changed') }, immediate: true }, // 你可以传入回调数组，它们将会被逐一调用 f: [ 'handle1', function handle2(val, oldVal) { console.log('handle2 triggered') }, { handler: function handle3(val, oldVal) { console.log('handle3 triggered') } /* ... */ } ] }, methods: { someMethod() { console.log('b changed') }, handle1() { console.log('handle 1 triggered') } }, created() { this.a = 3 // => new: 3, old: 1 } } \"]},\"69\":{\"h\":\"$watch 的API：\",\"t\":[\"https://cn.vuejs.org/api/component-instance.html#watch\",\"我们可以在created的生命周期（后续会讲到）中，使用 this.$watchs 来侦听；\",\"第一个参数是要侦听的源；\",\"第二个参数是侦听的回调函数callback；\",\"第三个参数是额外的其他选项，比如deep、immediate；\",\"created() { const unwatch = this.$watch(\\\"info\\\", function(newInfo, oldInfo) { console.log(newInfo, oldInfo); }, { deep: true, immediate: true }) // unwatch() } \"]},\"70\":{\"h\":\"阶段案例\",\"t\":[\"现在我们来做一个相对综合一点的练习：书籍购物车\",\"css\",\"table { border: 1px solid #e9e9e9; border-collapse: collapse; border-spacing: 0; } th, td { padding: 8px 16px; border: 1px solid #e9e9e9; text-align: left; } th { background-color: #f7f7f7; color: #5c6b77; font-weight: 600; } .counter { margin: 0 5px; } \",\"index\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <link rel=\\\"stylesheet\\\" href=\\\"./style.css\\\" /> </head> <body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <template v-if=\\\"books.length > 0\\\"> <table> <thead> <th>序号</th> <th>书籍名称</th> <th>出版日期</th> <th>价格</th> <th>购买数量</th> <th>操作</th> </thead> <tbody> <tr v-for=\\\"(book, index) in books\\\"> <td>{{index + 1}}</td> <td>{{book.name}}</td> <td>{{book.date}}</td> <td>{{formatPrice(book.price)}}</td> <td> <button :disabled=\\\"book.count <= 1\\\" @click=\\\"decrement(index)\\\"> - </button> <span class=\\\"counter\\\">{{book.count}}</span> <button @click=\\\"increment(index)\\\">+</button> </td> <td> <button @click=\\\"removeBook(index)\\\">移除</button> </td> </tr> </tbody> </table> <h2>总价格: {{formatPrice(totalPrice)}}</h2> </template> <template v-else> <h2>购物车为空~</h2> </template> </template> <script src=\\\"../js/vue.js\\\"></script> <script src=\\\"./index.js\\\"></script> <script> Vue.createApp({ template: \\\"#my-app\\\", data() { return { books: [ { id: 1, name: \\\"《算法导论》\\\", date: \\\"2006-9\\\", price: 85.0, count: 1, }, { id: 2, name: \\\"《UNIX编程艺术》\\\", date: \\\"2006-2\\\", price: 59.0, count: 1, }, { id: 3, name: \\\"《编程珠玑》\\\", date: \\\"2008-10\\\", price: 39.0, count: 1, }, { id: 4, name: \\\"《代码大全》\\\", date: \\\"2006-3\\\", price: 128.0, count: 1, }, ], }; }, computed: { totalPrice() { let finalPrice = 0; for (let book of this.books) { finalPrice += book.count * book.price; } return finalPrice; }, // Vue3不支持过滤器了, 推荐两种做法: 使用计算属性/使用全局的方法 filterBooks() { return this.books.map((item) => { const newItem = Object.assign({}, item); newItem.price = \\\"¥\\\" + item.price; return newItem; }); }, }, methods: { increment(index) { // 通过索引值获取到对象 this.books[index].count++; }, decrement(index) { this.books[index].count--; }, removeBook(index) { this.books.splice(index, 1); }, formatPrice(price) { return \\\"¥\\\" + price; }, }, }).mount(\\\"#app\\\"); </script> </body> </html> \"]},\"71\":{\"h\":\"v-model\",\"t\":[\"v-model 可以在组件上使用以实现双向绑定。\"]},\"72\":{\"h\":\"邂逅Vue3开发\"},\"73\":{\"h\":\"认识 Vue\"},\"74\":{\"h\":\"什么是 Vue\",\"t\":[\"Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。 \",\"全程是Vue.js或者Vuejs；\",\"什么是渐进式框架呢？表示我们可以在项目中一点点来引入和使用Vue，而不一定需要全部使用Vue来开发整个 项目；\"]},\"75\":{\"h\":\"Vue3带来的变化\",\"t\":[\"源码通过monorepo的形式来管理源代码： \",\"Mono：单个\",\"Repo：repository仓库\",\"主要是将许多项目的代码存储在同一个 repository 中；\",\"这样做的目的是多个包本身相互独立，可以有自己的功能逻辑、单元测试等，同时又在同一个仓库下方便管理；\",\"而且模块划分的更加清晰，可维护性、可扩展性更强；\",\"源码使用TypeScript来进行重写： \",\"在Vue2.x的时候，Vue使用 Flow 来进行类型检测；\",\"在Vue3.x的时候，Vue的源码全部使用 TypeScript 来进行重构，并且 Vue 本身对 TypeScript 支持也更好了；\"]},\"76\":{\"h\":\"性能方面\",\"t\":[\"使用Proxy进行数据劫持 \",\"在 Vue2.x 的时候，Vue2 是使用 Object.defineProperty 来劫持数据的 getter 和 setter 方法的；\",\"这种方式一致存在一个缺陷就是当给对象添加或者删除属性时，是无法劫持和监听的；\",\"所以在 Vue2.x 的时候，不得不提供一些特殊的API，比如 $set 或 $delete ，事实上都是一些 hack 方法，也增加了 开发者学习新的API的成本；\",\"而在 Vue3.x 开始，Vue 使用 Proxy 来实现数据的劫持\",\"删除了一些不必要的API： \",\"移除了实例上的 $on , $off 和 $once；\",\"移除了一些特性：如filter、内联模板等；\",\"包括编译方面的优化： \",\"生成Block Tree、Slot编译优化、diff算法优化；\"]},\"77\":{\"h\":\"新的API\",\"t\":[\"由Options API 到 Composition API： \",\"在 Vue2.x 的时候，我们会通过 Options API 来描述组件对象；\",\"Options API 包括data、props、methods、computed、生命周期等等这些选项；\",\"存在比较大的问题是多个逻辑可能是在不同的地方： \",\"比如created中会使用某一个method来修改data的数据，代码的内聚性非常差；\",\"Composition API可以将 相关联的代码 放到同一处 进行处理，而不需要在多个Options之间寻找；\",\"Hooks函数增加代码的复用性： \",\"在Vue2.x的时候，我们通常通过mixins在多个组件之间共享逻辑；但是有一个很大的缺陷就是 mixins也是由一大堆的Options组成的，并且多个mixins会存在命名冲突的问题；\",\"在Vue3.x中，我们可以通过Hook函数，来将一部分独立的逻辑抽取出去，并且它们还可以做到是响应式的；\"]},\"78\":{\"h\":\"如何使用 Vue\",\"t\":[\"方式一：在页面中通过CDN的方式来引入；\",\"方式二：下载Vue的JavaScript文件，并且自己手动引入；\",\"方式三：通过npm包管理工具安装使用它；\",\"方式四：直接通过Vue CLI创建项目，并且使用它；\"]},\"79\":{\"h\":\"CDN 引入\",\"t\":[\"<script src=\\\"https://unpkg.com/vue@next\\\"></script> \"]},\"80\":{\"h\":\"下载和引入\",\"t\":[\"下载Vue的源码，可以直接打开CDN的链接： \",\"打开链接，复制其中所有的代码；\",\"创建一个新的文件，比如vue.js，将代码复制到其中；\",\"<script src=\\\"../js/vue.js\\\"></script> \"]},\"81\":{\"h\":\"声明式编程和命令式编程\",\"t\":[\"原生开发和Vue开发的模式和特点,我们会发现是完全不同的,这里其实涉及到两种不同的编程范式命令式编程和声明式编程\",\"命令式编程关注的是“ how to do”,声明式编程关注的是\\\" what to do\\\",由框架(机器)完成\\\"how\\\"的过程\"]},\"82\":{\"h\":\"MVVM模型\",\"t\":[\"MVC和MVVM都是一种软件的体系结构 \",\"MVC是 Model-View-Controller的简称,是在前期被使用非常框架的架构模式,比如iS、前端\",\"MVVM是 Model-View- ViewMode的简称,是目前非常流行的架构模式\",\"通常情况下,我们也经常称vue是一个MVVM的框架 \",\"vue官方其实有说明,vue虽然并没有完全遵守MVVM的模型,但是整个设计是受到它的启发的\"]},\"83\":{\"h\":\"template属性\",\"t\":[\"在使用 createApp的时候,我们传入了一个对象,接下来我们详细解析一下之前传入的属性分别代表什么含义。 \",\"template属性:表示的是Vue需要帮助我们渲染的模板信息\",\"目前我们看到它里面有很多的HTML标签,这些标签会替换掉我们挂载到的元素(比如id为app的dⅳv)的innerHTML\",\"模板中有一些奇怪的语法,比如{},比如@ )click,这些都是模板特有的语法\",\"但是这个模板的写法有点过于别扭了,并且IDE很有可能没有任何提示,阻碍我们编程的效率\",\"vue提供了两种方式:\",\"方式一:使用 script标签,并且标记它的类型为 X-template;\",\"<body> <div id=\\\"app\\\">hhhh</div> <script type=\\\"x-template\\\" id=\\\"why\\\"> <div> <h2>{{message}}</h2> <h2>{{counter}}</h2> <button @click='increment'>+1</button> <button @click='decrement'>-1</button> </div> </script> <script src=\\\"../js//Vue.js\\\"></script> <script> Vue.createApp({ template: '#why', data: function(){ return{ message:\\\"Hello World\\\", counter: 100 } }, methods: { increment(){ this.counter++ }, decrement(){ this.counter-- } } }).mount(\\\"#app\\\") </script> </body> \",\"方式二:使用任意标签(通常使用 template标签,因为不会被浏览器渲染),设置id;v template元素是一种用于保存客户端内容的机制,该内容再加载页面时不会被呈现,但随后可以在运行时使用 JavaScript 实例化\",\" <body> <div id=\\\"app\\\"></div> <template id=\\\"why\\\"> <div> <h2>{{message}}</h2> <h2>{{counter}}</h2> <button @click='increment'>+1</button> <button @click='decrement'>-1</button> </div> </template> <script src=\\\"../js//Vue.js\\\"></script> <script> Vue.createApp({ template: '#why', data: function(){ return{ message:\\\"Hello World\\\", counter: 100 } }, methods: { increment(){ this.counter++ }, decrement(){ this.counter-- } } }).mount(\\\"#app\\\") </script> </body> \"]},\"84\":{\"h\":\"data属性\",\"t\":[\"data属性是传入一个函数,并且该函数需要返回一个对象\",\"在Vue2x的时候,也可以传入一个对象(虽然官方推荐是一个函数);\",\"在Vue3x的时候,必须传入一个函数,否则就会直接在浏览器中报错\",\"data中返回的对象会被vue的响应式系统劫持,之后对该对象的修改或者访问都会在劫持中被处理\",\"所以我们在 template中通过{ counter} 访问 counter,可以从对象中获取到数据\",\"所以我们修改 counter的值时, template中的{ counter)也会发生改变;\"]},\"85\":{\"h\":\"methods属性（重点）\",\"t\":[\"methods属性是一个对象,通常我们会在这个对象中定义很多的方法\",\"这些方法可以被绑定到 template模板中;\",\"在该方法中,我们可以使用this关键字来直接访问到data中返回的对象的属性;\",\"问题：官方文档有这个描述，即不能使用箭头函数\",\"为什么不能使用箭头函数(VUE3.0)？\",\"我们在methods中要使用data返回对象中的数据：\",\"那么这个this是必须有值的，并且应该可以通过this获取到data返回对象中的数据。\",\"那么我们这个this能不能是window呢？\",\"不可以是window，因为window中我们无法获取到data返回对象中的数据；\",\"但是如果我们使用箭头函数，那么这个this就会是window了；\",\"为什么是window呢？\",\"这里涉及到箭头函数使用this的查找规则，它会在自己的上层作用于中来查找this；\",\"最终刚好找到的是script作用于中的this，所以就是window；\",\"this到底是如何查找和绑定的呢？\",\"前端面试之彻底搞懂this指向\",\"不使用箭头函数的情况下，this到底指向什么\",\"事实上Vue的源码当中就是对methods中的所有函数进行了遍历，并且通过 bind 绑定了 this\",\"具体看 https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA\",\"// window 隐式绑定 foo(); const obj = { bar: foo }; obj.bar(); /* Window{} {bar: f()} */ const foo2 = () => { console.log(this); } const obj2 = { bar: foo2 }; obj2.bar(); /* Window{} Window{} */ \"]},\"86\":{\"h\":\"如何阅读Vue源码\",\"t\":[\"需要的环境 npm，yarn\",\"操作步骤 \",\"安装yarn npm install yarn -g\",\"在项目中配置yarn yarn install\",\"在package.json中的dev后加上--sourcemap\",\"打包项目 yarn dev （在vue/dist文件夹下有两个文件，vue.global.js和vue.global.js.map）\",\"在vue/examplex新建自己的文件夹以及测试demo\",\"在demo中打下断点—debugger\",\"在浏览器中打开调试面板，选择其中的source面板，查看执行对应的源码\"]},\"87\":{\"h\":\"Js\"},\"88\":{\"h\":\"Web\"},\"89\":{\"h\":\"Essential\"},\"90\":{\"h\":\"Learn\"},\"91\":{\"h\":\"Vue\"}},\"dirtCount\":0,\"index\":[[\"查看执行对应的源码\",{\"1\":{\"86\":1}}],[\"选择其中的source面板\",{\"1\":{\"86\":1}}],[\"选项期望接受一个对象\",{\"1\":{\"65\":1}}],[\"选项\",{\"1\":{\"59\":1,\"65\":1,\"67\":1}}],[\"安装yarn\",{\"1\":{\"86\":1}}],[\"安装loadsh\",{\"1\":{\"16\":1}}],[\"操作步骤\",{\"1\":{\"86\":1}}],[\"操作符来检查该元素上是否定义了和绑定的\",{\"1\":{\"27\":1}}],[\"隐式绑定\",{\"1\":{\"85\":1}}],[\"qq\",{\"1\":{\"85\":1}}],[\"queryanswer\",{\"1\":{\"66\":3}}],[\"question侦听的data中的属性的名称\",{\"1\":{\"66\":1}}],[\"question\",{\"1\":{\"66\":6}}],[\"具体看\",{\"1\":{\"85\":1}}],[\"具体的步骤如下\",{\"1\":{\"18\":1}}],[\"最终刚好找到的是script作用于中的this\",{\"1\":{\"85\":1}}],[\"为什么是window呢\",{\"1\":{\"85\":1}}],[\"为什么不能使用箭头函数\",{\"1\":{\"85\":1}}],[\"问题\",{\"1\":{\"85\":1}}],[\"重点\",{\"0\":{\"85\":1}}],[\"访问\",{\"1\":{\"84\":1}}],[\"之后对该对象的修改或者访问都会在劫持中被处理\",{\"1\":{\"84\":1}}],[\"之后通过babe将js编译成\",{\"1\":{\"19\":1}}],[\"否则就会直接在浏览器中报错\",{\"1\":{\"84\":1}}],[\"必须传入一个函数\",{\"1\":{\"84\":1}}],[\"必须在子组件中已被正确声明\",{\"1\":{\"27\":1}}],[\"虽然官方推荐是一个函数\",{\"1\":{\"84\":1}}],[\"实例化\",{\"1\":{\"83\":1}}],[\"实现\",{\"0\":{\"62\":1}}],[\"实现思路一\",{\"1\":{\"60\":1}}],[\"实现深拷贝\",{\"1\":{\"16\":1}}],[\"但随后可以在运行时使用\",{\"1\":{\"83\":1}}],[\"但是这个模板的写法有点过于别扭了\",{\"1\":{\"83\":1}}],[\"但是整个设计是受到它的启发的\",{\"1\":{\"82\":1}}],[\"但是有一个很大的缺陷就是\",{\"1\":{\"77\":1}}],[\"但是watch不会侦听到\",{\"1\":{\"67\":2}}],[\"但是如果我们使用箭头函数\",{\"1\":{\"85\":1}}],[\"但是如果我们希望切换的是多个元素呢\",{\"1\":{\"43\":1}}],[\"但是如果依赖的数据发生变化\",{\"1\":{\"63\":1}}],[\"但是计算的过程只调用了一次\",{\"1\":{\"63\":1}}],[\"但是我们在使用的时候不需要加\",{\"1\":{\"62\":1}}],[\"但是我们并不希望div这种元素被渲染\",{\"1\":{\"43\":1}}],[\"但是都变成了一种方法的调用\",{\"1\":{\"61\":1}}],[\"但是\",{\"1\":{\"58\":1,\"64\":1}}],[\"但是设计它们的初衷是用于简单的运算\",{\"1\":{\"58\":1}}],[\"但是在某些情况下\",{\"1\":{\"65\":1}}],[\"但是在某些情况\",{\"1\":{\"58\":1}}],[\"但是依然有旧的节点\",{\"1\":{\"54\":1}}],[\"但是依然有新的节点\",{\"1\":{\"54\":1}}],[\"但是因为我们的c被f所使用了\",{\"1\":{\"54\":1}}],[\"但是某些方法不会替换原来的数组\",{\"1\":{\"49\":1}}],[\"但是最终template不会被渲染出来\",{\"1\":{\"43\":1}}],[\"但是注意\",{\"1\":{\"39\":1}}],[\"但是你也可以显式用\",{\"1\":{\"27\":1}}],[\"但是大多数情况下\",{\"1\":{\"19\":1}}],[\"但是对应两个不同的地址\",{\"1\":{\"11\":1}}],[\"阻碍我们编程的效率\",{\"1\":{\"83\":1}}],[\"目前我们看到它里面有很多的html标签\",{\"1\":{\"83\":1}}],[\"接下来我们详细解析一下之前传入的属性分别代表什么含义\",{\"1\":{\"83\":1}}],[\"接下来我们来看一下同一个计算多次使用\",{\"1\":{\"63\":1}}],[\"通常我们会在这个对象中定义很多的方法\",{\"1\":{\"85\":1}}],[\"通常使用\",{\"1\":{\"83\":1}}],[\"通常情况下\",{\"1\":{\"82\":1}}],[\"通过npm包管理工具安装使用它\",{\"1\":{\"78\":1}}],[\"通过索引值获取到对象\",{\"1\":{\"70\":1}}],[\"通过\",{\"1\":{\"65\":1}}],[\"完成\",{\"1\":{\"81\":1}}],[\"完整写法\",{\"1\":{\"38\":1}}],[\"完整代码\",{\"1\":{\"22\":1}}],[\"机器\",{\"1\":{\"81\":1}}],[\"由框架\",{\"1\":{\"81\":1}}],[\"由options\",{\"1\":{\"77\":1}}],[\"命令式编程关注的是\",{\"1\":{\"81\":1}}],[\"原生开发和vue开发的模式和特点\",{\"1\":{\"81\":1}}],[\"声明式编程关注的是\",{\"1\":{\"81\":1}}],[\"声明式编程和命令式编程\",{\"0\":{\"81\":1}}],[\"声明的属性\",{\"1\":{\"65\":1}}],[\"创建一个新的文件\",{\"1\":{\"80\":1}}],[\"打包项目\",{\"1\":{\"86\":1}}],[\"打开链接\",{\"1\":{\"80\":1}}],[\"打印结果如下\",{\"1\":{\"63\":1}}],[\"下载vue的源码\",{\"1\":{\"80\":1}}],[\"下载vue的javascript文件\",{\"1\":{\"78\":1}}],[\"下载和引入\",{\"0\":{\"80\":1}}],[\"下文中的代码的意思是\",{\"1\":{\"49\":1}}],[\"进行处理\",{\"1\":{\"77\":1}}],[\"进行递归\",{\"1\":{\"12\":1}}],[\"放到同一处\",{\"1\":{\"77\":1}}],[\"放到methods的options中\",{\"1\":{\"58\":1}}],[\"相关联的代码\",{\"1\":{\"77\":1}}],[\"存在比较大的问题是多个逻辑可能是在不同的地方\",{\"1\":{\"77\":1}}],[\"存在重复的代码\",{\"1\":{\"60\":1}}],[\"生命周期等等这些选项\",{\"1\":{\"77\":1}}],[\"生成block\",{\"1\":{\"76\":1}}],[\"生成补丁\",{\"1\":{\"54\":1}}],[\"包括data\",{\"1\":{\"77\":1}}],[\"包括编译方面的优化\",{\"1\":{\"76\":1}}],[\"到\",{\"1\":{\"77\":1}}],[\"到表达式\",{\"1\":{\"27\":1}}],[\"新的api\",{\"0\":{\"77\":1}}],[\"新值\",{\"1\":{\"66\":1}}],[\"内联模板等\",{\"1\":{\"76\":1}}],[\"内部发生的改变是不能侦听\",{\"1\":{\"67\":1}}],[\"移除了一些特性\",{\"1\":{\"76\":1}}],[\"移除了实例上的\",{\"1\":{\"76\":1}}],[\"删除了一些不必要的api\",{\"1\":{\"76\":1}}],[\"开始\",{\"1\":{\"76\":1}}],[\"开发者学习新的api的成本\",{\"1\":{\"76\":1}}],[\"开发中我们在data返回的对象中定义了数据\",{\"1\":{\"65\":1}}],[\"开发中如何进行选择呢\",{\"1\":{\"45\":1}}],[\"性能方面\",{\"0\":{\"76\":1}}],[\"支持也更好了\",{\"1\":{\"75\":1}}],[\"支持额外的值类型如数组或对象\",{\"1\":{\"27\":1}}],[\"本身对\",{\"1\":{\"75\":1}}],[\"本质的区别\",{\"1\":{\"45\":1}}],[\"源码使用typescript来进行重写\",{\"1\":{\"75\":1}}],[\"源码通过monorepo的形式来管理源代码\",{\"1\":{\"75\":1}}],[\"单元测试等\",{\"1\":{\"75\":1}}],[\"单个\",{\"1\":{\"75\":1}}],[\"项目\",{\"1\":{\"74\":1}}],[\"全程是vue\",{\"1\":{\"74\":1}}],[\"读音\",{\"1\":{\"74\":1}}],[\"邂逅vue3开发\",{\"0\":{\"72\":1}}],[\"¥\",{\"1\":{\"70\":2}}],[\"推荐两种做法\",{\"1\":{\"70\":1}}],[\"代码的内聚性非常差\",{\"1\":{\"77\":1}}],[\"代码大全\",{\"1\":{\"70\":1}}],[\"代码片段\",{\"0\":{\"18\":1}}],[\"编程珠玑\",{\"1\":{\"70\":1}}],[\"书籍购物车\",{\"1\":{\"70\":1}}],[\"现在我们来做一个相对综合一点的练习\",{\"1\":{\"70\":1}}],[\"阶段案例\",{\"0\":{\"70\":1}}],[\"后续会讲到\",{\"1\":{\"69\":1}}],[\"后者是将其地址存在栈内存中\",{\"1\":{\"1\":1}}],[\"$off\",{\"1\":{\"76\":1}}],[\"$once\",{\"1\":{\"76\":1}}],[\"$on\",{\"1\":{\"76\":1}}],[\"$delete\",{\"1\":{\"76\":1}}],[\"$set\",{\"1\":{\"76\":1}}],[\"$watchs\",{\"1\":{\"69\":1}}],[\"$watch\",{\"0\":{\"69\":1},\"1\":{\"69\":1}}],[\"$\",{\"1\":{\"68\":2}}],[\"$event可以获取到事件发生时的事件对象\",{\"1\":{\"39\":1}}],[\"$event\",{\"1\":{\"39\":2}}],[\"`\",{\"1\":{\"68\":1}}],[\"`new\",{\"1\":{\"68\":1}}],[\"`你的问题$\",{\"1\":{\"66\":2}}],[\"缓存旧值\",{\"1\":{\"67\":1}}],[\"引入\",{\"0\":{\"79\":1}}],[\"引入loadsh\",{\"1\":{\"16\":2}}],[\"引用对象\",{\"1\":{\"67\":1}}],[\"此时已经处理了\",{\"1\":{\"67\":1}}],[\"此时我们渲染div\",{\"1\":{\"43\":1}}],[\"钩子之前\",{\"1\":{\"67\":1}}],[\"回调函数的初次执行就发生在\",{\"1\":{\"67\":1}}],[\"一定会执行一次\",{\"1\":{\"67\":1}}],[\"一个参数\",{\"1\":{\"47\":1}}],[\"一个对象\",{\"1\":{\"30\":1}}],[\"立即执行\",{\"1\":{\"67\":3}}],[\"理由如上\",{\"1\":{\"67\":1}}],[\"页面会改变\",{\"1\":{\"67\":2}}],[\"仅在被赋新值时\",{\"1\":{\"67\":1}}],[\"仅当事件是从特定键触发时才触发回调\",{\"1\":{\"37\":1,\"40\":1}}],[\"被侦听的属性\",{\"1\":{\"67\":1}}],[\"配置选项\",{\"0\":{\"67\":1}}],[\"配合像\",{\"1\":{\"26\":1}}],[\"旧值\",{\"1\":{\"66\":1}}],[\"网络请求\",{\"1\":{\"66\":1}}],[\"网球\",{\"1\":{\"12\":3,\"13\":1,\"14\":1}}],[\"去进行一些逻辑的处理\",{\"1\":{\"66\":1}}],[\"侦听单个嵌套属性\",{\"1\":{\"68\":1}}],[\"侦听根级属性\",{\"1\":{\"68\":1}}],[\"侦听的函数都会有限执行一次\",{\"1\":{\"67\":1}}],[\"侦听question的变化时\",{\"1\":{\"66\":1}}],[\"侦听器\",{\"0\":{\"65\":1}}],[\"您的问题\",{\"1\":{\"66\":1}}],[\"简单案例\",{\"0\":{\"66\":1}}],[\"该内容再加载页面时不会被呈现\",{\"1\":{\"83\":1}}],[\"该回调将会在侦听开始之后立即调用\",{\"1\":{\"68\":1}}],[\"该回调将会在被侦听的对象的属性改变时调动\",{\"1\":{\"68\":1}}],[\"该回调函数接受被侦听源的新值和旧值\",{\"1\":{\"65\":1}}],[\"该指令只在没有构建步骤的环境下需要使用\",{\"1\":{\"26\":1}}],[\"该指令可以用于性能优化\",{\"1\":{\"22\":1}}],[\"图片\",{\"1\":{\"64\":1}}],[\"输出如下\",{\"1\":{\"63\":1}}],[\"变化\",{\"1\":{\"63\":1}}],[\"定义了一个计算属性叫fullname\",{\"1\":{\"62\":1}}],[\"还是效果上计算属性都是更好的选择\",{\"1\":{\"62\":1}}],[\"注意\",{\"1\":{\"62\":1,\"67\":1}}],[\"注意上面的顺序\",{\"1\":{\"47\":1}}],[\"85\",{\"1\":{\"70\":1}}],[\"8\",{\"1\":{\"70\":1}}],[\"8px\",{\"1\":{\"70\":1}}],[\"80\",{\"1\":{\"61\":1,\"62\":1}}],[\"88\",{\"1\":{\"36\":2,\"47\":1,\"48\":1}}],[\"及格\",{\"1\":{\"60\":1,\"61\":1,\"62\":1,\"63\":2}}],[\"没有缓存\",{\"1\":{\"60\":1,\"61\":1}}],[\"没有key的操作过程\",{\"1\":{\"54\":1}}],[\"没有key的时候\",{\"1\":{\"50\":1}}],[\"没有key\",{\"1\":{\"54\":1}}],[\"很多运算也需要多次执行\",{\"1\":{\"60\":1}}],[\"多次使用方法的时候\",{\"1\":{\"61\":1}}],[\"多次使用的时候\",{\"1\":{\"60\":1}}],[\"多平台的渲染\",{\"1\":{\"51\":1}}],[\"缺点三\",{\"1\":{\"60\":1}}],[\"缺点二\",{\"1\":{\"60\":1,\"61\":1}}],[\"缺点一\",{\"1\":{\"60\":1,\"61\":1}}],[\"思路三\",{\"1\":{\"59\":1}}],[\"思路二\",{\"1\":{\"59\":1}}],[\"思路一\",{\"1\":{\"59\":1}}],[\"某些情况下我们需要对这段文字进行反转\",{\"1\":{\"59\":1}}],[\"某些情况下我们是直接显示这段文字\",{\"1\":{\"59\":1}}],[\"记录一段文字\",{\"1\":{\"59\":1}}],[\"记得用引号括起来\",{\"1\":{\"32\":2}}],[\"希望它们拼接之后在界面上显示\",{\"1\":{\"59\":1}}],[\"类似于\",{\"1\":{\"74\":1}}],[\"类似于v\",{\"1\":{\"48\":1}}],[\"类型\",{\"1\":{\"59\":1,\"65\":1}}],[\"上下文自动地绑定为组件实例\",{\"1\":{\"58\":1}}],[\"上面的方法会直接修改原来的数组\",{\"1\":{\"49\":1}}],[\"你可以传入回调数组\",{\"1\":{\"68\":1}}],[\"你可以使用\",{\"1\":{\"48\":1}}],[\"你需要深层侦听器\",{\"1\":{\"67\":1}}],[\"你都应该使用计算属性\",{\"1\":{\"58\":1}}],[\"官方文档有这个描述\",{\"1\":{\"85\":1}}],[\"官方并没有给出直接的概念解释\",{\"1\":{\"58\":1}}],[\"官方的解释对于初学者来说并不好理解\",{\"1\":{\"50\":1}}],[\"另外一种方式就是使用计算属性computed\",{\"1\":{\"58\":1}}],[\"就是所有的data使用过程都会变成了一个方法的调用\",{\"1\":{\"58\":1}}],[\"保持相同的key可以让diff算法更加的高效\",{\"1\":{\"55\":1}}],[\"比较\",{\"1\":{\"54\":2}}],[\"比如id为app的dⅳv\",{\"1\":{\"83\":1}}],[\"比如is\",{\"1\":{\"82\":1}}],[\"比如vue\",{\"1\":{\"80\":1}}],[\"比如created中会使用某一个method来修改data的数据\",{\"1\":{\"77\":1}}],[\"比如deep\",{\"1\":{\"69\":1}}],[\"比如hello\",{\"1\":{\"59\":1}}],[\"比如我们需要对多个data数据进行运算\",{\"1\":{\"58\":1}}],[\"比如下面的问题\",{\"1\":{\"50\":1}}],[\"比如点击\",{\"1\":{\"37\":1}}],[\"比如某段文字的颜色\",{\"1\":{\"32\":1}}],[\"比如\",{\"1\":{\"13\":1,\"14\":2,\"29\":1,\"49\":1,\"76\":1,\"83\":2}}],[\"应用补丁\",{\"1\":{\"54\":1}}],[\"应该怎么做呢\",{\"1\":{\"36\":1}}],[\"→\",{\"1\":{\"54\":2}}],[\"触发更新\",{\"1\":{\"54\":1}}],[\"算法导论\",{\"1\":{\"70\":1}}],[\"算法一定存在这样一个过程\",{\"1\":{\"54\":1}}],[\"算法是指生成更新补丁的方式\",{\"1\":{\"54\":1}}],[\"更新真实\",{\"1\":{\"54\":1}}],[\"树变化后\",{\"1\":{\"54\":1}}],[\"主要是将许多项目的代码存储在同一个\",{\"1\":{\"75\":1}}],[\"主要应用于虚拟\",{\"1\":{\"54\":1}}],[\"主要好处\",{\"1\":{\"51\":1}}],[\"表示的是vue需要帮助我们渲染的模板信息\",{\"1\":{\"83\":1}}],[\"表示我们可以在项目中一点点来引入和使用vue\",{\"1\":{\"74\":1}}],[\"表\",{\"1\":{\"53\":1}}],[\"表达式\",{\"1\":{\"20\":1}}],[\"需要的环境\",{\"1\":{\"86\":1}}],[\"需要更新的是我们\",{\"1\":{\"53\":1}}],[\"需要注意参数问题\",{\"1\":{\"39\":1}}],[\"插入\",{\"0\":{\"53\":1}}],[\"真实\",{\"1\":{\"52\":1}}],[\"与\",{\"1\":{\"52\":1}}],[\"虚拟\",{\"0\":{\"52\":1},\"1\":{\"52\":1}}],[\"跨平台\",{\"1\":{\"51\":1}}],[\"好处\",{\"1\":{\"51\":1}}],[\"无论其被嵌套多深\",{\"1\":{\"68\":1}}],[\"无论是组件还是元素\",{\"1\":{\"51\":1}}],[\"无需传入\",{\"1\":{\"26\":1}}],[\"事实上vue的源码当中就是对methods中的所有函数进行了遍历\",{\"1\":{\"85\":1}}],[\"事实上都是一些\",{\"1\":{\"76\":1}}],[\"事实上\",{\"1\":{\"51\":1}}],[\"事件冒泡到父元素\",{\"1\":{\"40\":1}}],[\"事件可以参考\",{\"1\":{\"37\":1}}],[\"认识计算属性\",{\"0\":{\"58\":1}}],[\"认识\",{\"0\":{\"51\":1,\"73\":1}}],[\"什么是渐进式框架呢\",{\"1\":{\"74\":1}}],[\"什么是\",{\"0\":{\"74\":1}}],[\"什么是侦听器\",{\"1\":{\"65\":1}}],[\"什么是计算属性呢\",{\"1\":{\"58\":1}}],[\"什么是vnode\",{\"1\":{\"50\":1}}],[\"什么是新旧nodes\",{\"1\":{\"50\":1}}],[\"销毁key不存在的元素\",{\"1\":{\"50\":1}}],[\"复制其中所有的代码\",{\"1\":{\"80\":1}}],[\"复制自己需要生成代码片段的代码\",{\"1\":{\"18\":1}}],[\"复用相同类型元素的算法\",{\"1\":{\"50\":1}}],[\"过滤掉长度小于等于2的电影\",{\"1\":{\"49\":1}}],[\"替换数组的方法\",{\"1\":{\"49\":1}}],[\"元素\",{\"1\":{\"51\":1}}],[\"元素来循环渲染一段包含多个元素的内容\",{\"1\":{\"48\":1}}],[\"元素或者组件以及其所有的子元素将视为静态内容并且跳过\",{\"1\":{\"22\":1}}],[\"少年派\",{\"1\":{\"47\":1,\"49\":1}}],[\"教父\",{\"1\":{\"47\":1,\"49\":1}}],[\"大话西游\",{\"1\":{\"47\":1,\"49\":1}}],[\"大小等等\",{\"1\":{\"32\":1}}],[\"盗梦空间\",{\"1\":{\"47\":1,\"49\":1}}],[\"星际穿越\",{\"1\":{\"47\":1,\"49\":1}}],[\"遍历数组\",{\"1\":{\"47\":1}}],[\"遍历对象\",{\"0\":{\"13\":1},\"1\":{\"47\":1}}],[\"每一个item都是一个数字\",{\"1\":{\"47\":1}}],[\"三个参数\",{\"1\":{\"47\":1}}],[\"三元运算符来决定结果\",{\"1\":{\"58\":1}}],[\"三元运算符\",{\"1\":{\"20\":2}}],[\"二个参数\",{\"1\":{\"47\":1}}],[\"索引项index是在后面的\",{\"1\":{\"47\":1}}],[\"切换\",{\"1\":{\"45\":1}}],[\"首先\",{\"1\":{\"45\":1}}],[\"因为window中我们无法获取到data返回对象中的数据\",{\"1\":{\"85\":1}}],[\"因为不会被浏览器渲染\",{\"1\":{\"83\":1}}],[\"因为对于列表中\",{\"1\":{\"53\":1}}],[\"因为目前我们还没有比较完整的学习组件的概念\",{\"1\":{\"51\":1}}],[\"因为v\",{\"1\":{\"43\":1}}],[\"因此\",{\"1\":{\"3\":2}}],[\"才会触发回调函数\",{\"1\":{\"67\":1}}],[\"才会真正渲染条件块中的内容\",{\"1\":{\"43\":1}}],[\"才会被渲染出来\",{\"1\":{\"42\":1}}],[\"其他方式\",{\"0\":{\"68\":1}}],[\"其他方法\",{\"0\":{\"15\":1}}],[\"其中键是需要侦听的响应式组件实例属性\",{\"1\":{\"65\":1}}],[\"其中一种方式就是将逻辑抽取到一个method中\",{\"1\":{\"58\":1}}],[\"其对应的元素压根不会被渲染到dom中\",{\"1\":{\"45\":1}}],[\"其次\",{\"1\":{\"45\":1}}],[\"其判断的内容完全不会被渲染或者会被销毁掉\",{\"1\":{\"43\":1}}],[\"结合使用\",{\"0\":{\"43\":1}}],[\"9\",{\"1\":{\"70\":1}}],[\"95\",{\"1\":{\"42\":1}}],[\"90\",{\"1\":{\"42\":1,\"63\":1}}],[\"条件渲染\",{\"0\":{\"41\":1}}],[\"继续执行父元素的事件处理函数\",{\"1\":{\"40\":1}}],[\"然后再冒泡到该元素的父元素\",{\"1\":{\"40\":1}}],[\"传入事件\",{\"1\":{\"39\":1}}],[\"时\",{\"1\":{\"39\":1}}],[\"同时又在同一个仓库下方便管理\",{\"1\":{\"75\":1}}],[\"同时需要\",{\"1\":{\"39\":1}}],[\"同名的\",{\"1\":{\"27\":1}}],[\"情况二\",{\"1\":{\"39\":1}}],[\"情况一\",{\"1\":{\"39\":1}}],[\"鼠标移动\",{\"1\":{\"38\":1}}],[\"按钮1发生了点击\",{\"1\":{\"38\":1}}],[\"监听的事件=\",{\"1\":{\"38\":1}}],[\"只需要一个getter方法即可\",{\"1\":{\"64\":1}}],[\"只是通过css的display属性来进行\",{\"1\":{\"45\":1}}],[\"只当点击鼠标中键时触发\",{\"1\":{\"37\":1,\"40\":1}}],[\"只当点击鼠标右键时触发\",{\"1\":{\"37\":1,\"40\":1}}],[\"只当点击鼠标左键时触发\",{\"1\":{\"37\":1,\"40\":1}}],[\"只当事件是从侦听器绑定的元素本身触发时才触发回调\",{\"1\":{\"37\":1,\"40\":1}}],[\"只触发一次回调\",{\"1\":{\"37\":1,\"40\":1}}],[\"模式添加侦听器\",{\"1\":{\"37\":1,\"40\":1}}],[\"模式\",{\"1\":{\"37\":1,\"40\":1}}],[\"模板中有一些奇怪的语法\",{\"1\":{\"83\":1}}],[\"模板中表达式的初衷是用于简单的计算\",{\"1\":{\"60\":1}}],[\"模板中存在大量的复杂逻辑\",{\"1\":{\"60\":1}}],[\"模板\",{\"1\":{\"26\":1}}],[\"模板语法\",{\"0\":{\"19\":1}}],[\"添加事件侦听器时使用\",{\"1\":{\"37\":1,\"40\":1}}],[\"调用了getresult方法\",{\"1\":{\"63\":4}}],[\"调用了计算属性result的getter\",{\"1\":{\"63\":2}}],[\"调用\",{\"1\":{\"37\":2,\"40\":2}}],[\"调用一个方法\",{\"1\":{\"33\":1}}],[\"预期\",{\"1\":{\"37\":1}}],[\"键盘事件等等\",{\"1\":{\"37\":1}}],[\"拖拽\",{\"1\":{\"37\":1}}],[\"案例\",{\"1\":{\"36\":1}}],[\"非常简单\",{\"1\":{\"36\":1}}],[\"值是相应的回调函数\",{\"1\":{\"65\":1}}],[\"值\",{\"1\":{\"35\":1}}],[\"值转换为\",{\"1\":{\"14\":1}}],[\"属性直接绑定一个对象\",{\"0\":{\"36\":1}}],[\"属性名\",{\"1\":{\"35\":1}}],[\"属性名称都是固定的\",{\"1\":{\"35\":1}}],[\"属性为对象时\",{\"1\":{\"3\":2}}],[\"前端面试之彻底搞懂this指向\",{\"1\":{\"85\":1}}],[\"前端\",{\"1\":{\"82\":1}}],[\"前端我们无论绑定src\",{\"1\":{\"35\":1}}],[\"前面我们绑定了元素的内容和属性\",{\"1\":{\"37\":1}}],[\"前者是存储在栈内存中\",{\"1\":{\"1\":1}}],[\"700\",{\"1\":{\"33\":2}}],[\"+=\",{\"1\":{\"70\":1}}],[\"+\",{\"1\":{\"33\":1,\"60\":1,\"61\":2,\"62\":2,\"63\":4,\"64\":4,\"70\":3}}],[\"名短横线分隔\",{\"1\":{\"32\":1}}],[\"名可以用驼峰式\",{\"1\":{\"32\":1}}],[\"名称\",{\"1\":{\"27\":1}}],[\"来将一部分独立的逻辑抽取出去\",{\"1\":{\"77\":1}}],[\"来描述组件对象\",{\"1\":{\"77\":1}}],[\"来实现数据的劫持\",{\"1\":{\"76\":1}}],[\"来劫持数据的\",{\"1\":{\"76\":1}}],[\"来进行重构\",{\"1\":{\"75\":1}}],[\"来进行类型检测\",{\"1\":{\"75\":1}}],[\"来侦听\",{\"1\":{\"69\":1}}],[\"来阻止\",{\"1\":{\"40\":1}}],[\"来命名\",{\"1\":{\"32\":1}}],[\"来绑定一些css内联样式\",{\"1\":{\"32\":1}}],[\"来展示\",{\"1\":{\"23\":1}}],[\"列表渲染\",{\"0\":{\"46\":1}}],[\"列表\",{\"1\":{\"31\":1}}],[\"呵呵呵呵\",{\"1\":{\"30\":1}}],[\"以供\",{\"1\":{\"39\":1}}],[\"以应用一个\",{\"1\":{\"31\":1}}],[\"以动态地切换\",{\"1\":{\"30\":1}}],[\"以下为不使用深度监听\",{\"1\":{\"67\":1}}],[\"以下为内部判断\",{\"1\":{\"64\":1}}],[\"以下为错误写法\",{\"1\":{\"20\":1}}],[\"以下报错\",{\"1\":{\"28\":1}}],[\"字体显示黑色\",{\"1\":{\"29\":1}}],[\"字体显示红色\",{\"1\":{\"29\":1}}],[\"字符串方法名称\",{\"1\":{\"68\":1}}],[\"字符串转换为对象\",{\"1\":{\"14\":1}}],[\"字符串\",{\"1\":{\"14\":1}}],[\"window\",{\"1\":{\"85\":4}}],[\"width\",{\"1\":{\"70\":1}}],[\"width=device\",{\"1\":{\"70\":1}}],[\"what\",{\"1\":{\"81\":1}}],[\"why\",{\"1\":{\"30\":1,\"36\":2,\"47\":1,\"48\":1,\"64\":1,\"67\":2,\"83\":4}}],[\"weixin\",{\"1\":{\"85\":1}}],[\"weight\",{\"1\":{\"70\":1}}],[\"web\",{\"0\":{\"88\":1},\"1\":{\"37\":1}}],[\"watch\",{\"0\":{\"65\":1},\"1\":{\"65\":2,\"66\":1,\"67\":5,\"68\":2,\"69\":1}}],[\"www\",{\"1\":{\"28\":1}}],[\"world\",{\"1\":{\"20\":1,\"31\":1,\"33\":1,\"34\":1,\"38\":1,\"39\":1,\"40\":1,\"59\":1,\"61\":1,\"62\":1,\"66\":1,\"83\":2}}],[\"ua\",{\"1\":{\"70\":1}}],[\"utf\",{\"1\":{\"70\":1}}],[\"unpkg\",{\"1\":{\"79\":1}}],[\"unix编程艺术\",{\"1\":{\"70\":1}}],[\"unwatch\",{\"1\":{\"69\":2}}],[\"unshift\",{\"1\":{\"49\":1}}],[\"underline\",{\"1\":{\"34\":1}}],[\"undefined\",{\"1\":{\"1\":1,\"2\":1,\"67\":1}}],[\"ul>\",{\"1\":{\"47\":3,\"48\":1,\"49\":1,\"53\":1}}],[\"us\",{\"1\":{\"37\":1}}],[\"u\",{\"1\":{\"28\":1}}],[\"global\",{\"1\":{\"86\":2}}],[\"g\",{\"1\":{\"86\":1}}],[\"githubusercontent\",{\"1\":{\"28\":1}}],[\"getresult\",{\"1\":{\"61\":2,\"63\":4}}],[\"getreversemessage\",{\"1\":{\"20\":2,\"61\":2}}],[\"getfullname\",{\"1\":{\"61\":2,\"63\":7}}],[\"getfinalstyleobj\",{\"1\":{\"33\":2}}],[\"get\",{\"1\":{\"59\":1,\"64\":1}}],[\"getter方法\",{\"1\":{\"64\":1}}],[\"getter\",{\"0\":{\"64\":1},\"1\":{\"58\":1,\"76\":1}}],[\"getclassobj\",{\"1\":{\"30\":2}}],[\"generator\",{\"1\":{\"18\":1}}],[\"是目前非常流行的架构模式\",{\"1\":{\"82\":1}}],[\"是在前期被使用非常框架的架构模式\",{\"1\":{\"82\":1}}],[\"是无法劫持和监听的\",{\"1\":{\"76\":1}}],[\"是使用\",{\"1\":{\"76\":1}}],[\"是一套用于构建用户界面的渐进式框架\",{\"1\":{\"74\":1}}],[\"是一个事件修饰符\",{\"1\":{\"40\":1}}],[\"是一个表达式\",{\"1\":{\"20\":1}}],[\"是什么作用\",{\"0\":{\"50\":1}}],[\"是过滤的意思\",{\"1\":{\"49\":1}}],[\"是允许template中有多个根元素\",{\"1\":{\"27\":2}}],[\"小知识\",{\"1\":{\"27\":1}}],[\"动态绑定属性\",{\"0\":{\"35\":1},\"1\":{\"35\":1}}],[\"动态地绑定一个或多个\",{\"1\":{\"27\":1}}],[\"动态的绑定一个或多个\",{\"1\":{\"27\":1}}],[\"绑定了\",{\"1\":{\"85\":1}}],[\"绑定事件监听\",{\"1\":{\"37\":1}}],[\"绑定一个对象\",{\"1\":{\"38\":1}}],[\"绑定一个表达式\",{\"1\":{\"38\":1}}],[\"绑定一个\",{\"1\":{\"36\":1}}],[\"绑定一个data中的属性值\",{\"1\":{\"33\":1}}],[\"绑定到元素上的所有属性\",{\"1\":{\"36\":1}}],[\"绑定class\",{\"1\":{\"31\":1}}],[\"绑定class有两种方式\",{\"1\":{\"29\":1,\"32\":1}}],[\"绑定\",{\"0\":{\"29\":1,\"32\":1}}],[\"绑定值对的对象\",{\"1\":{\"27\":1}}],[\"绑定时\",{\"1\":{\"27\":1}}],[\"所有\",{\"1\":{\"58\":1}}],[\"所有后续所有的内容都要一次进行改动\",{\"1\":{\"54\":1}}],[\"所绑定的\",{\"1\":{\"27\":1}}],[\"所以就是window\",{\"1\":{\"85\":1}}],[\"所以就会break跳出循环\",{\"1\":{\"54\":1}}],[\"所以在\",{\"1\":{\"76\":1}}],[\"所以这些属性在第一次调用时就是可用的\",{\"1\":{\"67\":1}}],[\"所以我们修改\",{\"1\":{\"84\":1}}],[\"所以我们在\",{\"1\":{\"84\":1}}],[\"所以我们会将计算属性直接写成一个函数\",{\"1\":{\"64\":1}}],[\"所以我们可以发现\",{\"1\":{\"55\":1}}],[\"所以我们一般会借助于一个在线工具来完成\",{\"1\":{\"18\":1}}],[\"所以\",{\"1\":{\"54\":1}}],[\"所以目前我们先理解html元素创建出来的vnode\",{\"1\":{\"51\":1}}],[\"所以它们也将会触发视图更新\",{\"1\":{\"49\":1}}],[\"所以必须将其添加到一个元素上\",{\"1\":{\"43\":1}}],[\"所以对应的代码都是编写的类似于js的一种语法\",{\"1\":{\"19\":1}}],[\"特别是在和自定义元素打交道时\",{\"1\":{\"27\":1}}],[\"有无key的结论\",{\"0\":{\"55\":1},\"1\":{\"55\":1}}],[\"有key的操作过程\",{\"1\":{\"54\":1}}],[\"有key的时候\",{\"1\":{\"50\":1}}],[\"有key\",{\"1\":{\"54\":1}}],[\"有点类似于小程序中的block\",{\"1\":{\"43\":1}}],[\"有时候我们的元素\",{\"1\":{\"29\":1}}],[\"有时这是必要的\",{\"1\":{\"27\":1}}],[\"有些代码片段是需要经常写的\",{\"1\":{\"18\":1}}],[\"设置id\",{\"1\":{\"83\":1}}],[\"设置\",{\"1\":{\"27\":1}}],[\"赋值\",{\"1\":{\"27\":1}}],[\"则\",{\"1\":{\"27\":1}}],[\"则还会在堆内存中开辟另一块空间存储引用类型的真实数据\",{\"1\":{\"3\":1}}],[\"默认是浅层的\",{\"1\":{\"67\":1}}],[\"默认传入event对象\",{\"1\":{\"39\":1}}],[\"默认的class和动态的class结合\",{\"1\":{\"30\":1}}],[\"默认会利用\",{\"1\":{\"27\":1}}],[\"默认情况下我们的侦听器只会针对监听的数据本身的改变\",{\"1\":{\"67\":1}}],[\"默认情况下\",{\"1\":{\"23\":1}}],[\"详见下方的指南链接\",{\"1\":{\"27\":1}}],[\"详细信息\",{\"1\":{\"26\":1}}],[\"强制绑定为\",{\"1\":{\"27\":2}}],[\"转变为驼峰式命名\",{\"1\":{\"27\":1}}],[\"将代码复制到其中\",{\"1\":{\"80\":1}}],[\"将\",{\"1\":{\"67\":1}}],[\"将被侦听的数组的变更方法进行了包裹\",{\"1\":{\"49\":1}}],[\"将返回的对象放到一个methods\",{\"1\":{\"30\":1}}],[\"将对象放到一个单独的属性中\",{\"1\":{\"30\":1}}],[\"将短横线命名的\",{\"1\":{\"27\":1}}],[\"将不可见\",{\"1\":{\"26\":1}}],[\"参数传递\",{\"0\":{\"39\":1}}],[\"参数\",{\"1\":{\"27\":1,\"37\":1}}],[\"|\",{\"1\":{\"27\":1,\"37\":2,\"59\":1,\"65\":3}}],[\"带参数\",{\"1\":{\"27\":1}}],[\"期望\",{\"1\":{\"27\":1}}],[\"修饰符相当于对事件进行了一些特殊的处理\",{\"1\":{\"40\":1}}],[\"修饰符来强制绑定方式\",{\"1\":{\"27\":1}}],[\"修饰符\",{\"1\":{\"27\":2,\"37\":1}}],[\"修改一个对象的属性\",{\"1\":{\"11\":1}}],[\"修改其中一个变量的值\",{\"1\":{\"2\":1}}],[\"或短横线分隔\",{\"1\":{\"32\":1}}],[\"或一个组件\",{\"1\":{\"27\":1}}],[\"或\",{\"1\":{\"27\":1,\"65\":1,\"76\":1}}],[\"或者自己深拷贝一份作为保存\",{\"1\":{\"67\":1}}],[\"或者需要将多个数据结合起来进行显示\",{\"1\":{\"58\":1}}],[\"或者\",{\"1\":{\"27\":1}}],[\"或多个变量\",{\"1\":{\"7\":1}}],[\"或多个元素\",{\"1\":{\"7\":1}}],[\"缩写\",{\"1\":{\"27\":1,\"37\":1}}],[\"它们将会被逐一调用\",{\"1\":{\"68\":1}}],[\"它们最终在vue中表示出来的都是一个个vnode\",{\"1\":{\"51\":1}}],[\"它会在自己的上层作用于中来查找this\",{\"1\":{\"85\":1}}],[\"它会基于key的变化重新排列元素顺序\",{\"1\":{\"50\":1}}],[\"它会先执行该元素上的事件处理函数\",{\"1\":{\"40\":1}}],[\"它的dom实际都是有渲染的\",{\"1\":{\"45\":1}}],[\"它可以在组件编译完毕前隐藏原始模板\",{\"1\":{\"26\":1}}],[\"它将返回目标对象\",{\"1\":{\"8\":1}}],[\"规则\",{\"1\":{\"26\":1}}],[\"这里涉及到箭头函数使用this的查找规则\",{\"1\":{\"85\":1}}],[\"这里其实涉及到两种不同的编程范式命令式编程和声明式编程\",{\"1\":{\"81\":1}}],[\"这样做的目的是多个包本身相互独立\",{\"1\":{\"75\":1}}],[\"这样的\",{\"1\":{\"26\":1}}],[\"这是因为计算属性会基于它们的依赖关系进行缓存\",{\"1\":{\"63\":1}}],[\"这种方式一致存在一个缺陷就是当给对象添加或者删除属性时\",{\"1\":{\"76\":1}}],[\"这种做法有一个直观的弊端\",{\"1\":{\"58\":1}}],[\"这种绑定的方式\",{\"1\":{\"35\":1}}],[\"这次更新对于ul和button是不需要进行更新\",{\"1\":{\"53\":1}}],[\"这次因为某些样式我们需要根据数据动态来决定\",{\"1\":{\"32\":1}}],[\"这些方法可以被绑定到\",{\"1\":{\"85\":1}}],[\"这些都是模板特有的语法\",{\"1\":{\"83\":1}}],[\"这些标签会替换掉我们挂载到的元素\",{\"1\":{\"83\":1}}],[\"这些被包裹过的方法包括\",{\"1\":{\"49\":1}}],[\"这些内容只有在条件为true时\",{\"1\":{\"42\":1}}],[\"这三个指令与javascript的条件语句if\",{\"1\":{\"42\":1}}],[\"这个数据通过插值语法等方式绑定到template中\",{\"1\":{\"65\":1}}],[\"这个数据有着原始数据属性值的一份精确拷贝\",{\"1\":{\"5\":1}}],[\"这个后面讲setter和getter时会讲到\",{\"1\":{\"62\":1}}],[\"这个案例是当我点击按钮时会在中间插入一个f\",{\"1\":{\"53\":1}}],[\"这个key属性有什么作用呢\",{\"1\":{\"50\":1}}],[\"这个别名可以自定来定义\",{\"1\":{\"47\":1}}],[\"这个时候无论后面数据是否有变化\",{\"1\":{\"67\":1}}],[\"这个时候就需要用侦听器watch来完成了\",{\"1\":{\"65\":1}}],[\"这个时候我们也可以给计算属性设置一个setter的方法\",{\"1\":{\"64\":1}}],[\"这个时候我们可以使用v\",{\"1\":{\"46\":1}}],[\"这个时候我们就需要进行条件判断了\",{\"1\":{\"41\":1}}],[\"这个时候\",{\"1\":{\"37\":1,\"43\":1}}],[\"这个行为在大多数情况都符合期望的绑定值类型\",{\"1\":{\"27\":1}}],[\"直到编译完成前\",{\"1\":{\"26\":1}}],[\"直到相关组件实例被挂载后才移除\",{\"1\":{\"26\":1}}],[\"直到挂载的组件将它们替换为实际渲染的内容\",{\"1\":{\"26\":1}}],[\"直接通过vue\",{\"1\":{\"78\":1}}],[\"直接\",{\"1\":{\"18\":1}}],[\"直接调用\",{\"1\":{\"16\":1}}],[\"直接赋值\",{\"1\":{\"12\":1}}],[\"用法如下\",{\"1\":{\"65\":1}}],[\"用法\",{\"1\":{\"27\":1,\"37\":1}}],[\"用途\",{\"1\":{\"27\":1}}],[\"用户可能先看到的是还没编译完成的双大括号标签\",{\"1\":{\"26\":1}}],[\"用于声明在数据更改时调用的侦听回调\",{\"1\":{\"65\":1}}],[\"用于阻止事件冒泡\",{\"1\":{\"40\":1}}],[\"用于隐藏尚未完成编译的\",{\"1\":{\"26\":1}}],[\"用于更新元素的\",{\"1\":{\"24\":1}}],[\"用于解构赋值\",{\"1\":{\"7\":1}}],[\"用于数组字面量\",{\"1\":{\"7\":1}}],[\"用于函数调用\",{\"1\":{\"7\":1}}],[\"未编译模板闪现\",{\"1\":{\"26\":1}}],[\"可扩展性更强\",{\"1\":{\"75\":1}}],[\"可维护性\",{\"1\":{\"75\":1}}],[\"可以从对象中获取到数据\",{\"1\":{\"84\":1}}],[\"可以直接打开cdn的链接\",{\"1\":{\"80\":1}}],[\"可以有自己的功能逻辑\",{\"1\":{\"75\":1}}],[\"可以在组件上使用以实现双向绑定\",{\"1\":{\"71\":1}}],[\"可以在方法中获取\",{\"1\":{\"39\":1}}],[\"可以利用\",{\"1\":{\"67\":1}}],[\"可以\",{\"1\":{\"58\":1}}],[\"可以非常方便的实现\",{\"1\":{\"58\":1}}],[\"可以用于描述某一个标签\",{\"1\":{\"51\":1}}],[\"可以用于遍历一组数据\",{\"1\":{\"46\":1}}],[\"可以用于绑定一个包含了多个\",{\"1\":{\"27\":1}}],[\"可以使用格式\",{\"1\":{\"47\":1}}],[\"可以使用\",{\"1\":{\"40\":1}}],[\"可以使用computed\",{\"1\":{\"20\":1}}],[\"可以阻止事件继续冒泡到父元素\",{\"1\":{\"40\":1}}],[\"可以通过\",{\"1\":{\"39\":1}}],[\"可以不添加\",{\"1\":{\"39\":1}}],[\"可以嵌套对象语法\",{\"1\":{\"31\":1}}],[\"可选的\",{\"1\":{\"27\":1}}],[\"可能会出现一种叫做\",{\"1\":{\"26\":1}}],[\"加快编译的速度\",{\"1\":{\"25\":1}}],[\"显示原始的mustache标签\",{\"1\":{\"25\":1}}],[\"等价于\",{\"1\":{\"24\":1}}],[\"等存储在栈内存中\",{\"1\":{\"1\":1}}],[\"那么这个this就会是window了\",{\"1\":{\"85\":1}}],[\"那么这个this是必须有值的\",{\"1\":{\"85\":1}}],[\"那么我们这个this能不能是window呢\",{\"1\":{\"85\":1}}],[\"那么会有大量重复的代码\",{\"1\":{\"58\":1}}],[\"那么会默认将原生事件event参数传递进去\",{\"1\":{\"39\":1}}],[\"那么就移除旧节点\",{\"1\":{\"54\":1}}],[\"那么就新增节点\",{\"1\":{\"54\":1}}],[\"那么就使用\",{\"1\":{\"54\":1}}],[\"那么久使用\",{\"1\":{\"54\":1}}],[\"那么vue中对于列表的更新究竟是如何操作的呢\",{\"1\":{\"53\":1}}],[\"那么vue并不会对其进行特殊的解析\",{\"1\":{\"23\":1}}],[\"那么它们应该会形成一个\",{\"1\":{\"52\":1}}],[\"那么使用v\",{\"1\":{\"45\":2}}],[\"那么方法后的\",{\"1\":{\"39\":1}}],[\"那么可以使用\",{\"1\":{\"23\":1}}],[\"也会发生改变\",{\"1\":{\"84\":1}}],[\"也增加了\",{\"1\":{\"76\":1}}],[\"也需要多次计算\",{\"1\":{\"61\":1}}],[\"也就是虚拟节点\",{\"1\":{\"51\":1}}],[\"也是根据一个条件决定是否显示元素或者组件\",{\"1\":{\"44\":1}}],[\"也只能渲染一次\",{\"1\":{\"22\":1}}],[\"也可以传入一个对象\",{\"1\":{\"84\":1}}],[\"也可以有多个键值对\",{\"1\":{\"30\":1}}],[\"也可以是其他方式\",{\"1\":{\"47\":1}}],[\"也可以是组件的\",{\"1\":{\"27\":1}}],[\"也可以是一个javascript的表达式\",{\"1\":{\"20\":1}}],[\"也可以调用函数\",{\"1\":{\"20\":1}}],[\"错误用法\",{\"1\":{\"20\":1}}],[\"哈哈哈\",{\"1\":{\"20\":2}}],[\"计算属性在大多数情况下\",{\"1\":{\"64\":1}}],[\"计算属性的\",{\"0\":{\"64\":1}}],[\"计算属性的用法\",{\"1\":{\"59\":1}}],[\"计算属性依然会重新进行计算\",{\"1\":{\"63\":1}}],[\"计算属性是不需要重新计算的\",{\"1\":{\"63\":1}}],[\"计算属性是有缓存的\",{\"1\":{\"63\":1}}],[\"计算属性会随着依赖的数据\",{\"1\":{\"63\":1}}],[\"计算属性中的运算只会执行一次\",{\"1\":{\"63\":1}}],[\"计算属性和methods的差异\",{\"1\":{\"63\":1}}],[\"计算属性看起来像是一个函数\",{\"1\":{\"62\":1}}],[\"计算属性将被混入到组件实例中\",{\"1\":{\"58\":1}}],[\"计算属性\",{\"0\":{\"63\":1},\"1\":{\"20\":1,\"67\":1}}],[\"mp\",{\"1\":{\"85\":1}}],[\"mvvm是\",{\"1\":{\"82\":1}}],[\"mvvm模型\",{\"0\":{\"82\":1}}],[\"mvc是\",{\"1\":{\"82\":1}}],[\"mvc和mvvm都是一种软件的体系结构\",{\"1\":{\"82\":1}}],[\"mixins也是由一大堆的options组成的\",{\"1\":{\"77\":1}}],[\"middle\",{\"1\":{\"37\":1,\"40\":1}}],[\"map\",{\"1\":{\"70\":1,\"86\":1}}],[\"margin\",{\"1\":{\"70\":1}}],[\"mono\",{\"1\":{\"75\":1}}],[\"model\",{\"0\":{\"71\":1},\"1\":{\"71\":1,\"82\":2}}],[\"model=\",{\"1\":{\"42\":1,\"49\":1,\"63\":1,\"66\":1}}],[\"movies\",{\"1\":{\"47\":2,\"49\":5}}],[\"movie\",{\"1\":{\"47\":2,\"49\":2}}],[\"mousemove\",{\"1\":{\"38\":6}}],[\"mousemove=\",{\"1\":{\"38\":1}}],[\"mount\",{\"1\":{\"20\":1,\"22\":1,\"23\":1,\"28\":1,\"30\":1,\"31\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"40\":1,\"42\":1,\"43\":1,\"47\":1,\"48\":1,\"49\":1,\"53\":1,\"61\":1,\"62\":1,\"63\":2,\"64\":1,\"66\":1,\"67\":1,\"70\":1,\"83\":2}}],[\"mozilla\",{\"1\":{\"37\":1}}],[\"msg\",{\"1\":{\"23\":3}}],[\"methods属性是一个对象\",{\"1\":{\"85\":1}}],[\"methods属性\",{\"0\":{\"85\":1}}],[\"methods的getfullname中的计算\",{\"1\":{\"63\":1}}],[\"methods中方法\",{\"1\":{\"38\":1}}],[\"methods\",{\"0\":{\"63\":1},\"1\":{\"20\":1,\"22\":1,\"30\":1,\"33\":1,\"38\":1,\"39\":1,\"40\":1,\"49\":1,\"53\":1,\"61\":1,\"63\":2,\"64\":1,\"66\":1,\"67\":2,\"68\":1,\"70\":1,\"77\":1,\"83\":2}}],[\"message\",{\"1\":{\"20\":5,\"22\":3,\"24\":2,\"25\":2,\"26\":1,\"31\":1,\"33\":1,\"34\":1,\"38\":1,\"39\":1,\"40\":1,\"60\":1,\"61\":2,\"62\":2,\"83\":4}}],[\"my\",{\"1\":{\"20\":2,\"22\":2,\"23\":2,\"25\":1,\"27\":1,\"28\":2,\"30\":2,\"31\":2,\"33\":2,\"34\":2,\"35\":2,\"36\":2,\"38\":2,\"39\":2,\"40\":2,\"42\":2,\"43\":2,\"44\":1,\"45\":1,\"47\":2,\"48\":2,\"49\":2,\"53\":2,\"60\":1,\"61\":2,\"62\":2,\"63\":4,\"64\":2,\"66\":2,\"67\":2,\"70\":2}}],[\"mustache的基本使用\",{\"1\":{\"20\":1}}],[\"mustache的使用\",{\"1\":{\"20\":1}}],[\"mustache中不仅仅可以是data中的属性\",{\"1\":{\"20\":1}}],[\"mustache\",{\"0\":{\"20\":1},\"1\":{\"20\":1}}],[\"函数\",{\"1\":{\"20\":1}}],[\"对于任何包含响应式数据的复杂逻辑\",{\"1\":{\"58\":1}}],[\"对于相同父元素的子元素节点并不会重新渲染整个列\",{\"1\":{\"53\":1}}],[\"对象\",{\"1\":{\"36\":1}}],[\"对象语法\",{\"0\":{\"30\":1,\"33\":1},\"1\":{\"29\":1,\"30\":2,\"32\":1}}],[\"对象属性为基础数据类型\",{\"1\":{\"12\":1}}],[\"对应的内容也会发生更新\",{\"1\":{\"20\":1}}],[\"当\",{\"1\":{\"63\":1,\"67\":1}}],[\"当我们多次使用计算属性时\",{\"1\":{\"63\":1}}],[\"当有多次一样的逻辑时\",{\"1\":{\"60\":1}}],[\"当score小于60的时候\",{\"1\":{\"59\":1}}],[\"当score大于60的时候\",{\"1\":{\"59\":1}}],[\"当条件为true时\",{\"1\":{\"43\":1}}],[\"当条件为false时\",{\"1\":{\"43\":1}}],[\"当一个元素上的事件被触发时\",{\"1\":{\"40\":1}}],[\"当通过methods中定义方法\",{\"1\":{\"39\":1}}],[\"当数据变化时\",{\"1\":{\"65\":1}}],[\"当数据另一个状态时\",{\"1\":{\"29\":1}}],[\"当数据为某个状态时\",{\"1\":{\"29\":1}}],[\"当数据发生变化时\",{\"1\":{\"22\":1}}],[\"当不带参数使用时\",{\"1\":{\"27\":1}}],[\"当用于组件\",{\"1\":{\"27\":1}}],[\"当用于绑定\",{\"1\":{\"27\":1}}],[\"当使用\",{\"1\":{\"27\":1}}],[\"当使用直接在\",{\"1\":{\"26\":1}}],[\"当然\",{\"1\":{\"20\":1}}],[\"当data中的数据发生改变时\",{\"1\":{\"20\":1}}],[\"当修改其中一个变量的值时\",{\"1\":{\"3\":2}}],[\"并且通过\",{\"1\":{\"85\":1}}],[\"并且应该可以通过this获取到data返回对象中的数据\",{\"1\":{\"85\":1}}],[\"并且该函数需要返回一个对象\",{\"1\":{\"84\":1}}],[\"并且标记它的类型为\",{\"1\":{\"83\":1}}],[\"并且ide很有可能没有任何提示\",{\"1\":{\"83\":1}}],[\"并且使用它\",{\"1\":{\"78\":1}}],[\"并且自己手动引入\",{\"1\":{\"78\":1}}],[\"并且它们还可以做到是响应式的\",{\"1\":{\"77\":1}}],[\"并且多个mixins会存在命名冲突的问题\",{\"1\":{\"77\":1}}],[\"并且\",{\"1\":{\"75\":1}}],[\"并且计算属性是有缓存的\",{\"1\":{\"62\":1}}],[\"并且如果多个地方都使用到\",{\"1\":{\"58\":1}}],[\"并且最后进行新增\",{\"1\":{\"54\":1}}],[\"并且会移除\",{\"1\":{\"50\":1}}],[\"并且支持有一二三个参数\",{\"1\":{\"47\":1}}],[\"并且需要对其进行渲染\",{\"1\":{\"46\":1}}],[\"并且在v\",{\"1\":{\"43\":1}}],[\"并且是一个对象\",{\"1\":{\"33\":1}}],[\"并且我们前端提到过\",{\"1\":{\"20\":1}}],[\"并将被拷贝对象的栈内存数据完全拷贝到该块空间中\",{\"1\":{\"3\":1}}],[\"双大括号\",{\"1\":{\"20\":1}}],[\"双大括号语法\",{\"0\":{\"20\":1}}],[\"使用任意标签\",{\"1\":{\"83\":1}}],[\"使用proxy进行数据劫持\",{\"1\":{\"76\":1}}],[\"使用全局的方法\",{\"1\":{\"70\":1}}],[\"使用计算属性\",{\"1\":{\"70\":1}}],[\"使用计算属性computed\",{\"1\":{\"59\":1}}],[\"使用computed\",{\"1\":{\"63\":1}}],[\"使用methods\",{\"1\":{\"63\":1}}],[\"使用method对逻辑进行抽取\",{\"0\":{\"61\":1},\"1\":{\"59\":1}}],[\"使用\",{\"1\":{\"40\":1,\"69\":1,\"76\":1,\"83\":1}}],[\"使用v\",{\"1\":{\"37\":1}}],[\"使用最多的语法是\",{\"1\":{\"20\":1}}],[\"使用基于html的模板语法\",{\"1\":{\"19\":1}}],[\"中更改如下\",{\"1\":{\"67\":1}}],[\"中间还有很多未知的或者乱序的节点\",{\"1\":{\"54\":1}}],[\"中的\",{\"0\":{\"50\":1}}],[\"中的深拷贝实现\",{\"0\":{\"16\":1}}],[\"中的深浅拷贝\",{\"0\":{\"4\":1}}],[\"中书写的模板时\",{\"1\":{\"26\":1}}],[\"中\",{\"1\":{\"20\":1,\"40\":1,\"69\":1,\"75\":1}}],[\"语法糖\",{\"1\":{\"38\":1}}],[\"语法\",{\"0\":{\"20\":1},\"1\":{\"20\":1}}],[\"语文\",{\"1\":{\"7\":1}}],[\"<=\",{\"1\":{\"70\":1}}],[\"<td>\",{\"1\":{\"70\":6}}],[\"<tr\",{\"1\":{\"70\":1}}],[\"<tbody>\",{\"1\":{\"70\":1}}],[\"<th>操作<\",{\"1\":{\"70\":1}}],[\"<th>购买数量<\",{\"1\":{\"70\":1}}],[\"<th>价格<\",{\"1\":{\"70\":1}}],[\"<th>出版日期<\",{\"1\":{\"70\":1}}],[\"<th>书籍名称<\",{\"1\":{\"70\":1}}],[\"<th>序号<\",{\"1\":{\"70\":1}}],[\"<thead>\",{\"1\":{\"70\":1}}],[\"<table>\",{\"1\":{\"70\":1}}],[\"<title>document<\",{\"1\":{\"70\":1}}],[\"<template\",{\"1\":{\"20\":1,\"22\":1,\"23\":1,\"25\":1,\"27\":1,\"28\":1,\"30\":1,\"31\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"40\":1,\"42\":1,\"43\":3,\"44\":1,\"45\":1,\"47\":1,\"48\":2,\"49\":1,\"53\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":2,\"64\":1,\"66\":1,\"67\":1,\"70\":3,\"83\":1}}],[\"<template>\",{\"1\":{\"19\":1}}],[\"<meta\",{\"1\":{\"70\":3}}],[\"<head>\",{\"1\":{\"70\":1}}],[\"<html\",{\"1\":{\"70\":1}}],[\"<h2\",{\"1\":{\"22\":1,\"24\":1,\"25\":1,\"42\":3,\"44\":1,\"45\":2}}],[\"<h2>购物车为空~<\",{\"1\":{\"70\":1}}],[\"<h2>总价格\",{\"1\":{\"70\":1}}],[\"<h2>遍历数字<\",{\"1\":{\"47\":1}}],[\"<h2>个人信息<\",{\"1\":{\"47\":1}}],[\"<h2>电影列表<\",{\"1\":{\"47\":1,\"49\":1}}],[\"<h2>呵呵呵呵<\",{\"1\":{\"43\":3}}],[\"<h2>哈哈哈哈<\",{\"1\":{\"43\":3}}],[\"<h2>\",{\"1\":{\"20\":7,\"22\":5,\"24\":1,\"60\":3,\"61\":3,\"62\":3,\"63\":20,\"64\":1,\"67\":1,\"83\":4}}],[\"<p>答案是\",{\"1\":{\"66\":1}}],[\"<p>您的问题是\",{\"1\":{\"66\":1}}],[\"<link\",{\"1\":{\"70\":1}}],[\"<li>\",{\"1\":{\"48\":2}}],[\"<li\",{\"1\":{\"47\":3,\"48\":1,\"49\":1,\"53\":1}}],[\"<ul>\",{\"1\":{\"47\":3,\"48\":1,\"49\":1,\"53\":1}}],[\"<input\",{\"1\":{\"40\":1,\"42\":1,\"49\":1,\"63\":1,\"66\":1}}],[\"<img\",{\"1\":{\"27\":3,\"28\":3,\"35\":1}}],[\"<body>\",{\"1\":{\"30\":1,\"31\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"40\":1,\"43\":1,\"47\":1,\"48\":1,\"49\":1,\"53\":1,\"63\":1,\"66\":1,\"67\":1,\"70\":1,\"83\":2}}],[\"<button\",{\"1\":{\"20\":1,\"22\":3,\"30\":1,\"38\":3,\"39\":2,\"40\":2,\"43\":1,\"49\":1,\"53\":1,\"63\":1,\"64\":1,\"66\":1,\"67\":3,\"70\":3,\"83\":4}}],[\"<a\",{\"1\":{\"27\":1,\"28\":1,\"35\":1}}],[\"<style>\",{\"1\":{\"30\":1}}],[\"<span\",{\"1\":{\"23\":1,\"70\":1}}],[\"<script>\",{\"1\":{\"20\":1,\"22\":1,\"23\":1,\"28\":1,\"30\":1,\"31\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"40\":1,\"42\":1,\"43\":1,\"47\":1,\"48\":1,\"49\":1,\"53\":1,\"61\":1,\"62\":1,\"63\":2,\"64\":1,\"66\":1,\"67\":1,\"70\":1,\"83\":2}}],[\"<script\",{\"1\":{\"20\":1,\"22\":1,\"23\":1,\"30\":1,\"31\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"40\":1,\"42\":1,\"43\":1,\"47\":1,\"48\":1,\"49\":1,\"53\":1,\"61\":1,\"62\":1,\"63\":2,\"64\":1,\"66\":1,\"67\":1,\"70\":2,\"79\":1,\"80\":1,\"83\":3}}],[\"<\",{\"1\":{\"19\":2,\"20\":15,\"22\":10,\"23\":3,\"24\":2,\"25\":3,\"26\":1,\"27\":5,\"28\":5,\"30\":10,\"31\":5,\"33\":6,\"34\":3,\"35\":4,\"36\":4,\"38\":8,\"39\":5,\"40\":4,\"42\":2,\"43\":5,\"44\":1,\"45\":1,\"47\":11,\"48\":7,\"49\":5,\"53\":5,\"60\":5,\"61\":5,\"62\":5,\"63\":27,\"64\":3,\"66\":5,\"67\":5,\"70\":21,\"83\":12}}],[\"<div>\",{\"1\":{\"23\":1,\"26\":1,\"83\":2}}],[\"<div><\",{\"1\":{\"19\":1}}],[\"<div\",{\"1\":{\"19\":1,\"22\":3,\"23\":1,\"26\":1,\"30\":7,\"31\":4,\"33\":6,\"34\":2,\"35\":4,\"36\":4,\"38\":4,\"39\":1,\"40\":2,\"43\":1,\"47\":1,\"48\":1,\"49\":1,\"53\":1,\"63\":1,\"66\":1,\"67\":1,\"70\":1,\"83\":2}}],[\"口在底层的实现中\",{\"1\":{\"19\":1}}],[\"起\",{\"1\":{\"19\":1}}],[\"和\",{\"0\":{\"43\":1,\"64\":1},\"1\":{\"27\":1,\"49\":1,\"58\":1,\"59\":1,\"67\":1,\"76\":2}}],[\"和底层组件实例的数据绑定在\",{\"1\":{\"19\":1}}],[\"和函数等则是分别存储数据1的地址\",{\"1\":{\"1\":1}}],[\"允许开发者以声明式的方式将\",{\"1\":{\"19\":1}}],[\"允许一个表达式在期望多个参数\",{\"1\":{\"7\":1}}],[\"了解\",{\"1\":{\"19\":1}}],[\"即不能使用箭头函数\",{\"1\":{\"85\":1}}],[\"即当刷新页面时会立刻执行一次\",{\"1\":{\"67\":1}}],[\"即可\",{\"1\":{\"53\":1}}],[\"即可自动填充\",{\"1\":{\"18\":1}}],[\"即基本数据类型的值会被完全拷贝\",{\"1\":{\"3\":1}}],[\"第三个参数是额外的其他选项\",{\"1\":{\"69\":1}}],[\"第三步是如果旧节点遍历完毕\",{\"1\":{\"54\":1}}],[\"第三步\",{\"1\":{\"18\":1}}],[\"第二个参数是侦听的回调函数callback\",{\"1\":{\"69\":1}}],[\"第二步的操作是从尾部开始进行遍历\",{\"1\":{\"54\":1}}],[\"第二步\",{\"1\":{\"18\":1}}],[\"第一个参数是要侦听的源\",{\"1\":{\"69\":1}}],[\"第一步的操作是从头开始进行遍历\",{\"1\":{\"54\":1}}],[\"第一步\",{\"1\":{\"18\":1}}],[\"第五步是最特色的情况\",{\"1\":{\"54\":1}}],[\"第四步是如果新的节点遍历完毕\",{\"1\":{\"54\":1}}],[\"方式四\",{\"1\":{\"78\":1}}],[\"方式三\",{\"1\":{\"78\":1}}],[\"方式二\",{\"1\":{\"78\":1,\"83\":1}}],[\"方式一\",{\"1\":{\"78\":1,\"83\":1}}],[\"方便我们快速生成\",{\"1\":{\"18\":1}}],[\"方法\",{\"1\":{\"76\":1}}],[\"方法的\",{\"1\":{\"76\":1}}],[\"方法中\",{\"1\":{\"30\":1}}],[\"方法返回一个给定对象自身可枚举属性的键值对数组\",{\"1\":{\"13\":1}}],[\"方法用于将一个\",{\"1\":{\"14\":1}}],[\"方法用于将\",{\"1\":{\"14\":1}}],[\"方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象\",{\"1\":{\"8\":1}}],[\"方法用于连接两个或多个数组\",{\"1\":{\"10\":1}}],[\"方法可从已有的数组中返回选定的元素\",{\"1\":{\"9\":1}}],[\"我们在methods中要使用data返回对象中的数据\",{\"1\":{\"85\":1}}],[\"我们在前面练习vue的过程中\",{\"1\":{\"18\":1}}],[\"我们传入了一个对象\",{\"1\":{\"83\":1}}],[\"我们也经常称vue是一个mvvm的框架\",{\"1\":{\"82\":1}}],[\"我们通常通过mixins在多个组件之间共享逻辑\",{\"1\":{\"77\":1}}],[\"我们通常会给元素或者组件绑定一个key属性\",{\"1\":{\"50\":1}}],[\"我们会通过\",{\"1\":{\"77\":1}}],[\"我们会发现是完全不同的\",{\"1\":{\"81\":1}}],[\"我们会发现methods在多次使用时\",{\"1\":{\"63\":1}}],[\"我们会发现计算属性和methods的实现看起来是差别是不大的\",{\"1\":{\"63\":1}}],[\"我们会发现无论是直观上\",{\"1\":{\"62\":1}}],[\"我们会发现上面的diff算法效率并不高\",{\"1\":{\"54\":1}}],[\"我们希望在代码逻辑中监听某个数据的变化\",{\"1\":{\"65\":1}}],[\"我们事实上先显示的是一个结果\",{\"1\":{\"61\":1}}],[\"我们有一个变量message\",{\"1\":{\"59\":1}}],[\"我们有一个分数\",{\"1\":{\"59\":1}}],[\"我们有两个变量\",{\"1\":{\"59\":1}}],[\"我们有没有什么方法可以将逻辑抽离出去呢\",{\"1\":{\"58\":1}}],[\"我们来看三个案例\",{\"1\":{\"59\":1}}],[\"我们可能需要对数据进行一些转化后再显示\",{\"1\":{\"58\":1}}],[\"我们可以通过hook函数\",{\"1\":{\"77\":1}}],[\"我们可以在created的生命周期\",{\"1\":{\"69\":1}}],[\"我们可以有三种实现思路\",{\"1\":{\"59\":1}}],[\"我们可以确定的是\",{\"1\":{\"53\":1}}],[\"我们可以选择使用template\",{\"1\":{\"43\":1}}],[\"我们可以直接使用\",{\"1\":{\"36\":1}}],[\"我们可以使用this关键字来直接访问到data中返回的对象的属性\",{\"1\":{\"85\":1}}],[\"我们可以使用\",{\"1\":{\"35\":1}}],[\"我们可以利用\",{\"1\":{\"32\":1}}],[\"我们可以把一个数组传给\",{\"1\":{\"31\":1}}],[\"我们可以传给\",{\"1\":{\"30\":1}}],[\"我们只需要在中间插入一个\",{\"1\":{\"53\":1}}],[\"我们先来看一个案例\",{\"1\":{\"53\":1}}],[\"我们先来看一下官方的解释\",{\"1\":{\"50\":1}}],[\"我们先来解释一下vnode的概念\",{\"1\":{\"51\":1}}],[\"我们先梳理一下js中的数据类型\",{\"1\":{\"1\":1}}],[\"我们使用template来对多个元素进行包裹\",{\"1\":{\"48\":1}}],[\"我们知道\",{\"1\":{\"47\":1,\"58\":1}}],[\"我们往往会从服务器拿到一组数据\",{\"1\":{\"46\":1}}],[\"我们需要根据当前的条件决定某些元素或组件是否渲染\",{\"1\":{\"41\":1}}],[\"我们需要经常和用户进行各种各样的交互\",{\"1\":{\"37\":1}}],[\"我们就必须监听用户发生的事件\",{\"1\":{\"37\":1}}],[\"我们称之为\",{\"1\":{\"35\":1}}],[\"我们属性的名称可能也不是固定的\",{\"1\":{\"35\":1}}],[\"我们再vscode中我们可以生成一个代码片段\",{\"1\":{\"18\":1}}],[\"to\",{\"1\":{\"81\":2}}],[\"totalprice\",{\"1\":{\"70\":2}}],[\"toggle\",{\"1\":{\"20\":2,\"30\":2}}],[\"tbody>\",{\"1\":{\"70\":1}}],[\"td>\",{\"1\":{\"70\":6}}],[\"td\",{\"1\":{\"70\":1}}],[\"thead>\",{\"1\":{\"70\":1}}],[\"th>\",{\"1\":{\"70\":6}}],[\"th\",{\"1\":{\"70\":2}}],[\"this到底指向什么\",{\"1\":{\"85\":1}}],[\"this到底是如何查找和绑定的呢\",{\"1\":{\"85\":1}}],[\"this\",{\"1\":{\"16\":1,\"20\":3,\"22\":1,\"30\":5,\"49\":5,\"53\":1,\"58\":1,\"61\":4,\"62\":4,\"63\":7,\"64\":7,\"66\":4,\"67\":3,\"68\":1,\"69\":2,\"70\":5,\"83\":4,\"85\":2}}],[\"target\",{\"1\":{\"40\":1}}],[\"table>\",{\"1\":{\"70\":1}}],[\"table\",{\"1\":{\"70\":1}}],[\"tab\",{\"1\":{\"18\":1}}],[\"typescript\",{\"1\":{\"75\":2}}],[\"type=\",{\"1\":{\"40\":1,\"42\":1,\"49\":1,\"63\":1,\"66\":1,\"83\":1}}],[\"typeof\",{\"1\":{\"6\":1,\"12\":1,\"13\":1}}],[\"title>\",{\"1\":{\"70\":1}}],[\"title\",{\"1\":{\"30\":4,\"31\":4}}],[\"textdecoration\",{\"1\":{\"34\":1}}],[\"text=\",{\"1\":{\"24\":1}}],[\"textcontent\",{\"1\":{\"24\":1}}],[\"text\",{\"0\":{\"24\":1},\"1\":{\"40\":1,\"42\":1,\"49\":1,\"63\":1,\"66\":1,\"70\":1}}],[\"template模板中\",{\"1\":{\"85\":1}}],[\"template模板中只能有一个根元素\",{\"1\":{\"27\":1}}],[\"template中的\",{\"1\":{\"84\":1}}],[\"template中通过\",{\"1\":{\"84\":1}}],[\"template标签\",{\"1\":{\"83\":1}}],[\"template属性\",{\"0\":{\"83\":1},\"1\":{\"83\":1}}],[\"template会自动进行更新来显示最新的数据\",{\"1\":{\"65\":1}}],[\"template元素是一种用于保存客户端内容的机制\",{\"1\":{\"83\":1}}],[\"template元素使用\",{\"0\":{\"48\":1}}],[\"template元素可以当做不可见的包裹元素\",{\"1\":{\"43\":1}}],[\"template元素\",{\"1\":{\"43\":1}}],[\"template\",{\"0\":{\"43\":1},\"1\":{\"20\":2,\"22\":1,\"23\":1,\"28\":1,\"30\":1,\"31\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"40\":1,\"42\":1,\"43\":1,\"47\":1,\"48\":2,\"49\":1,\"53\":1,\"61\":1,\"62\":1,\"63\":2,\"64\":1,\"66\":1,\"67\":1,\"70\":1,\"83\":4}}],[\"template>\",{\"1\":{\"19\":1,\"20\":1,\"22\":1,\"23\":1,\"25\":1,\"27\":1,\"28\":1,\"30\":1,\"31\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"40\":1,\"42\":1,\"43\":3,\"44\":1,\"45\":1,\"47\":1,\"48\":2,\"49\":1,\"53\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":2,\"64\":1,\"66\":1,\"67\":1,\"70\":3,\"83\":1}}],[\"tr>\",{\"1\":{\"70\":1}}],[\"tree\",{\"1\":{\"52\":1,\"76\":1}}],[\"true\",{\"1\":{\"20\":1,\"30\":5,\"31\":1,\"37\":1,\"40\":1,\"43\":1,\"67\":3,\"68\":2,\"69\":2}}],[\"triggered\",{\"1\":{\"68\":3}}],[\"trigger\",{\"1\":{\"18\":1}}],[\"库的方法\",{\"1\":{\"16\":1}}],[\"提供\",{\"1\":{\"16\":1}}],[\"手写循环递归\",{\"1\":{\"15\":1}}],[\"手写递归\",{\"0\":{\"6\":1,\"12\":1}}],[\"600\",{\"1\":{\"70\":1}}],[\"60\",{\"1\":{\"42\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":2}}],[\"6\",{\"1\":{\"14\":2,\"68\":1}}],[\"yarn\",{\"1\":{\"86\":4}}],[\"y\",{\"1\":{\"14\":2}}],[\"59\",{\"1\":{\"70\":1}}],[\"5px\",{\"1\":{\"70\":1}}],[\"5c6b77\",{\"1\":{\"70\":1}}],[\"50px\",{\"1\":{\"33\":2}}],[\"50\",{\"1\":{\"33\":1}}],[\"5\",{\"1\":{\"14\":2,\"68\":1}}],[\"james\",{\"1\":{\"67\":1}}],[\"javascript\",{\"1\":{\"14\":1,\"66\":1,\"83\":1}}],[\"join\",{\"1\":{\"20\":2,\"60\":1,\"61\":1,\"62\":1}}],[\"jquery\",{\"1\":{\"15\":1}}],[\"js和vue\",{\"1\":{\"86\":1}}],[\"js或者vuejs\",{\"1\":{\"74\":1}}],[\"jsx\",{\"1\":{\"19\":1}}],[\"json中的dev后加上\",{\"1\":{\"86\":1}}],[\"json\",{\"0\":{\"14\":2},\"1\":{\"14\":8}}],[\"js中的基本数据类型\",{\"1\":{\"2\":1}}],[\"js的数据类型分为两类\",{\"1\":{\"1\":1}}],[\"js\",{\"0\":{\"0\":1,\"4\":1,\"87\":1},\"1\":{\"20\":2,\"22\":2,\"23\":2,\"30\":2,\"31\":2,\"33\":2,\"34\":2,\"35\":2,\"36\":2,\"38\":2,\"39\":2,\"40\":3,\"42\":2,\"43\":2,\"47\":2,\"48\":2,\"49\":2,\"53\":2,\"61\":2,\"62\":2,\"63\":4,\"64\":2,\"66\":2,\"67\":2,\"70\":3,\"80\":3,\"83\":4,\"86\":1}}],[\"常用\",{\"0\":{\"14\":1}}],[\">hhhh<\",{\"1\":{\"83\":1}}],[\">移除<\",{\"1\":{\"70\":1}}],[\">+<\",{\"1\":{\"70\":1}}],[\">+1<\",{\"1\":{\"22\":3,\"83\":2}}],[\">改变info\",{\"1\":{\"67\":2}}],[\">改变info<\",{\"1\":{\"67\":1}}],[\">查找答案<\",{\"1\":{\"66\":1}}],[\">修改fullname<\",{\"1\":{\"64\":1}}],[\">修改firstname<\",{\"1\":{\"63\":1}}],[\">=\",{\"1\":{\"60\":1,\"61\":1,\"62\":1,\"63\":2}}],[\">插入f元素<\",{\"1\":{\"53\":1}}],[\">添加电影<\",{\"1\":{\"49\":1}}],[\">良好<\",{\"1\":{\"42\":1}}],[\">优秀<\",{\"1\":{\"42\":1}}],[\">按钮<\",{\"1\":{\"40\":2}}],[\">按钮2<\",{\"1\":{\"39\":1}}],[\">按钮1<\",{\"1\":{\"38\":2,\"39\":1}}],[\">div<\",{\"1\":{\"38\":1}}],[\">呵呵呵呵<\",{\"1\":{\"30\":4,\"33\":2,\"45\":1}}],[\">哈哈哈哈<\",{\"1\":{\"30\":1,\"31\":3,\"33\":3,\"36\":3,\"44\":1,\"45\":1}}],[\">哈哈哈<\",{\"1\":{\"23\":1,\"34\":1,\"35\":2}}],[\">百度一下<\",{\"1\":{\"27\":1,\"28\":1}}],[\"><\",{\"1\":{\"20\":1,\"22\":2,\"23\":2,\"24\":1,\"30\":2,\"31\":2,\"33\":2,\"34\":2,\"35\":3,\"36\":2,\"38\":4,\"39\":2,\"40\":2,\"42\":1,\"43\":2,\"47\":2,\"48\":3,\"49\":2,\"53\":2,\"61\":1,\"62\":1,\"63\":3,\"64\":1,\"66\":2,\"67\":2,\"70\":3,\"79\":1,\"80\":1,\"83\":3}}],[\">切换<\",{\"1\":{\"20\":1,\"30\":1,\"43\":1}}],[\">\",{\"0\":{\"14\":1},\"1\":{\"14\":2,\"20\":7,\"22\":1,\"23\":1,\"24\":1,\"25\":2,\"27\":8,\"28\":7,\"30\":7,\"31\":3,\"33\":4,\"34\":1,\"35\":3,\"36\":2,\"38\":6,\"39\":3,\"40\":3,\"42\":4,\"43\":2,\"44\":1,\"45\":1,\"47\":6,\"48\":2,\"49\":4,\"53\":2,\"60\":2,\"61\":1,\"62\":1,\"63\":5,\"64\":1,\"66\":2,\"67\":2,\"70\":11,\"83\":4}}],[\"待拷贝对象\",{\"0\":{\"14\":1}}],[\"options\",{\"1\":{\"68\":1,\"77\":2}}],[\"or\",{\"1\":{\"67\":1}}],[\"org\",{\"1\":{\"37\":1,\"50\":1,\"58\":1,\"68\":1,\"69\":1}}],[\"old\",{\"1\":{\"68\":2}}],[\"oldval\",{\"1\":{\"68\":7}}],[\"oldvalue\",{\"1\":{\"66\":2,\"67\":3}}],[\"oldvalue变化前的旧值\",{\"1\":{\"66\":1}}],[\"oldinfo\",{\"1\":{\"67\":4,\"69\":2}}],[\"on支持修饰符\",{\"1\":{\"40\":1}}],[\"on=\",{\"1\":{\"38\":1}}],[\"on的用法\",{\"1\":{\"37\":1}}],[\"on指令\",{\"1\":{\"37\":1}}],[\"on绑定事件\",{\"1\":{\"37\":1}}],[\"on\",{\"0\":{\"37\":1,\"40\":1},\"1\":{\"38\":3}}],[\"once\",{\"1\":{\"37\":1,\"40\":1}}],[\"once用于指定元素或者组件只渲染一次\",{\"1\":{\"22\":1}}],[\"once指令\",{\"0\":{\"22\":1}}],[\"once>\",{\"1\":{\"19\":1,\"22\":3}}],[\"of\",{\"1\":{\"13\":1,\"70\":1}}],[\"obj2\",{\"1\":{\"85\":2}}],[\"obj\",{\"0\":{\"13\":1},\"1\":{\"6\":6,\"7\":3,\"8\":3,\"12\":11,\"13\":6,\"14\":3,\"16\":1,\"85\":2}}],[\"object\",{\"0\":{\"8\":1,\"13\":1},\"1\":{\"1\":1,\"6\":1,\"8\":2,\"12\":1,\"13\":4,\"14\":1,\"27\":1,\"37\":1,\"47\":3,\"65\":1,\"67\":1,\"70\":1,\"76\":1}}],[\"viewmode的简称\",{\"1\":{\"82\":1}}],[\"view\",{\"1\":{\"74\":1,\"82\":2}}],[\"viewport\",{\"1\":{\"70\":1}}],[\"vjuː\",{\"1\":{\"74\":1}}],[\"vs\",{\"0\":{\"63\":1}}],[\"vscode中的代码片段有固定的格式\",{\"1\":{\"18\":1}}],[\"vscode\",{\"0\":{\"18\":1}}],[\"vnode的本质是一个javascript的对象\",{\"1\":{\"51\":1}}],[\"vnode的全称是virtual\",{\"1\":{\"51\":1}}],[\"vnode\",{\"0\":{\"51\":1},\"1\":{\"52\":1}}],[\"val\",{\"1\":{\"68\":7}}],[\"value\",{\"1\":{\"35\":2,\"40\":1,\"47\":5,\"48\":2}}],[\"var\",{\"1\":{\"20\":2}}],[\"v=4\",{\"1\":{\"28\":1}}],[\"vue提供了两种方式\",{\"1\":{\"83\":1}}],[\"vue提供了下面的指令来进行条件判断\",{\"1\":{\"41\":1}}],[\"vue虽然并没有完全遵守mvvm的模型\",{\"1\":{\"82\":1}}],[\"vue官方其实有说明\",{\"1\":{\"82\":1}}],[\"vue的源码全部使用\",{\"1\":{\"75\":1}}],[\"vue使用\",{\"1\":{\"75\":1}}],[\"vue在进行diff算法的时候\",{\"1\":{\"55\":1}}],[\"vue源码对于key的判断\",{\"0\":{\"54\":1}}],[\"vue事实上会对于有key和没有key会调用两个不同的方法\",{\"1\":{\"53\":1}}],[\"vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改\",{\"1\":{\"50\":1}}],[\"vuejs\",{\"1\":{\"50\":1,\"58\":1,\"68\":1,\"69\":1}}],[\"vue2\",{\"1\":{\"27\":1,\"76\":3,\"77\":1}}],[\"vue将模板编译成虚拟dom渲染函数\",{\"1\":{\"19\":1}}],[\"vue也支持\",{\"1\":{\"19\":1}}],[\"vue3带来的变化\",{\"0\":{\"75\":1}}],[\"vue3不支持过滤器了\",{\"1\":{\"70\":1}}],[\"vue3\",{\"0\":{\"17\":1},\"1\":{\"27\":2,\"76\":1,\"85\":1}}],[\"vue\",{\"0\":{\"16\":1,\"56\":1,\"73\":1,\"74\":1,\"78\":1,\"91\":1},\"1\":{\"20\":2,\"22\":2,\"23\":2,\"27\":2,\"28\":1,\"30\":2,\"31\":2,\"33\":2,\"34\":2,\"35\":2,\"36\":2,\"38\":2,\"39\":2,\"40\":3,\"42\":2,\"43\":2,\"47\":2,\"48\":2,\"49\":3,\"53\":2,\"61\":2,\"62\":2,\"63\":4,\"64\":2,\"66\":2,\"67\":3,\"70\":2,\"74\":1,\"75\":1,\"76\":1,\"79\":1,\"80\":1,\"83\":4,\"86\":1}}],[\"v\",{\"0\":{\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"37\":1,\"40\":1,\"43\":1,\"44\":1,\"45\":1,\"50\":1,\"71\":1},\"1\":{\"13\":4,\"19\":2,\"22\":4,\"23\":2,\"24\":1,\"25\":2,\"26\":4,\"27\":5,\"28\":4,\"30\":1,\"32\":1,\"36\":2,\"37\":2,\"38\":4,\"40\":1,\"41\":4,\"42\":7,\"43\":4,\"44\":2,\"45\":6,\"46\":1,\"47\":7,\"48\":1,\"49\":2,\"53\":1,\"63\":1,\"66\":1,\"70\":3,\"71\":1,\"83\":1}}],[\"kobe\",{\"1\":{\"35\":2,\"61\":1,\"62\":1,\"63\":1,\"64\":1,\"67\":3}}],[\"kebab\",{\"1\":{\"32\":2}}],[\"key=\",{\"1\":{\"53\":1}}],[\"key属性主要用在vue的虚拟dom算法\",{\"1\":{\"50\":1}}],[\"keyup\",{\"1\":{\"40\":2}}],[\"keyalias\",{\"1\":{\"37\":1,\"40\":1}}],[\"key\",{\"0\":{\"50\":1},\"1\":{\"6\":4,\"27\":1,\"47\":4,\"48\":2,\"50\":1,\"59\":1,\"65\":1}}],[\"k\",{\"1\":{\"13\":2}}],[\"essential\",{\"0\":{\"89\":1}}],[\"equiv=\",{\"1\":{\"70\":1}}],[\"e9e9e9\",{\"1\":{\"70\":2}}],[\"e\",{\"1\":{\"68\":3}}],[\"examplex新建自己的文件夹以及测试demo\",{\"1\":{\"86\":1}}],[\"export\",{\"1\":{\"68\":1}}],[\"extend\",{\"1\":{\"15\":1}}],[\"enterkeyup\",{\"1\":{\"40\":2}}],[\"enter=\",{\"1\":{\"40\":1}}],[\"entries\",{\"0\":{\"13\":1},\"1\":{\"13\":3}}],[\"en\",{\"1\":{\"37\":1,\"70\":1}}],[\"events\",{\"1\":{\"37\":1}}],[\"event\",{\"1\":{\"37\":4,\"39\":5,\"40\":4}}],[\"element函数调用\",{\"1\":{\"19\":1}}],[\"else一起使用\",{\"1\":{\"45\":1}}],[\"else>\",{\"1\":{\"43\":1,\"70\":1}}],[\"else>不及格<\",{\"1\":{\"42\":1}}],[\"else\",{\"1\":{\"12\":1,\"41\":2,\"42\":5}}],[\"乒乓球\",{\"1\":{\"12\":3,\"13\":1,\"14\":1}}],[\"排球\",{\"1\":{\"12\":2,\"13\":1,\"14\":1}}],[\"zs\",{\"1\":{\"12\":2,\"13\":1,\"14\":1}}],[\"若对象属性还是引用类型\",{\"1\":{\"12\":1}}],[\"若被拷贝对象中有引用类型\",{\"1\":{\"3\":1}}],[\"x中\",{\"1\":{\"77\":1}}],[\"x的时候\",{\"1\":{\"75\":2,\"77\":1}}],[\"x\",{\"1\":{\"14\":2,\"70\":1,\"76\":3,\"77\":1,\"83\":2}}],[\"xia\",{\"1\":{\"10\":1}}],[\"xkc\",{\"1\":{\"6\":2}}],[\"p>\",{\"1\":{\"66\":2}}],[\"pop\",{\"1\":{\"49\":1}}],[\"push\",{\"1\":{\"49\":2}}],[\"padding\",{\"1\":{\"70\":1}}],[\"patchunkeyedchildren方法\",{\"1\":{\"54\":1}}],[\"patchkeyedchildren方法\",{\"1\":{\"54\":1}}],[\"passive\",{\"1\":{\"37\":2,\"40\":2}}],[\"parse\",{\"0\":{\"14\":1},\"1\":{\"14\":3}}],[\"p\",{\"1\":{\"37\":1}}],[\"px\",{\"1\":{\"33\":1}}],[\"price\",{\"1\":{\"70\":10}}],[\"proxy\",{\"1\":{\"67\":1,\"76\":1}}],[\"props\",{\"1\":{\"27\":2,\"77\":1}}],[\"property\",{\"1\":{\"27\":4,\"32\":2}}],[\"prop\",{\"1\":{\"27\":5}}],[\"preventdefault\",{\"1\":{\"37\":1,\"40\":1}}],[\"prevent\",{\"1\":{\"37\":1,\"40\":1}}],[\"pre>\",{\"1\":{\"25\":1}}],[\"pre用于跳过元素和它的子元素的编译过程\",{\"1\":{\"25\":1}}],[\"pre\",{\"0\":{\"25\":1}}],[\"pig\",{\"1\":{\"10\":2}}],[\"person1\",{\"1\":{\"6\":4}}],[\"person\",{\"1\":{\"6\":3}}],[\"d\",{\"1\":{\"53\":1,\"68\":2}}],[\"d它们都是没有变化的\",{\"1\":{\"53\":1}}],[\"debugger\",{\"1\":{\"86\":1}}],[\"dev\",{\"1\":{\"86\":1}}],[\"developer\",{\"1\":{\"37\":1}}],[\"defineproperty\",{\"1\":{\"76\":1}}],[\"default\",{\"1\":{\"68\":1}}],[\"decrement\",{\"1\":{\"70\":2,\"83\":4}}],[\"deep\",{\"1\":{\"67\":1,\"68\":1,\"69\":1}}],[\"deepclone\",{\"1\":{\"12\":3,\"13\":3}}],[\"dist文件夹下有两个文件\",{\"1\":{\"86\":1}}],[\"disabled=\",{\"1\":{\"70\":1}}],[\"display\",{\"1\":{\"26\":2}}],[\"diff\",{\"1\":{\"54\":2}}],[\"diff算法优化\",{\"1\":{\"76\":1}}],[\"diff算法\",{\"1\":{\"54\":2}}],[\"divider\",{\"1\":{\"48\":1}}],[\"divclick\",{\"1\":{\"40\":3}}],[\"div>\",{\"1\":{\"19\":2,\"22\":3,\"23\":2,\"26\":1,\"30\":7,\"31\":4,\"33\":6,\"34\":2,\"35\":4,\"36\":4,\"38\":4,\"39\":1,\"40\":2,\"43\":1,\"47\":1,\"48\":1,\"49\":1,\"53\":1,\"63\":1,\"66\":1,\"67\":1,\"70\":1,\"83\":4}}],[\"date\",{\"1\":{\"70\":5}}],[\"data中返回的对象会被vue的响应式系统劫持\",{\"1\":{\"84\":1}}],[\"data属性是传入一个函数\",{\"1\":{\"84\":1}}],[\"data属性\",{\"0\":{\"84\":1}}],[\"data\",{\"1\":{\"20\":1,\"22\":1,\"23\":1,\"28\":1,\"30\":1,\"31\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"40\":1,\"42\":1,\"43\":1,\"47\":1,\"48\":1,\"49\":1,\"53\":1,\"61\":1,\"62\":1,\"63\":2,\"64\":1,\"65\":1,\"66\":1,\"67\":2,\"68\":1,\"70\":1,\"83\":2}}],[\"data返回的对象是有添加到vue的响应式系统中\",{\"1\":{\"20\":1}}],[\"dance\",{\"1\":{\"6\":3}}],[\"doctype\",{\"1\":{\"70\":1}}],[\"docs\",{\"1\":{\"37\":1}}],[\"do\",{\"1\":{\"68\":1,\"81\":2}}],[\"dom\",{\"0\":{\"52\":1},\"1\":{\"19\":1,\"26\":2,\"27\":4,\"52\":2,\"54\":2}}],[\"dog\",{\"1\":{\"10\":1}}],[\"2scrlta\",{\"1\":{\"85\":1}}],[\"2008\",{\"1\":{\"70\":1}}],[\"2006\",{\"1\":{\"70\":3}}],[\"20231022182300781\",{\"1\":{\"54\":1}}],[\"20231022182341619\",{\"1\":{\"54\":1}}],[\"20231022182251535\",{\"1\":{\"54\":1}}],[\"20231022182241976\",{\"1\":{\"54\":1}}],[\"20231022182232738\",{\"1\":{\"54\":1}}],[\"20231022182140133\",{\"1\":{\"54\":1}}],[\"20231022182012027\",{\"1\":{\"54\":1}}],[\"20231020164733530\",{\"1\":{\"54\":1}}],[\"20231020163154944\",{\"1\":{\"52\":1}}],[\"20231020162812819\",{\"1\":{\"51\":1}}],[\"20231019222841008\",{\"1\":{\"45\":1}}],[\"20231019005251770\",{\"1\":{\"40\":1}}],[\"20231019004604619\",{\"1\":{\"39\":1}}],[\"20231018083558572\",{\"1\":{\"23\":1}}],[\"20231016233051010\",{\"1\":{\"18\":1}}],[\"2+\",{\"1\":{\"27\":2}}],[\"2\",{\"1\":{\"9\":1,\"10\":1,\"20\":2,\"27\":1,\"28\":1,\"49\":1,\"53\":1,\"63\":1,\"68\":1,\"70\":2}}],[\"4\",{\"1\":{\"9\":3,\"20\":2,\"68\":1,\"70\":1}}],[\"42\",{\"1\":{\"9\":3,\"13\":2}}],[\"39\",{\"1\":{\"70\":1}}],[\"30px\",{\"1\":{\"33\":2,\"34\":1}}],[\"3\",{\"1\":{\"9\":1,\"10\":1,\"20\":2,\"27\":2,\"68\":2,\"70\":2}}],[\"1<\",{\"1\":{\"83\":2}}],[\"128\",{\"1\":{\"70\":1}}],[\"16px\",{\"1\":{\"70\":1}}],[\"1px\",{\"1\":{\"70\":2}}],[\"18\",{\"1\":{\"10\":1,\"14\":2,\"36\":2,\"39\":1,\"47\":1,\"48\":1,\"67\":2}}],[\"1\",{\"1\":{\"9\":2,\"20\":2,\"27\":1,\"28\":1,\"36\":2,\"47\":1,\"48\":1,\"60\":1,\"63\":1,\"64\":1,\"68\":3,\"70\":8}}],[\"10335230\",{\"1\":{\"28\":1}}],[\"100\",{\"1\":{\"9\":3,\"20\":1,\"22\":1,\"38\":1,\"83\":2}}],[\"10\",{\"1\":{\"2\":1,\"9\":2,\"20\":1,\"47\":1,\"70\":1}}],[\"篮球\",{\"1\":{\"8\":2,\"12\":2,\"13\":1,\"14\":1}}],[\"跳过不需要编译的节点\",{\"1\":{\"25\":1}}],[\"跳\",{\"1\":{\"8\":2}}],[\"唱\",{\"1\":{\"8\":1}}],[\"物理\",{\"1\":{\"7\":3}}],[\"英语\",{\"1\":{\"7\":3}}],[\"数组更新检测\",{\"0\":{\"49\":1}}],[\"数组元素项item是在前面的\",{\"1\":{\"47\":1}}],[\"数组通常是来自data或者prop\",{\"1\":{\"47\":1}}],[\"数组\",{\"1\":{\"47\":2}}],[\"数组语法\",{\"0\":{\"31\":1,\"34\":1},\"1\":{\"29\":1,\"31\":2,\"32\":1}}],[\"数学\",{\"1\":{\"7\":3}}],[\"数据进行某种转化后显示\",{\"1\":{\"58\":1}}],[\"数据2的地址和数据3的地址\",{\"1\":{\"1\":1}}],[\"数据类型\",{\"0\":{\"1\":1}}],[\"的innerhtml\",{\"1\":{\"83\":1}}],[\"的过程\",{\"1\":{\"81\":1}}],[\"的时候\",{\"1\":{\"76\":2,\"77\":1}}],[\"的api\",{\"0\":{\"69\":1}}],[\"的答案是哈哈哈哈哈`\",{\"1\":{\"66\":2}}],[\"的改变\",{\"1\":{\"63\":1}}],[\"的options\",{\"0\":{\"56\":1}}],[\"的列表\",{\"1\":{\"53\":1}}],[\"的案例\",{\"0\":{\"53\":1}}],[\"的样子\",{\"1\":{\"51\":1}}],[\"的修饰符\",{\"0\":{\"40\":1}}],[\"的格式来定义\",{\"1\":{\"35\":1}}],[\"的简写\",{\"1\":{\"30\":1}}],[\"的情况\",{\"1\":{\"26\":1}}],[\"的\",{\"1\":{\"23\":1,\"53\":1,\"58\":1,\"64\":1}}],[\"的文本插值\",{\"1\":{\"20\":1}}],[\"的开发模式\",{\"1\":{\"19\":1}}],[\"的位置扩展\",{\"1\":{\"7\":1}}],[\"的浅拷贝与深拷贝\",{\"0\":{\"0\":1}}],[\"展开语法\",{\"0\":{\"7\":1},\"1\":{\"7\":1}}],[\"lang=\",{\"1\":{\"70\":1}}],[\"lastname\",{\"1\":{\"59\":1,\"60\":1,\"61\":2,\"62\":2,\"63\":3,\"64\":4}}],[\"li\",{\"1\":{\"53\":2}}],[\"li>\",{\"1\":{\"47\":3,\"48\":3,\"49\":1,\"53\":1}}],[\"link\",{\"1\":{\"27\":1,\"28\":2}}],[\"lisi\",{\"1\":{\"12\":2,\"13\":1,\"14\":1}}],[\"loadsh\",{\"1\":{\"16\":1}}],[\"lodash\",{\"1\":{\"16\":2}}],[\"log\",{\"1\":{\"6\":2,\"7\":2,\"8\":2,\"9\":2,\"10\":2,\"12\":2,\"13\":2,\"14\":2,\"38\":2,\"39\":2,\"40\":3,\"63\":4,\"64\":1,\"66\":2,\"67\":2,\"68\":7,\"69\":1,\"85\":1}}],[\"learn\",{\"0\":{\"90\":1}}],[\"length\",{\"1\":{\"49\":1,\"70\":1}}],[\"left\",{\"1\":{\"37\":1,\"40\":1,\"70\":1}}],[\"lessons\",{\"1\":{\"7\":4}}],[\"letters\",{\"1\":{\"53\":3}}],[\"let\",{\"1\":{\"2\":1,\"6\":2,\"7\":2,\"8\":2,\"9\":2,\"10\":2,\"12\":2,\"13\":1,\"70\":2}}],[\"0\",{\"1\":{\"6\":1,\"7\":1,\"8\":1,\"9\":2,\"12\":1,\"13\":1,\"14\":1,\"53\":1,\"64\":1,\"70\":9,\"85\":1}}],[\"right\",{\"1\":{\"37\":1,\"40\":1}}],[\"repository\",{\"1\":{\"75\":1}}],[\"repository仓库\",{\"1\":{\"75\":1}}],[\"repo\",{\"1\":{\"75\":1}}],[\"removebook\",{\"1\":{\"70\":2}}],[\"rel=\",{\"1\":{\"70\":1}}],[\"result\",{\"1\":{\"62\":2,\"63\":4}}],[\"red\",{\"1\":{\"23\":1,\"30\":1,\"33\":3,\"34\":1}}],[\"reversemessage\",{\"1\":{\"62\":2}}],[\"reverse\",{\"1\":{\"20\":2,\"49\":1,\"60\":1,\"61\":1,\"62\":1}}],[\"reactivity\",{\"1\":{\"58\":1}}],[\"react\",{\"1\":{\"19\":1}}],[\"react使用的jsx\",{\"1\":{\"19\":1}}],[\"react的开发模式\",{\"1\":{\"19\":1}}],[\"return\",{\"1\":{\"6\":2,\"12\":1,\"13\":1,\"19\":1,\"20\":3,\"22\":1,\"23\":1,\"28\":1,\"30\":2,\"31\":1,\"33\":2,\"34\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"40\":1,\"42\":1,\"43\":1,\"47\":1,\"48\":1,\"49\":1,\"53\":1,\"61\":4,\"62\":4,\"63\":6,\"64\":3,\"66\":1,\"67\":1,\"68\":1,\"70\":5,\"83\":2}}],[\"rap\",{\"1\":{\"6\":3,\"8\":2}}],[\"hym0jgbi25grng\",{\"1\":{\"85\":1}}],[\"how\",{\"1\":{\"81\":2}}],[\"hooks函数增加代码的复用性\",{\"1\":{\"77\":1}}],[\"hobbies\",{\"1\":{\"8\":3}}],[\"hobby\",{\"1\":{\"6\":4,\"12\":4,\"13\":2,\"14\":2}}],[\"hack\",{\"1\":{\"76\":1}}],[\"handle\",{\"1\":{\"68\":1}}],[\"handle3\",{\"1\":{\"68\":2}}],[\"handle2\",{\"1\":{\"68\":2}}],[\"handle1\",{\"1\":{\"68\":2}}],[\"handler\",{\"1\":{\"67\":1,\"68\":3}}],[\"hasownproperty\",{\"1\":{\"6\":1,\"12\":1}}],[\"head>\",{\"1\":{\"70\":1}}],[\"height\",{\"1\":{\"36\":1,\"47\":1,\"48\":1}}],[\"height=\",{\"1\":{\"36\":1}}],[\"hello\",{\"1\":{\"20\":1,\"31\":1,\"33\":1,\"34\":1,\"38\":1,\"39\":1,\"40\":1,\"61\":1,\"62\":1,\"66\":1,\"83\":2}}],[\"href\",{\"1\":{\"35\":1}}],[\"href=\",{\"1\":{\"27\":1,\"28\":1,\"35\":1,\"70\":1}}],[\"http\",{\"1\":{\"70\":1}}],[\"https\",{\"1\":{\"18\":1,\"28\":2,\"37\":1,\"50\":1,\"58\":1,\"68\":1,\"69\":1,\"79\":1,\"85\":1}}],[\"html>\",{\"1\":{\"70\":2}}],[\"html=\",{\"1\":{\"23\":1}}],[\"html\",{\"0\":{\"23\":1},\"1\":{\"23\":2,\"50\":1,\"58\":1,\"68\":1,\"69\":1}}],[\"h2>\",{\"1\":{\"20\":7,\"22\":6,\"24\":2,\"25\":1,\"42\":3,\"43\":6,\"44\":1,\"45\":2,\"47\":3,\"49\":1,\"60\":3,\"61\":3,\"62\":3,\"63\":20,\"64\":1,\"67\":1,\"70\":2,\"83\":4}}],[\"hdx\",{\"1\":{\"7\":2}}],[\"hd1\",{\"1\":{\"7\":4}}],[\"cdn\",{\"0\":{\"79\":1}}],[\"charset=\",{\"1\":{\"70\":1}}],[\"changed\",{\"1\":{\"68\":3}}],[\"changeinfonbaname\",{\"1\":{\"67\":2}}],[\"changeinfoname\",{\"1\":{\"67\":2}}],[\"changeinfo\",{\"1\":{\"67\":2}}],[\"changefullname\",{\"1\":{\"64\":2}}],[\"changefirstname\",{\"1\":{\"63\":2}}],[\"c和f因为key不一致\",{\"1\":{\"54\":1}}],[\"c和d来说它们事实上并不需要有任何的改动\",{\"1\":{\"54\":1}}],[\"c\",{\"1\":{\"53\":2,\"68\":4}}],[\"cn\",{\"1\":{\"50\":1,\"58\":1,\"68\":1,\"69\":1}}],[\"cba=\",{\"1\":{\"35\":1}}],[\"cba\",{\"1\":{\"30\":3,\"31\":2,\"35\":1}}],[\"capture\",{\"1\":{\"37\":2,\"40\":2}}],[\"case\",{\"1\":{\"32\":2}}],[\"camelcase\",{\"1\":{\"32\":1}}],[\"camel\",{\"1\":{\"27\":1}}],[\"cat\",{\"1\":{\"10\":1}}],[\"csspropertyvalue\",{\"1\":{\"33\":1}}],[\"csspropertyname\",{\"1\":{\"33\":1}}],[\"css\",{\"1\":{\"26\":1,\"32\":2,\"70\":2}}],[\"count++\",{\"1\":{\"70\":1}}],[\"count\",{\"1\":{\"70\":8}}],[\"counter的值时\",{\"1\":{\"84\":1}}],[\"counter++\",{\"1\":{\"22\":1,\"38\":1,\"83\":2}}],[\"counter\",{\"1\":{\"20\":2,\"22\":5,\"38\":2,\"70\":2,\"83\":6,\"84\":3}}],[\"collapse\",{\"1\":{\"70\":2}}],[\"color\",{\"1\":{\"23\":1,\"30\":1,\"33\":3,\"34\":1,\"70\":2}}],[\"coder\",{\"1\":{\"63\":1,\"64\":1}}],[\"coderwhy\",{\"1\":{\"39\":1}}],[\"core\",{\"1\":{\"58\":1}}],[\"composition\",{\"1\":{\"77\":2}}],[\"component\",{\"1\":{\"69\":1}}],[\"compatible\",{\"1\":{\"70\":1}}],[\"computed的fullname中的计算\",{\"1\":{\"63\":1}}],[\"computed\",{\"0\":{\"57\":1,\"62\":1},\"1\":{\"30\":1,\"58\":1,\"59\":1,\"62\":1,\"63\":2,\"64\":1,\"65\":1,\"67\":1,\"70\":1,\"77\":1}}],[\"com\",{\"1\":{\"28\":2,\"79\":1,\"85\":1}}],[\"controller的简称\",{\"1\":{\"82\":1}}],[\"content=\",{\"1\":{\"70\":2}}],[\"concat\",{\"0\":{\"10\":1},\"1\":{\"10\":2,\"49\":1}}],[\"console\",{\"1\":{\"6\":2,\"7\":2,\"8\":2,\"9\":2,\"10\":2,\"12\":2,\"13\":2,\"14\":2,\"38\":2,\"39\":2,\"40\":3,\"63\":5,\"64\":1,\"66\":2,\"67\":2,\"68\":7,\"69\":1,\"85\":1}}],[\"const\",{\"1\":{\"6\":2,\"12\":2,\"13\":3,\"14\":2,\"16\":1,\"20\":1,\"22\":1,\"23\":1,\"28\":1,\"30\":1,\"31\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"40\":1,\"42\":1,\"43\":1,\"47\":1,\"48\":1,\"49\":1,\"53\":1,\"61\":1,\"62\":1,\"63\":2,\"64\":2,\"66\":1,\"67\":1,\"69\":1,\"70\":1,\"85\":3}}],[\"cli创建项目\",{\"1\":{\"78\":1}}],[\"click调用时\",{\"1\":{\"39\":1}}],[\"click=\",{\"1\":{\"20\":1,\"22\":3,\"30\":1,\"38\":3,\"39\":2,\"40\":2,\"43\":1,\"49\":1,\"53\":1,\"63\":1,\"64\":1,\"66\":1,\"67\":3,\"70\":3,\"83\":4}}],[\"click\",{\"1\":{\"19\":1,\"38\":2,\"40\":3,\"83\":1}}],[\"class><\",{\"1\":{\"35\":1}}],[\"classobj\",{\"1\":{\"30\":5}}],[\"classname\",{\"1\":{\"30\":2}}],[\"class=\",{\"1\":{\"30\":9,\"31\":4,\"38\":3,\"48\":1,\"70\":1}}],[\"class也是动态的\",{\"1\":{\"29\":1}}],[\"class\",{\"0\":{\"29\":1},\"1\":{\"27\":1,\"30\":3,\"31\":2,\"35\":1}}],[\"cloak>\",{\"1\":{\"26\":1}}],[\"cloak\",{\"0\":{\"26\":1},\"1\":{\"26\":3}}],[\"clonedeep\",{\"1\":{\"15\":1,\"16\":2}}],[\"created\",{\"1\":{\"67\":1,\"68\":1,\"69\":1}}],[\"createapp的时候\",{\"1\":{\"83\":1}}],[\"createapp\",{\"1\":{\"20\":1,\"22\":1,\"23\":1,\"28\":1,\"30\":1,\"31\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"40\":1,\"42\":1,\"43\":1,\"47\":1,\"48\":1,\"49\":1,\"53\":1,\"61\":1,\"62\":1,\"63\":2,\"64\":1,\"66\":1,\"67\":1,\"70\":1,\"83\":2}}],[\"create\",{\"1\":{\"19\":1}}],[\"cxk\",{\"1\":{\"6\":2,\"7\":2,\"8\":2,\"14\":2}}],[\"flow\",{\"1\":{\"75\":1}}],[\"f7f7f7\",{\"1\":{\"70\":1}}],[\"fullname的getter和setter方法\",{\"1\":{\"64\":1}}],[\"fullname\",{\"1\":{\"62\":2,\"63\":9,\"64\":5}}],[\"function\",{\"1\":{\"6\":1,\"12\":1,\"13\":1,\"19\":1,\"37\":1,\"59\":3,\"64\":2,\"65\":1,\"66\":1,\"67\":1,\"68\":3,\"69\":1,\"83\":2}}],[\"f\",{\"0\":{\"53\":1},\"1\":{\"53\":2,\"68\":2,\"85\":1}}],[\"firstname\",{\"1\":{\"59\":1,\"60\":1,\"61\":2,\"62\":2,\"63\":5,\"64\":4}}],[\"filterbooks\",{\"1\":{\"70\":1}}],[\"filter\",{\"1\":{\"49\":3}}],[\"finalprice\",{\"1\":{\"70\":3}}],[\"finalstyleobj\",{\"1\":{\"33\":2}}],[\"finalfontsize\",{\"1\":{\"33\":2}}],[\"finalcolor\",{\"1\":{\"33\":4}}],[\"from\",{\"1\":{\"16\":1}}],[\"fontweight\",{\"1\":{\"33\":2}}],[\"fontsize\",{\"1\":{\"33\":2,\"34\":1}}],[\"font\",{\"1\":{\"33\":3,\"70\":1}}],[\"foo2\",{\"1\":{\"85\":2}}],[\"foo\",{\"1\":{\"13\":2,\"85\":2}}],[\"formatprice\",{\"1\":{\"70\":3}}],[\"for进行列表渲染时\",{\"1\":{\"50\":1}}],[\"for=\",{\"1\":{\"47\":3,\"48\":1,\"49\":1,\"53\":1,\"70\":1}}],[\"for同时也支持数字的遍历\",{\"1\":{\"47\":1}}],[\"for也支持遍历对象\",{\"1\":{\"47\":1}}],[\"for支持的类型\",{\"1\":{\"47\":1}}],[\"for的基本格式是\",{\"1\":{\"47\":1}}],[\"for类似于javascript的for循环\",{\"1\":{\"46\":1}}],[\"for来完成\",{\"1\":{\"46\":1}}],[\"for\",{\"0\":{\"50\":1},\"1\":{\"6\":1,\"12\":1,\"13\":1,\"70\":1}}],[\"id\",{\"1\":{\"70\":4}}],[\"id=\",{\"1\":{\"20\":1,\"22\":2,\"23\":1,\"25\":1,\"27\":1,\"28\":1,\"30\":2,\"31\":2,\"33\":2,\"34\":2,\"35\":2,\"36\":2,\"38\":2,\"39\":2,\"40\":2,\"42\":1,\"43\":2,\"44\":1,\"45\":1,\"47\":2,\"48\":2,\"49\":2,\"53\":2,\"60\":1,\"61\":1,\"62\":1,\"63\":3,\"64\":1,\"66\":2,\"67\":2,\"70\":2,\"83\":4}}],[\"ie=edge\",{\"1\":{\"70\":1}}],[\"item是我们给每项元素起的一个别名\",{\"1\":{\"47\":1}}],[\"item\",{\"1\":{\"47\":2,\"49\":2,\"53\":3,\"70\":3}}],[\"isactive\",{\"1\":{\"30\":6,\"31\":3}}],[\"isshowha\",{\"1\":{\"43\":4}}],[\"isshow\",{\"1\":{\"20\":5,\"44\":1,\"45\":2}}],[\"immediate\",{\"1\":{\"67\":2,\"68\":1,\"69\":2}}],[\"imgurl\",{\"1\":{\"27\":3,\"28\":4}}],[\"image\",{\"1\":{\"18\":1,\"23\":1,\"39\":1,\"40\":1,\"45\":1,\"51\":1,\"52\":1,\"54\":8}}],[\"import\",{\"1\":{\"16\":1}}],[\"i\",{\"1\":{\"12\":8,\"16\":1}}],[\"initial\",{\"1\":{\"70\":1}}],[\"install\",{\"1\":{\"86\":2}}],[\"instance\",{\"1\":{\"69\":1}}],[\"instanceof\",{\"1\":{\"6\":1,\"12\":1,\"13\":1}}],[\"insertf\",{\"1\":{\"53\":2}}],[\"index+1\",{\"1\":{\"47\":1,\"49\":1}}],[\"index\",{\"1\":{\"47\":7,\"49\":1,\"70\":13}}],[\"inline\",{\"1\":{\"37\":1,\"38\":1}}],[\"increment\",{\"1\":{\"22\":4,\"70\":2,\"83\":4}}],[\"info对象会被拆解成div的各个属性\",{\"1\":{\"36\":1}}],[\"info\",{\"1\":{\"8\":3,\"36\":3,\"47\":2,\"48\":2,\"67\":8,\"69\":1}}],[\"in\",{\"1\":{\"6\":1,\"12\":1,\"27\":1,\"47\":8,\"48\":1,\"49\":1,\"50\":1,\"53\":1,\"70\":1}}],[\"if当条件为false时\",{\"1\":{\"45\":1}}],[\"if的区别\",{\"0\":{\"45\":1}}],[\"if的用法看起来是一致的\",{\"1\":{\"44\":1}}],[\"if的渲染原理\",{\"1\":{\"43\":1}}],[\"if上使用\",{\"1\":{\"43\":1}}],[\"if是一个指令\",{\"1\":{\"43\":1}}],[\"if是惰性的\",{\"1\":{\"43\":1}}],[\"if=\",{\"1\":{\"42\":2,\"43\":1,\"45\":1,\"70\":1}}],[\"if类似\",{\"1\":{\"42\":1}}],[\"if用于根据条件来渲染某一块的内容\",{\"1\":{\"42\":1}}],[\"if\",{\"0\":{\"43\":1},\"1\":{\"6\":2,\"12\":2,\"20\":1,\"41\":2,\"42\":1,\"45\":1,\"48\":1}}],[\"next\",{\"1\":{\"79\":1}}],[\"newitem\",{\"1\":{\"70\":3}}],[\"newinfo\",{\"1\":{\"67\":4,\"69\":2}}],[\"new\",{\"1\":{\"68\":1}}],[\"newvalue变化后的新值\",{\"1\":{\"66\":1}}],[\"newvalue\",{\"1\":{\"64\":3,\"66\":2,\"67\":3}}],[\"newmovie\",{\"1\":{\"49\":4}}],[\"newobj\",{\"1\":{\"6\":3,\"12\":8,\"13\":7,\"14\":4,\"16\":1}}],[\"nba\",{\"1\":{\"67\":4}}],[\"node\",{\"1\":{\"51\":1}}],[\"none\",{\"1\":{\"26\":2}}],[\"n\",{\"1\":{\"47\":1}}],[\"npm\",{\"1\":{\"16\":1,\"86\":2}}],[\"name<\",{\"1\":{\"67\":2}}],[\"names\",{\"1\":{\"64\":3}}],[\"name=\",{\"1\":{\"36\":1,\"70\":1}}],[\"name\",{\"1\":{\"6\":4,\"7\":4,\"8\":2,\"10\":2,\"12\":4,\"13\":2,\"14\":4,\"20\":2,\"35\":2,\"36\":1,\"39\":2,\"47\":1,\"48\":1,\"67\":8,\"70\":5}}],[\"num\",{\"1\":{\"47\":2}}],[\"number\",{\"1\":{\"2\":1}}],[\"null\",{\"1\":{\"2\":1}}],[\"null和\",{\"1\":{\"1\":1}}],[\"s\",{\"1\":{\"85\":1}}],[\"slot编译优化\",{\"1\":{\"76\":1}}],[\"slice\",{\"0\":{\"9\":1},\"1\":{\"9\":2,\"49\":1}}],[\"sourcemap\",{\"1\":{\"86\":1}}],[\"solid\",{\"1\":{\"70\":2}}],[\"something\",{\"1\":{\"68\":1}}],[\"somemethod\",{\"1\":{\"68\":2}}],[\"sort\",{\"1\":{\"49\":1}}],[\"set\",{\"1\":{\"59\":1,\"64\":1}}],[\"setter\",{\"0\":{\"64\":1},\"1\":{\"58\":1,\"76\":1}}],[\"self\",{\"1\":{\"37\":1,\"40\":1}}],[\"script标签\",{\"1\":{\"83\":1}}],[\"script>\",{\"1\":{\"20\":2,\"22\":2,\"23\":2,\"28\":1,\"30\":2,\"31\":2,\"33\":2,\"34\":2,\"35\":2,\"36\":2,\"38\":2,\"39\":2,\"40\":2,\"42\":2,\"43\":2,\"47\":2,\"48\":2,\"49\":2,\"53\":2,\"61\":2,\"62\":2,\"63\":4,\"64\":2,\"66\":2,\"67\":2,\"70\":3,\"79\":1,\"80\":1,\"83\":5}}],[\"scale=1\",{\"1\":{\"70\":1}}],[\"score\",{\"1\":{\"42\":4,\"59\":1,\"60\":1,\"61\":2,\"62\":2,\"63\":5}}],[\"shift\",{\"1\":{\"49\":1}}],[\"show元素无论是否需要显示到浏览器上\",{\"1\":{\"45\":1}}],[\"show不可以和v\",{\"1\":{\"45\":1}}],[\"show是不支持template\",{\"1\":{\"45\":1}}],[\"show=\",{\"1\":{\"44\":1,\"45\":1}}],[\"show和v\",{\"0\":{\"45\":1},\"1\":{\"44\":1}}],[\"show\",{\"0\":{\"44\":1},\"1\":{\"41\":1,\"45\":1}}],[\"shallowclone\",{\"1\":{\"6\":2}}],[\"size\",{\"1\":{\"33\":3}}],[\"sing\",{\"1\":{\"6\":1}}],[\"s=60\",{\"1\":{\"28\":1}}],[\"state\",{\"1\":{\"68\":1}}],[\"statement\",{\"1\":{\"37\":1,\"38\":1}}],[\"stop=\",{\"1\":{\"40\":1}}],[\"stoppropagation\",{\"1\":{\"37\":1,\"40\":3}}],[\"stop\",{\"1\":{\"37\":1,\"40\":2}}],[\"stylesheet\",{\"1\":{\"70\":1}}],[\"style2obj\",{\"1\":{\"34\":2}}],[\"style1obj\",{\"1\":{\"34\":2}}],[\"style>\",{\"1\":{\"30\":1}}],[\"style\",{\"0\":{\"32\":1},\"1\":{\"27\":1,\"32\":1,\"35\":1,\"70\":1}}],[\"style=\",{\"1\":{\"23\":1,\"33\":6,\"34\":1}}],[\"stringify\",{\"0\":{\"14\":1},\"1\":{\"14\":3}}],[\"string\",{\"1\":{\"1\":1,\"2\":1,\"14\":1,\"59\":1,\"65\":2}}],[\"src=\",{\"1\":{\"20\":1,\"22\":1,\"23\":1,\"27\":3,\"28\":3,\"30\":1,\"31\":1,\"33\":1,\"34\":1,\"35\":2,\"36\":1,\"38\":1,\"39\":1,\"40\":1,\"42\":1,\"43\":1,\"47\":1,\"48\":1,\"49\":1,\"53\":1,\"61\":1,\"62\":1,\"63\":2,\"64\":1,\"66\":1,\"67\":1,\"70\":2,\"79\":1,\"80\":1,\"83\":2}}],[\"spacing\",{\"1\":{\"70\":1}}],[\"span>\",{\"1\":{\"23\":1,\"70\":1}}],[\"special\",{\"1\":{\"50\":1}}],[\"splice\",{\"1\":{\"49\":1,\"53\":1,\"70\":1}}],[\"split\",{\"1\":{\"20\":2,\"60\":1,\"61\":1,\"62\":1,\"64\":1}}],[\"spread\",{\"1\":{\"7\":1}}],[\"snippet\",{\"1\":{\"18\":1}}],[\"save\",{\"1\":{\"16\":1}}],[\"syntax\",{\"1\":{\"7\":1}}],[\"拷贝的就是内存地址\",{\"1\":{\"5\":1}}],[\"拷贝的就是基本类型的值\",{\"1\":{\"5\":1}}],[\"如filter\",{\"1\":{\"76\":1}}],[\"如何阅读vue源码\",{\"0\":{\"86\":1}}],[\"如何使用\",{\"0\":{\"78\":1}}],[\"如何基于key重新排列的\",{\"1\":{\"50\":1}}],[\"如何尝试修改和复用的\",{\"1\":{\"50\":1}}],[\"如下\",{\"1\":{\"35\":1,\"63\":1}}],[\"如下图所示\",{\"1\":{\"1\":1}}],[\"如果想侦听所有嵌套的变更\",{\"1\":{\"67\":1}}],[\"如果不使用key\",{\"1\":{\"50\":1}}],[\"如果不会频繁的发生切换\",{\"1\":{\"45\":1}}],[\"如果需要同时传入某个参数\",{\"1\":{\"39\":1}}],[\"如果方法本身中有一个参数\",{\"1\":{\"39\":1}}],[\"如果该方法不需要额外参数\",{\"1\":{\"39\":1}}],[\"如果属性名称不是固定的\",{\"1\":{\"35\":1}}],[\"如果属性是引用类型\",{\"1\":{\"5\":1}}],[\"如果属性是基本类型\",{\"1\":{\"5\":1}}],[\"如果存在同名的\",{\"1\":{\"27\":1}}],[\"如果我们确实想设置计算属性的值呢\",{\"1\":{\"64\":1}}],[\"如果我们不只是一个简单的div\",{\"1\":{\"52\":1}}],[\"如果我们需要索引\",{\"1\":{\"47\":1}}],[\"如果我们的元素需要在显示和隐藏之间频繁的切换\",{\"1\":{\"45\":1}}],[\"如果我们希望将一个对象的所有属性\",{\"1\":{\"36\":1}}],[\"如果我们希望这个内容被vue可以解析出来\",{\"1\":{\"23\":1}}],[\"如果我们希望把数据显示到模板\",{\"1\":{\"20\":1}}],[\"如果我们展示的内容本身是\",{\"1\":{\"23\":1}}],[\"如果是子节点的化\",{\"1\":{\"22\":1}}],[\"指的是创建新的数据\",{\"1\":{\"5\":1}}],[\"指向堆内存的地址\",{\"1\":{\"3\":1}}],[\"两个对象属性完成相同\",{\"1\":{\"11\":1}}],[\"两个对象指向不同的地址\",{\"1\":{\"3\":1}}],[\"两个对象指向同一个地址\",{\"1\":{\"3\":1}}],[\"两者示意图如下\",{\"1\":{\"3\":1}}],[\"不使用箭头函数的情况下\",{\"1\":{\"85\":1}}],[\"不可以是window\",{\"1\":{\"85\":1}}],[\"不得不提供一些特殊的api\",{\"1\":{\"76\":1}}],[\"不能侦听到旧值\",{\"1\":{\"67\":1}}],[\"不管多深都会侦听到\",{\"1\":{\"67\":1}}],[\"不及格\",{\"1\":{\"60\":1,\"61\":1,\"62\":1,\"63\":2}}],[\"不便于维护\",{\"1\":{\"60\":1}}],[\"不一定一一对应\",{\"1\":{\"52\":1}}],[\"不带参数\",{\"1\":{\"27\":1}}],[\"不常用指令\",{\"0\":{\"21\":1}}],[\"不会改变另一个对象的属性\",{\"1\":{\"11\":1}}],[\"不会影响到另一个变量的值\",{\"1\":{\"2\":1,\"3\":1}}],[\"不仅会在栈中开辟另一块空间\",{\"1\":{\"3\":1}}],[\"深度侦听\",{\"1\":{\"67\":2}}],[\"深拷贝开辟一个新的栈\",{\"1\":{\"11\":1}}],[\"深拷贝是新开栈\",{\"1\":{\"3\":1}}],[\"深拷贝是递归拷贝深层次\",{\"1\":{\"3\":1}}],[\"深拷贝\",{\"0\":{\"11\":1},\"1\":{\"3\":1}}],[\"深浅拷贝\",{\"0\":{\"2\":1}}],[\"会调用多次\",{\"1\":{\"63\":1}}],[\"会尽量利用我们的key来进行优化操作\",{\"1\":{\"55\":1}}],[\"会将它作为\",{\"1\":{\"27\":1}}],[\"会保留在所绑定的元素上\",{\"1\":{\"26\":1}}],[\"会影响到另一个变量的值\",{\"1\":{\"3\":1}}],[\"会在栈中开辟另一块空间\",{\"1\":{\"3\":1}}],[\"浅拷贝是复制\",{\"1\":{\"3\":1}}],[\"浅拷贝是拷贝一层\",{\"1\":{\"3\":1}}],[\"浅拷贝\",{\"0\":{\"5\":1},\"1\":{\"3\":1,\"5\":1}}],[\"概念\",{\"0\":{\"3\":1}}],[\"bryant\",{\"1\":{\"61\":1,\"62\":1,\"63\":1,\"64\":1}}],[\"built\",{\"1\":{\"50\":1}}],[\"button>\",{\"1\":{\"20\":1,\"22\":3,\"30\":1,\"38\":3,\"39\":2,\"40\":2,\"43\":1,\"49\":1,\"53\":1,\"63\":1,\"64\":1,\"66\":1,\"67\":3,\"70\":3,\"83\":4}}],[\"btnclick\",{\"1\":{\"40\":4}}],[\"btn2click\",{\"1\":{\"39\":2}}],[\"btn1click\",{\"1\":{\"38\":5,\"39\":2}}],[\"book\",{\"1\":{\"70\":9}}],[\"books\",{\"1\":{\"70\":8}}],[\"boolean\",{\"1\":{\"1\":1,\"2\":1,\"30\":1}}],[\"border\",{\"1\":{\"70\":4}}],[\"body\",{\"1\":{\"34\":1}}],[\"body>\",{\"1\":{\"30\":1,\"31\":1,\"33\":1,\"35\":1,\"36\":1,\"38\":1,\"39\":1,\"40\":1,\"43\":1,\"47\":1,\"48\":1,\"49\":1,\"53\":1,\"63\":1,\"66\":1,\"67\":1,\"70\":1,\"83\":2}}],[\"blue\",{\"1\":{\"23\":1}}],[\"bind=\",{\"1\":{\"36\":1}}],[\"bind提供一个语法糖\",{\"1\":{\"27\":1,\"28\":1}}],[\"bind的基本使用\",{\"1\":{\"27\":1,\"28\":1}}],[\"bind\",{\"0\":{\"27\":1},\"1\":{\"19\":1,\"27\":3,\"28\":2,\"30\":1,\"32\":1,\"36\":1,\"85\":1}}],[\"big\",{\"1\":{\"10\":1}}],[\"baidu\",{\"1\":{\"28\":1}}],[\"backgroundcolor\",{\"1\":{\"33\":2}}],[\"background\",{\"1\":{\"23\":1,\"70\":1}}],[\"baz\",{\"1\":{\"13\":2}}],[\"bar\",{\"1\":{\"13\":2,\"85\":5}}],[\"basketball\",{\"1\":{\"6\":3}}],[\"b\",{\"1\":{\"2\":1,\"53\":2,\"68\":3}}],[\"=>\",{\"1\":{\"49\":1,\"68\":1,\"70\":1,\"85\":1}}],[\"==\",{\"1\":{\"6\":1,\"12\":1,\"13\":1}}],[\"=\",{\"1\":{\"2\":2,\"6\":6,\"7\":4,\"8\":3,\"9\":4,\"10\":4,\"12\":7,\"13\":6,\"14\":4,\"16\":1,\"20\":4,\"22\":1,\"23\":1,\"28\":1,\"30\":3,\"31\":1,\"33\":1,\"34\":1,\"35\":3,\"36\":2,\"38\":2,\"39\":1,\"40\":1,\"42\":1,\"43\":2,\"47\":1,\"48\":1,\"49\":3,\"53\":1,\"61\":1,\"62\":1,\"63\":3,\"64\":5,\"66\":2,\"67\":4,\"68\":1,\"69\":1,\"70\":3,\"85\":3}}],[\"align\",{\"1\":{\"70\":1}}],[\"alt=\",{\"1\":{\"27\":3,\"28\":3,\"35\":1}}],[\"anwser\",{\"1\":{\"66\":3}}],[\"any\",{\"1\":{\"27\":1}}],[\"a和b是一致的会继续进行比较\",{\"1\":{\"54\":1}}],[\"api可以将\",{\"1\":{\"77\":1}}],[\"api\",{\"0\":{\"56\":1},\"1\":{\"50\":1,\"58\":1,\"68\":1,\"69\":1,\"77\":4}}],[\"app\",{\"1\":{\"18\":1,\"20\":5,\"22\":6,\"23\":5,\"25\":1,\"27\":1,\"28\":5,\"30\":6,\"31\":6,\"33\":6,\"34\":6,\"35\":6,\"36\":6,\"38\":6,\"39\":6,\"40\":6,\"42\":5,\"43\":6,\"44\":1,\"45\":1,\"47\":6,\"48\":6,\"49\":6,\"53\":6,\"60\":1,\"61\":5,\"62\":5,\"63\":11,\"64\":5,\"66\":6,\"67\":6,\"70\":4,\"83\":4}}],[\"addmovie\",{\"1\":{\"49\":2}}],[\"area\",{\"1\":{\"38\":3}}],[\"arr2copy\",{\"1\":{\"10\":4}}],[\"arr2\",{\"1\":{\"10\":3}}],[\"arr1copy\",{\"1\":{\"9\":4}}],[\"arr1\",{\"1\":{\"9\":3}}],[\"array\",{\"1\":{\"1\":1,\"6\":1,\"12\":1,\"13\":1,\"65\":1}}],[\"active\",{\"1\":{\"30\":8,\"31\":3}}],[\"avatars\",{\"1\":{\"28\":1}}],[\"a>\",{\"1\":{\"27\":1,\"28\":1,\"35\":1}}],[\"attr\",{\"1\":{\"27\":2}}],[\"attrorprop\",{\"1\":{\"27\":1}}],[\"attributes\",{\"1\":{\"50\":1}}],[\"attribute\",{\"1\":{\"27\":7}}],[\"abc\",{\"1\":{\"20\":2,\"22\":1,\"30\":4,\"31\":4}}],[\"aa\",{\"1\":{\"10\":1}}],[\"age=\",{\"1\":{\"36\":1}}],[\"age\",{\"1\":{\"10\":1,\"14\":2,\"36\":1,\"39\":2,\"47\":1,\"48\":1,\"67\":2}}],[\"assign\",{\"0\":{\"8\":1},\"1\":{\"8\":2,\"70\":1}}],[\"a\",{\"1\":{\"2\":2,\"53\":2,\"68\":3}}],[\"例如\",{\"1\":{\"2\":1,\"65\":1}}],[\"在浏览器中打开调试面板\",{\"1\":{\"86\":1}}],[\"在demo中打下断点\",{\"1\":{\"86\":1}}],[\"在package\",{\"1\":{\"86\":1}}],[\"在项目中配置yarn\",{\"1\":{\"86\":1}}],[\"在该方法中\",{\"1\":{\"85\":1}}],[\"在该网站中生成代码片段\",{\"1\":{\"18\":1}}],[\"在页面中通过cdn的方式来引入\",{\"1\":{\"78\":1}}],[\"在方法中被赋值改变时\",{\"1\":{\"67\":1}}],[\"在使用\",{\"1\":{\"83\":1}}],[\"在使用时\",{\"1\":{\"63\":1}}],[\"在使用v\",{\"1\":{\"50\":1}}],[\"在数据不发生变化时\",{\"1\":{\"63\":1}}],[\"在上面的实现思路中\",{\"1\":{\"63\":1}}],[\"在模板语法中直接使用表达式\",{\"0\":{\"60\":1},\"1\":{\"59\":1}}],[\"在模板中放入太多的逻辑会让模板过重和难以维护\",{\"1\":{\"58\":1}}],[\"在模板中使用表达式\",{\"1\":{\"58\":1}}],[\"在模板中可以直接通过插值语法显示一些data中的数据\",{\"1\":{\"58\":1}}],[\"在模板中\",{\"1\":{\"19\":1}}],[\"在界面上显示不及格\",{\"1\":{\"59\":1}}],[\"在界面上显示及格\",{\"1\":{\"59\":1}}],[\"在进行插入或者重置顺序的时候\",{\"1\":{\"55\":1}}],[\"在没有key的时候我们的效率是非常低效的\",{\"1\":{\"55\":1}}],[\"在操作真实dom的时候\",{\"1\":{\"53\":1}}],[\"在新旧nodes对比时辨识vnodes\",{\"1\":{\"50\":1}}],[\"在遍历一个数组的时候会经常需要拿到数组的索引\",{\"1\":{\"47\":1}}],[\"在真实开发中\",{\"1\":{\"46\":1}}],[\"在用法上的区别\",{\"1\":{\"45\":1}}],[\"在给元素绑定事件时\",{\"1\":{\"40\":1}}],[\"在\",{\"1\":{\"40\":1,\"76\":1,\"77\":1}}],[\"在vue\",{\"1\":{\"86\":2}}],[\"在vue3x的时候\",{\"1\":{\"84\":1}}],[\"在vue3\",{\"1\":{\"75\":1,\"77\":1}}],[\"在vue2x的时候\",{\"1\":{\"84\":1}}],[\"在vue2\",{\"1\":{\"75\":1,\"77\":1}}],[\"在vue中\",{\"1\":{\"53\":1}}],[\"在vue中如何监听事件呢\",{\"1\":{\"37\":1}}],[\"在vscode中配置代码片段\",{\"1\":{\"18\":1}}],[\"在前端开发中\",{\"1\":{\"37\":1}}],[\"在前端开发中另外一个非常重要的特性就是交互\",{\"1\":{\"37\":1}}],[\"在某些情况下\",{\"1\":{\"35\":1,\"41\":1}}],[\"在开发中\",{\"1\":{\"29\":1}}],[\"在处理绑定时\",{\"1\":{\"27\":1}}],[\"在赋值的过程中都是深拷贝\",{\"1\":{\"2\":1}}],[\"在探讨深浅拷贝之前\",{\"1\":{\"1\":1}}],[\"而在\",{\"1\":{\"76\":1}}],[\"而且模块划分的更加清晰\",{\"1\":{\"75\":1}}],[\"而且我们多次提到计算属性有缓存\",{\"1\":{\"63\":1}}],[\"而不需要在多个options之间寻找\",{\"1\":{\"77\":1}}],[\"而不一定需要全部使用vue来开发整个\",{\"1\":{\"74\":1}}],[\"而不是使用div来完成\",{\"1\":{\"48\":1}}],[\"而不是作为\",{\"1\":{\"27\":1}}],[\"而嵌套属性的变化不会触发\",{\"1\":{\"67\":1}}],[\"而计算属性虽然使用了多次\",{\"1\":{\"63\":1}}],[\"而进行重新计算\",{\"1\":{\"63\":1}}],[\"而是说\",{\"1\":{\"58\":1}}],[\"而是有一大堆的元素\",{\"1\":{\"52\":1}}],[\"而是会生成新的数组\",{\"1\":{\"49\":1}}],[\"而使用key时\",{\"1\":{\"50\":1}}],[\"而引用类型的值则是拷贝了\",{\"1\":{\"3\":1}}],[\"而引用数据类型如\",{\"1\":{\"1\":1}}],[\"而真实数据存储在堆内存中\",{\"1\":{\"1\":1}}],[\"基本使用\",{\"0\":{\"28\":1,\"38\":1,\"42\":1,\"47\":1,\"59\":1},\"1\":{\"20\":1}}],[\"基本指令\",{\"0\":{\"17\":1}}],[\"基本类型如number\",{\"1\":{\"1\":1}}],[\"基本数据类型和引用数据类型\",{\"1\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
