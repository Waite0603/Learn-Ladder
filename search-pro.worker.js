const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}W(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f==null||f.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":74,\"nextId\":74,\"documentIds\":{\"0\":\"v-65bb3ddf\",\"1\":\"v-65bb3ddf#vscode-代码片段\",\"2\":\"v-65bb3ddf#模板语法\",\"3\":\"v-65bb3ddf#mustache-语法-双大括号语法\",\"4\":\"v-65bb3ddf#不常用指令\",\"5\":\"v-65bb3ddf#v-once指令\",\"6\":\"v-65bb3ddf#v-html\",\"7\":\"v-65bb3ddf#v-text\",\"8\":\"v-65bb3ddf#v-pre\",\"9\":\"v-65bb3ddf#v-cloak\",\"10\":\"v-65bb3ddf#v-bind\",\"11\":\"v-65bb3ddf#基本使用\",\"12\":\"v-65bb3ddf#绑定-class\",\"13\":\"v-65bb3ddf#对象语法\",\"14\":\"v-65bb3ddf#数组语法\",\"15\":\"v-65bb3ddf#绑定-style\",\"16\":\"v-65bb3ddf#对象语法-1\",\"17\":\"v-65bb3ddf#数组语法-1\",\"18\":\"v-65bb3ddf#动态绑定属性\",\"19\":\"v-65bb3ddf#属性直接绑定一个对象\",\"20\":\"v-65bb3ddf#v-on\",\"21\":\"v-65bb3ddf#基本使用-1\",\"22\":\"v-65bb3ddf#参数传递\",\"23\":\"v-65bb3ddf#v-on-的修饰符\",\"24\":\"v-65bb3ddf#条件渲染\",\"25\":\"v-65bb3ddf#基本使用-2\",\"26\":\"v-65bb3ddf#template-和-v-if-结合使用\",\"27\":\"v-65bb3ddf#v-show\",\"28\":\"v-65bb3ddf#v-show和v-if的区别\",\"29\":\"v-65bb3ddf#列表渲染\",\"30\":\"v-65bb3ddf#基本使用-3\",\"31\":\"v-65bb3ddf#template元素使用\",\"32\":\"v-65bb3ddf#数组更新检测\",\"33\":\"v-65bb3ddf#v-for-中的-key-是什么作用\",\"34\":\"v-65bb3ddf#认识-vnode\",\"35\":\"v-65bb3ddf#虚拟-dom\",\"36\":\"v-65bb3ddf#插入-f-的案例\",\"37\":\"v-65bb3ddf#vue源码对于key的判断\",\"38\":\"v-65bb3ddf#有无key的结论\",\"39\":\"v-735040ba\",\"40\":\"v-735040ba#computed\",\"41\":\"v-735040ba#认识计算属性\",\"42\":\"v-735040ba#基本使用\",\"43\":\"v-735040ba#在模板语法中直接使用表达式\",\"44\":\"v-735040ba#使用method对逻辑进行抽取\",\"45\":\"v-735040ba#computed-实现\",\"46\":\"v-735040ba#计算属性-vs-methods\",\"47\":\"v-735040ba#计算属性的-setter-和-getter\",\"48\":\"v-735040ba#侦听器-watch\",\"49\":\"v-735040ba#简单案例\",\"50\":\"v-735040ba#配置选项\",\"51\":\"v-735040ba#其他方式\",\"52\":\"v-735040ba#watch-的api\",\"53\":\"v-735040ba#阶段案例\",\"54\":\"v-735040ba#v-model\",\"55\":\"v-45b1c858\",\"56\":\"v-45b1c858#认识-vue\",\"57\":\"v-45b1c858#什么是-vue\",\"58\":\"v-45b1c858#vue3带来的变化\",\"59\":\"v-45b1c858#性能方面\",\"60\":\"v-45b1c858#新的api\",\"61\":\"v-45b1c858#如何使用-vue\",\"62\":\"v-45b1c858#cdn-引入\",\"63\":\"v-45b1c858#下载和引入\",\"64\":\"v-45b1c858#声明式编程和命令式编程\",\"65\":\"v-45b1c858#mvvm模型\",\"66\":\"v-45b1c858#template属性\",\"67\":\"v-45b1c858#data属性\",\"68\":\"v-45b1c858#methods属性-重点\",\"69\":\"v-45b1c858#如何阅读vue源码\",\"70\":\"v-44825889\",\"71\":\"v-659323e8\",\"72\":\"v-ad9a6986\",\"73\":\"v-744e6dd4\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2],\"1\":[2,23],\"2\":[1,33],\"3\":[3,80],\"4\":[1],\"5\":[2,50],\"6\":[2,47],\"7\":[2,13],\"8\":[2,17],\"9\":[2,33],\"10\":[2,93],\"11\":[1,45],\"12\":[2,11],\"13\":[1,68],\"14\":[1,46],\"15\":[2,22],\"16\":[1,57],\"17\":[1,41],\"18\":[1,56],\"19\":[1,52],\"20\":[2,61],\"21\":[1,62],\"22\":[1,68],\"23\":[3,92],\"24\":[1,8],\"25\":[1,46],\"26\":[5,60],\"27\":[2,17],\"28\":[3,36],\"29\":[1,9],\"30\":[1,86],\"31\":[1,54],\"32\":[1,84],\"33\":[6,34],\"34\":[2,19],\"35\":[2,12],\"36\":[3,71],\"37\":[1,49],\"38\":[1,8],\"39\":[3],\"40\":[1],\"41\":[1,45],\"42\":[1,36],\"43\":[1,35],\"44\":[1,55],\"45\":[2,56],\"46\":[3,95],\"47\":[4,62],\"48\":[2,30],\"49\":[1,65],\"50\":[1,103],\"51\":[1,62],\"52\":[3,35],\"53\":[1,176],\"54\":[2,4],\"55\":[1],\"56\":[2],\"57\":[2,13],\"58\":[1,30],\"59\":[1,47],\"60\":[1,37],\"61\":[2,12],\"62\":[2,10],\"63\":[1,14],\"64\":[1,13],\"65\":[1,16],\"66\":[1,81],\"67\":[1,20],\"68\":[3,58],\"69\":[1,26],\"70\":[1],\"71\":[1],\"72\":[1],\"73\":[1]},\"averageFieldLength\":[1.662162162162162,44.51622377622377],\"storedFields\":{\"0\":{\"h\":\"Vue3 基本指令\"},\"1\":{\"h\":\"VSCode 代码片段\",\"t\":[\"我们在前面练习Vue的过程中，有些代码片段是需要经常写的，我们再VSCode中我们可以生成一个代码片段，方便我们快速生成。\",\"VSCode中的代码片段有固定的格式，所以我们一般会借助于一个在线工具来完成。\",\"具体的步骤如下： \",\"第一步，复制自己需要生成代码片段的代码；\",\"第二步，https://snippet-generator.app/在该网站中生成代码片段；\",\"第三步，在VSCode中配置代码片段；\",\"直接 Tab trigger 即可自动填充\",\"image-20231016233051010\"]},\"2\":{\"h\":\"模板语法\",\"t\":[\"React的开发模式[了解] \",\"React使用的jsx,所以对应的代码都是编写的类似于js的一种语法\",\"之后通过Babe将js编译成 React. create Element函数调用\",\"function () { return <div></div> } \",\"vue也支持 jsx 的开发模式: \",\"但是大多数情况下,使用基于HTML的模板语法\",\"在模板中,允许开发者以声明式的方式将 DOM 和底层组件实例的数据绑定在-起;口在底层的实现中,vue将模板编译成虚拟DOM渲染函数\",\"<template> <div @click v-bind v-once> {{}} </div> </template> \"]},\"3\":{\"h\":\"Mustache 语法 双大括号语法\",\"t\":[\"如果我们希望把数据显示到模板（template）中，使用最多的语法是 “Mustache”语法 (双大括号) 的文本插值。 \",\"并且我们前端提到过，data返回的对象是有添加到Vue的响应式系统中；\",\"当data中的数据发生改变时，对应的内容也会发生更新。\",\"当然，Mustache中不仅仅可以是data中的属性，也可以是一个JavaScript的表达式。\",\"mustache的使用 1. 基本使用 2. 表达式 3. 函数 4. 三元运算符\",\"<template id=\\\"my-app\\\"> <!-- 1.mustache的基本使用 --> <h2>{{message}} - {{message}}</h2> <!-- 2.是一个表达式 --> <h2>{{counter * 10}}</h2> <h2>{{ message.split(\\\" \\\").reverse().join(\\\" \\\") }}</h2> <!-- 3.也可以调用函数 --> <!-- 可以使用computed(计算属性) --> <h2>{{getReverseMessage()}}</h2> <!-- 4.三元运算符 --> <h2>{{ isShow ? \\\"哈哈哈\\\": \\\"\\\" }}</h2> <button @click=\\\"toggle\\\">切换</button> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { message: \\\"Hello World\\\", counter: 100, isShow: true } }, methods: { getReverseMessage() { return this.message.split(\\\" \\\").reverse().join(\\\" \\\"); }, toggle() { this.isShow = !this.isShow; } } } Vue.createApp(App).mount('#app'); </script> \",\"以下为错误写法\",\"<!-- 错误用法 --> var name = \\\"abc\\\" ; <h2>{{var name = \\\"abc\\\"}}</h2> <h2>{{ if(isShow) { return \\\"哈哈哈\\\" } }}</h2> \"]},\"4\":{\"h\":\"不常用指令\"},\"5\":{\"h\":\"v-once指令\",\"t\":[\"v-once用于指定元素或者组件只渲染一次\",\"当数据发生变化时,元素或者组件以及其所有的子元素将视为静态内容并且跳过;\",\"该指令可以用于性能优化;\",\"<h2 v-once>{{counter}}</h2> <button @click=\\\"increment\\\">+1</button> \",\"如果是子节点的化，也只能渲染一次\",\"<div v-once> <h2>{{counter}}</h2> <h2>{{message}}</h2> </div> <button @click=\\\"increment\\\">+1</button> \",\"完整代码\",\"<div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <h2>{{counter}}</h2> <div v-once> <h2>{{counter}}</h2> <h2>{{message}}</h2> </div> <button @click=\\\"increment\\\">+1</button> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { counter: 100, message: \\\"abc\\\" } }, methods: { increment() { this.counter++; } } } Vue.createApp(App).mount('#app'); </script> \"]},\"6\":{\"h\":\"v-html\",\"t\":[\"默认情况下，如果我们展示的内容本身是 html 的，那么vue并不会对其进行特殊的解析。 \",\"如果我们希望这个内容被Vue可以解析出来，那么可以使用 v-html 来展示\",\"<template id=\\\"my-app\\\"> <div>{{msg}}</div> <div v-html=\\\"msg\\\"></div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { msg: '<span style=\\\"color:red; background: blue;\\\">哈哈哈</span>' } } } Vue.createApp(App).mount('#app'); </script> \",\"image-20231018083558572\"]},\"7\":{\"h\":\"v-text\",\"t\":[\"用于更新元素的 textContent\",\" <h2 v-text=\\\"message\\\"></h2> <!-- 等价于 --> <h2>{{message}}</h2> \"]},\"8\":{\"h\":\"v-pre\",\"t\":[\"v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签： \",\"跳过不需要编译的节点，加快编译的速度\",\" <template id=\\\"my-app\\\"> <h2 v-pre>{{message}}</h2> </template> <!-- {{message}} --> \"]},\"9\":{\"h\":\"v-cloak\",\"t\":[\"用于隐藏尚未完成编译的 DOM 模板。 \",\"无需传入\",\"详细信息\",\"该指令只在没有构建步骤的环境下需要使用。\",\"当使用直接在 DOM 中书写的模板时，可能会出现一种叫做“未编译模板闪现”的情况：用户可能先看到的是还没编译完成的双大括号标签，直到挂载的组件将它们替换为实际渲染的内容。\",\"v-cloak 会保留在所绑定的元素上，直到相关组件实例被挂载后才移除。配合像 [v-cloak] { display: none } 这样的 CSS 规则，它可以在组件编译完毕前隐藏原始模板。\",\"[v-cloak] { display: none; } \",\"<div v-cloak> {{ message }} </div> \",\"直到编译完成前，<div> 将不可见。\"]},\"10\":{\"h\":\"v-bind\",\"t\":[\"动态的绑定一个或多个 attribute，也可以是组件的 prop。\",\"缩写：: 或者 . (当使用 .prop 修饰符)\",\"期望：any (带参数) | Object (不带参数)\",\"参数：attrOrProp (可选的)\",\"修饰符\",\".camel - 将短横线命名的 attribute 转变为驼峰式命名。\",\".prop - 强制绑定为 DOM property。3.2+\",\".attr - 强制绑定为 DOM attribute。3.2+\",\"用途\",\"当用于绑定 class 或 style attribute，v-bind 支持额外的值类型如数组或对象。详见下方的指南链接。\",\"在处理绑定时，Vue 默认会利用 in 操作符来检查该元素上是否定义了和绑定的 key 同名的 DOM property。如果存在同名的 property，则 Vue 会将它作为 DOM property 赋值，而不是作为 attribute 设置。这个行为在大多数情况都符合期望的绑定值类型，但是你也可以显式用 .prop 和 .attr 修饰符来强制绑定方式。有时这是必要的，特别是在和自定义元素打交道时。\",\"当用于组件 props 绑定时，所绑定的 props 必须在子组件中已被正确声明。\",\"当不带参数使用时，可以用于绑定一个包含了多个 attribute 名称-绑定值对的对象。\",\"用法\",\"动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。\",\"小知识: vue3 是允许template中有多个根元素\",\"<!-- vue2 template模板中只能有一个根元素 --> <!-- vue3 是允许template中有多个根元素 --> <template id=\\\"my-app\\\"> <!-- 1.v-bind的基本使用 --> <img v-bind:src=\\\"imgUrl\\\" alt=\\\"\\\"> <a v-bind:href=\\\"link\\\">百度一下</a> <!-- 2.v-bind提供一个语法糖 : --> <img :src=\\\"imgUrl\\\" alt=\\\"\\\"> <img src=\\\"imgUrl\\\" alt=\\\"\\\"> </template> \"]},\"11\":{\"h\":\"基本使用\",\"t\":[\"<template id=\\\"my-app\\\"> <!-- 1.v-bind的基本使用 --> <img v-bind:src=\\\"imgUrl\\\" alt=\\\"\\\"> <a v-bind:href=\\\"link\\\">百度一下</a> <!-- 2.v-bind提供一个语法糖 : --> <img :src=\\\"imgUrl\\\" alt=\\\"\\\"> <!-- 以下报错 --> <img src=\\\"imgUrl\\\" alt=\\\"\\\"> </template> <script> const App = { template: '#my-app', data() { return { imgUrl: \\\"https://avatars.githubusercontent.com/u/10335230?s=60&v=4\\\", link: \\\"https://www.baidu.com\\\" } } } Vue.createApp(App).mount('#app'); </script> \"]},\"12\":{\"h\":\"绑定 class\",\"t\":[\"在开发中,有时候我们的元素 class也是动态的,比如 \",\"当数据为某个状态时,字体显示红色。\",\"当数据另一个状态时,字体显示黑色\",\"绑定class有两种方式： \",\"对象语法\",\"数组语法\"]},\"13\":{\"h\":\"对象语法\",\"t\":[\"对象语法：我们可以传给 :class (v-bind:class 的简写) 一个对象，以动态地切换 class\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <div :class=\\\"className\\\">哈哈哈哈</div> <!-- 对象语法: {'active': boolean} --> <div :class=\\\"{'active': isActive}\\\">呵呵呵呵</div> <button @click=\\\"toggle\\\">切换</button> <!-- 也可以有多个键值对 --> <div :class=\\\"{active: isActive, title: true}\\\">呵呵呵呵</div> <!-- 默认的class和动态的class结合 --> <div class=\\\"abc cba\\\" :class=\\\"{active: isActive, title: true}\\\"> 呵呵呵呵 </div> <!-- 将对象放到一个单独的属性中 --> <div class=\\\"abc cba\\\" :class=\\\"classObj\\\">呵呵呵呵</div> <!-- 将返回的对象放到一个methods(computed)方法中 --> <div class=\\\"abc cba\\\" :class=\\\"getClassObj()\\\">呵呵呵呵</div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: \\\"#my-app\\\", data() { return { className: \\\"why\\\", isActive: true, title: \\\"abc\\\", classObj: { active: true, title: true }, }; }, methods: { toggle() { this.isActive = !this.isActive; this.classObj.active = !this.classObj.active; }, getClassObj() { return this.classObj; } }, }; Vue.createApp(App).mount(\\\"#app\\\"); </script> <style> .active { color: red; } </style> </body> \"]},\"14\":{\"h\":\"数组语法\",\"t\":[\"绑定class – 数组语法 \",\"数组语法：我们可以把一个数组传给 :class，以应用一个 class 列表\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <div :class=\\\"['abc', title]\\\">哈哈哈哈</div> <!-- class=\\\"abc cba active\\\" --> <div :class=\\\"['abc', title, isActive ? 'active': '']\\\">哈哈哈哈</div> <!-- 可以嵌套对象语法 --> <div :class=\\\"['abc', title, {active: isActive}]\\\">哈哈哈哈</div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { message: \\\"Hello World\\\", title: \\\"cba\\\", isActive: true } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"15\":{\"h\":\"绑定 style\",\"t\":[\"我们可以利用 v-bind:style 来绑定一些CSS内联样式 \",\"这次因为某些样式我们需要根据数据动态来决定\",\"比如某段文字的颜色，大小等等\",\"CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名\",\"绑定class有两种方式 \",\"对象语法\",\"数组语法\",\"CSS property 名短横线分隔 (kebab-case，记得用引号括起来)\"]},\"16\":{\"h\":\"对象语法\",\"t\":[\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <!-- :style=\\\"{cssPropertyName: cssPropertyValue}\\\" --> <div :style=\\\"{color: finalColor, 'font-size': '30px'}\\\">哈哈哈哈</div> <div :style=\\\"{color: finalColor, fontSize: '30px'}\\\">哈哈哈哈</div> <div :style=\\\"{color: finalColor, fontSize: finalFontSize + 'px'}\\\">哈哈哈哈</div> <!-- 绑定一个data中的属性值, 并且是一个对象 --> <div :style=\\\"finalStyleObj\\\">呵呵呵呵</div> <!-- 调用一个方法 --> <div :style=\\\"getFinalStyleObj()\\\">呵呵呵呵</div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { message: \\\"Hello World\\\", finalColor: 'red', finalFontSize: 50, finalStyleObj: { 'font-size': '50px', fontWeight: 700, backgroundColor: 'red' } } }, methods: { getFinalStyleObj() { return { 'font-size': '50px', fontWeight: 700, backgroundColor: 'red' } } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"17\":{\"h\":\"数组语法\",\"t\":[\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <div :style=\\\"[style1Obj, style2Obj]\\\">哈哈哈</div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { message: \\\"Hello World\\\", style1Obj: { color: 'red', fontSize: '30px' }, style2Obj: { textDecoration: \\\"underline\\\" } } } } Vue.createApp(App).mount('#app'); </script> </body \"]},\"18\":{\"h\":\"动态绑定属性\",\"t\":[\"在某些情况下，我们属性的名称可能也不是固定的 \",\"前端我们无论绑定src、href、class、style，属性名称都是固定的\",\"如果属性名称不是固定的，我们可以使用 :[属性名]=“值” 的格式来定义\",\"这种绑定的方式，我们称之为 动态绑定属性；如下:\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <!-- <div cba=\\\"kobe\\\">哈哈哈</div> --> <div :[name]=\\\"value\\\">哈哈哈</div> <img :src=\\\"\\\" alt=\\\"\\\"> <a :href=\\\"\\\"></a> <div :class></div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { name: \\\"cba\\\", value: \\\"kobe\\\" } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"19\":{\"h\":\"属性直接绑定一个对象\",\"t\":[\"如果我们希望将一个对象的所有属性，绑定到元素上的所有属性，应该怎么做呢？ \",\"非常简单，我们可以直接使用 v-bind 绑定一个 对象\",\"案例：info对象会被拆解成div的各个属性\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <!-- <div name=\\\"why\\\" age=\\\"18\\\" height=\\\"1.88\\\">哈哈哈哈</div> --> <div v-bind=\\\"info\\\">哈哈哈哈</div> <div :=\\\"info\\\">哈哈哈哈</div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { info: { name: \\\"why\\\", age: 18, height: 1.88 } } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"20\":{\"h\":\"v-on\",\"t\":[\"v-on绑定事件\",\"前面我们绑定了元素的内容和属性，在前端开发中另外一个非常重要的特性就是交互。\",\"在前端开发中，我们需要经常和用户进行各种各样的交互 \",\"这个时候，我们就必须监听用户发生的事件，比如点击、拖拽、键盘事件等等\",\"在Vue中如何监听事件呢？使用v-on指令。\",\"v-on的用法\",\"缩写：@\",\"预期：Function | Inline Statement | Object\",\"参数：event p 修饰符： \",\".stop - 调用 event.stopPropagation()。\",\".prevent - 调用 event.preventDefault()。\",\".capture - 添加事件侦听器时使用 capture 模式。\",\".self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。\",\".{keyAlias} - 仅当事件是从特定键触发时才触发回调。\",\".once - 只触发一次回调。\",\".left - 只当点击鼠标左键时触发。\",\".right - 只当点击鼠标右键时触发。\",\".middle - 只当点击鼠标中键时触发。\",\".passive - { passive: true } 模式添加侦听器\",\"用法：绑定事件监听\",\"event 事件可以参考 https://developer.mozilla.org/en-US/docs/Web/Events\"]},\"21\":{\"h\":\"基本使用\",\"t\":[\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <!-- 完整写法: v-on:监听的事件=\\\"methods中方法\\\" --> <button v-on:click=\\\"btn1Click\\\">按钮1</button> <div class=\\\"area\\\" v-on:mousemove=\\\"mouseMove\\\">div</div> <!-- 语法糖 --> <button @click=\\\"btn1Click\\\">按钮1</button> <!-- 绑定一个表达式: inline statement --> <button @click=\\\"counter++\\\">{{counter}}</button> <!-- 绑定一个对象 --> <div class=\\\"area\\\" v-on=\\\"{click: btn1Click, mousemove: mouseMove}\\\"></div> <div class=\\\"area\\\" @=\\\"{click: btn1Click, mousemove: mouseMove}\\\"></div> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { message: \\\"Hello World\\\", counter: 100 } }, methods: { btn1Click() { console.log(\\\"按钮1发生了点击\\\"); }, mouseMove() { console.log(\\\"鼠标移动\\\"); } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"22\":{\"h\":\"参数传递\",\"t\":[\"当通过methods中定义方法，以供 @click调用时，需要注意参数问题：\",\"情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。 \",\"但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去\",\"情况二：如果需要同时传入某个参数，同时需要 event 时，可以通过 $event 传入事件。\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <!-- 默认传入event对象, 可以在方法中获取 --> <button @click=\\\"btn1Click\\\">按钮1</button> <!-- $event可以获取到事件发生时的事件对象 --> <button @click=\\\"btn2Click($event, 'coderwhy', 18)\\\">按钮2</button> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { message: \\\"Hello World\\\" } }, methods: { btn1Click(event) { console.log(event); }, btn2Click(event, name, age) { console.log(name, age, event); } } } Vue.createApp(App).mount('#app'); </script> </body> \",\"image-20231019004604619\"]},\"23\":{\"h\":\"v-on 的修饰符\",\"t\":[\"v-on支持修饰符，修饰符相当于对事件进行了一些特殊的处理： \",\".stop - 调用 event.stopPropagation()。\",\".prevent - 调用 event.preventDefault()。\",\".capture - 添加事件侦听器时使用 capture 模式。\",\".self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。\",\".{keyAlias} - 仅当事件是从特定键触发时才触发回调。\",\".once - 只触发一次回调。\",\".left - 只当点击鼠标左键时触发。\",\".right - 只当点击鼠标右键时触发。\",\".middle - 只当点击鼠标中键时触发。\",\".passive - { passive: true } 模式添加侦听器\",\"stopPropagation 是一个事件修饰符，用于阻止事件冒泡。在 Vue.js 中，当一个元素上的事件被触发时，它会先执行该元素上的事件处理函数，然后再冒泡到该元素的父元素，继续执行父元素的事件处理函数。使用 stopPropagation 可以阻止事件继续冒泡到父元素。在给元素绑定事件时，可以使用 @click.stop 来阻止 click 事件冒泡到父元素。\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <div @click=\\\"divClick\\\"> <button @click=\\\"btnClick\\\">按钮</button> <button @click.stop=\\\"btnClick\\\">按钮</button> </div> <input type=\\\"text\\\" @keyup.enter=\\\"enterKeyup\\\"> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { message: \\\"Hello World\\\" } }, methods: { divClick() { console.log(\\\"divClick\\\"); }, btnClick() { console.log('btnClick'); }, enterKeyup(event) { console.log(\\\"keyup\\\", event.target.value); } } } Vue.createApp(App).mount('#app'); </script> </body> \",\"image-20231019005251770\"]},\"24\":{\"h\":\"条件渲染\",\"t\":[\"在某些情况下，我们需要根据当前的条件决定某些元素或组件是否渲染，这个时候我们就需要进行条件判断了。 \",\"Vue提供了下面的指令来进行条件判断： \",\"v-if\",\"v-else\",\"v-else-if\",\"v-show\"]},\"25\":{\"h\":\"基本使用\",\"t\":[\"v-if、v-else、v-else-if用于根据条件来渲染某一块的内容： \",\"这些内容只有在条件为true时，才会被渲染出来；\",\"这三个指令与JavaScript的条件语句if、else、else if类似；\",\" <template id=\\\"my-app\\\"> <input type=\\\"text\\\" v-model=\\\"score\\\"> <h2 v-if=\\\"score > 90\\\">优秀</h2> <h2 v-else-if=\\\"score > 60\\\">良好</h2> <h2 v-else>不及格</h2> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { score: 95 } } } Vue.createApp(App).mount('#app'); </script> \"]},\"26\":{\"h\":\"template 和 v-if 结合使用\",\"t\":[\"v-if的渲染原理： \",\"v-if是惰性的；\",\"当条件为false时，其判断的内容完全不会被渲染或者会被销毁掉；\",\"当条件为true时，才会真正渲染条件块中的内容;\",\"template元素 \",\"因为v-if是一个指令，所以必须将其添加到一个元素上： \",\"但是如果我们希望切换的是多个元素呢？\",\"此时我们渲染div，但是我们并不希望div这种元素被渲染；\",\"这个时候，我们可以选择使用template；\",\"template元素可以当做不可见的包裹元素，并且在v-if上使用，但是最终template不会被渲染出来： \",\"有点类似于小程序中的block\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <template v-if=\\\"isShowHa\\\"> <h2>哈哈哈哈</h2> <h2>哈哈哈哈</h2> <h2>哈哈哈哈</h2> </template> <template v-else> <h2>呵呵呵呵</h2> <h2>呵呵呵呵</h2> <h2>呵呵呵呵</h2> </template> <button @click=\\\"isShowHa = !isShowHa\\\">切换</button> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { isShowHa: true } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"27\":{\"h\":\"v-show\",\"t\":[\"v-show和v-if的用法看起来是一致的，也是根据一个条件决定是否显示元素或者组件\",\" <template id=\\\"my-app\\\"> <h2 v-show=\\\"isShow\\\">哈哈哈哈</h2> </template> \"]},\"28\":{\"h\":\"v-show和v-if的区别\",\"t\":[\"首先，在用法上的区别： \",\"v-show是不支持template；\",\"v-show不可以和v-else一起使用；\",\"其次，本质的区别： \",\"v-show元素无论是否需要显示到浏览器上，它的DOM实际都是有渲染的，只是通过CSS的display属性来进行 切换；\",\"v-if当条件为false时，其对应的元素压根不会被渲染到DOM中；\",\"开发中如何进行选择呢？ \",\"如果我们的元素需要在显示和隐藏之间频繁的切换，那么使用v-show；\",\"如果不会频繁的发生切换，那么使用v-if；\",\"<template id=\\\"my-app\\\"> <h2 v-if=\\\"isShow\\\">哈哈哈哈</h2> <h2 v-show=\\\"isShow\\\">呵呵呵呵</h2> </template> \",\"image-20231019222841008\"]},\"29\":{\"h\":\"列表渲染\",\"t\":[\"在真实开发中，我们往往会从服务器拿到一组数据，并且需要对其进行渲染。 \",\"这个时候我们可以使用v-for来完成；\",\"v-for类似于JavaScript的for循环，可以用于遍历一组数据；\"]},\"30\":{\"h\":\"基本使用\",\"t\":[\"n v-for的基本格式是 \\\"item in 数组\\\"：\",\"数组通常是来自data或者prop，也可以是其他方式；\",\"item是我们给每项元素起的一个别名，这个别名可以自定来定义；\",\"我们知道，在遍历一个数组的时候会经常需要拿到数组的索引：\",\"如果我们需要索引，可以使用格式： \\\"(item, index) in 数组\\\"；\",\"注意上面的顺序：数组元素项item是在前面的，索引项index是在后面的；\",\"v-for支持的类型\",\"v-for也支持遍历对象，并且支持有一二三个参数： \",\"一个参数： \\\"value in object\\\";\",\"二个参数： \\\"(value, key) in object\\\";\",\"三个参数： \\\"(value, key, index) in object\\\";\",\"v-for同时也支持数字的遍历： \",\"每一个item都是一个数字；\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <h2>电影列表</h2> <ul> <!-- 遍历数组 --> <li v-for=\\\"(movie, index) in movies\\\">{{index+1}}.{{movie}}</li> </ul> <h2>个人信息</h2> <ul> <!-- 遍历对象 --> <li v-for=\\\"(value, key, index) in info\\\">{{value}}-{{key}}-{{index}}</li> </ul> <h2>遍历数字</h2> <ul> <li v-for=\\\"(num, index) in 10\\\">{{num}}-{{index}}</li> </ul> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { movies: [ \\\"星际穿越\\\", \\\"盗梦空间\\\", \\\"大话西游\\\", \\\"教父\\\", \\\"少年派\\\" ], info: { name: \\\"why\\\", age: 18, height: 1.88 } } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"31\":{\"h\":\"template元素使用\",\"t\":[\"类似于v-if，你可以使用 template 元素来循环渲染一段包含多个元素的内容： \",\"我们使用template来对多个元素进行包裹，而不是使用div来完成；\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <ul> <template v-for=\\\"(value, key) in info\\\"> <li>{{key}}</li> <li>{{value}}</li> <li class=\\\"divider\\\"></li> </template> </ul> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { info: { name: \\\"why\\\", age: 18, height: 1.88 } } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"32\":{\"h\":\"数组更新检测\",\"t\":[\"Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括： \",\"push()\",\"pop()\",\"shift()\",\"unshift()\",\"splice()\",\"sort()\",\"reverse()\",\"替换数组的方法 \",\"上面的方法会直接修改原来的数组，但是某些方法不会替换原来的数组，而是会生成新的数组，比如 filter()、 concat() 和 slice()。\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <h2>电影列表</h2> <ul> <li v-for=\\\"(movie, index) in movies\\\">{{index+1}}.{{movie}}</li> </ul> <input type=\\\"text\\\" v-model=\\\"newMovie\\\"> <button @click=\\\"addMovie\\\">添加电影</button> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { newMovie: \\\"\\\", movies: [ \\\"星际穿越\\\", \\\"盗梦空间\\\", \\\"大话西游\\\", \\\"教父\\\", \\\"少年派\\\" ] } }, methods: { addMovie() { this.movies.push(this.newMovie); this.newMovie = \\\"\\\"; // filter 是过滤的意思, 下文中的代码的意思是: 过滤掉长度小于等于2的电影 // this.movies = this.movies.filter(item => item.length > 2); } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"33\":{\"h\":\"v-for 中的 key 是什么作用？\",\"t\":[\"https://cn.vuejs.org/api/built-in-special-attributes.html#key\",\"在使用v-for进行列表渲染时，我们通常会给元素或者组件绑定一个key属性。\",\"这个key属性有什么作用呢？我们先来看一下官方的解释：\",\"key属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes；\",\"如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法；\",\"而使用key时，它会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素；\",\"官方的解释对于初学者来说并不好理解，比如下面的问题：\",\"什么是新旧nodes，什么是VNode？\",\"没有key的时候，如何尝试修改和复用的？\",\"有key的时候，如何基于key重新排列的？\"]},\"34\":{\"h\":\"认识 VNode\",\"t\":[\"我们先来解释一下VNode的概念： \",\"因为目前我们还没有比较完整的学习组件的概念，所以目前我们先理解HTML元素创建出来的VNode；\",\"VNode的全称是Virtual Node，也就是虚拟节点；\",\"事实上，无论是组件还是元素，它们最终在Vue中表示出来的都是一个个VNode；\",\"VNode的本质是一个JavaScript的对象；可以用于描述某一个标签/ 元素 的样子\",\"好处: 多平台的渲染, 跨平台(主要好处)\",\"image-20231020162812819\"]},\"35\":{\"h\":\"虚拟 DOM\",\"t\":[\"如果我们不只是一个简单的div，而是有一大堆的元素，那么它们应该会形成一个 VNode Tree\",\"虚拟 DOM 与 真实 DOM 不一定一一对应\",\"image-20231020163154944\"]},\"36\":{\"h\":\"插入 F 的案例\",\"t\":[\"我们先来看一个案例：这个案例是当我点击按钮时会在中间插入一个f；\",\"我们可以确定的是，这次更新对于ul和button是不需要进行更新，需要更新的是我们 li 的列表：\",\"在Vue中，对于相同父元素的子元素节点并不会重新渲染整个列 表；\",\"因为对于列表中 a、b、c、d它们都是没有变化的；\",\"在操作真实DOM的时候，我们只需要在中间插入一个 f 的 li 即可；\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <ul> <li v-for=\\\"item in letters\\\" :key=\\\"item\\\">{{item}}</li> </ul> <button @click=\\\"insertF\\\">插入F元素</button> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { letters: ['a', 'b', 'c', 'd'] } }, methods: { insertF() { this.letters.splice(2, 0, 'f') } } } Vue.createApp(App).mount('#app'); </script> </body> \",\"那么Vue中对于列表的更新究竟是如何操作的呢？ \",\"Vue事实上会对于有key和没有key会调用两个不同的方法；\"]},\"37\":{\"h\":\"Vue源码对于key的判断\",\"t\":[\"有key，那么就使用 patchKeyedChildren方法；\",\"没有key，那么久使用 patchUnkeyedChildren方法；\",\"image-20231020164733530\",\"diff算法: diff 算法是指生成更新补丁的方式,主要应用于虚拟 DOM 树变化后,更新真实 DOM。所以 diff 算法一定存在这样一个过程:触发更新 → 生成补丁 → 应用补丁。\",\"没有key的操作过程\",\"image-20231022182341619\",\"我们会发现上面的diff算法效率并不高： \",\"c和d来说它们事实上并不需要有任何的改动；\",\"但是因为我们的c被f所使用了，所有后续所有的内容都要一次进行改动，并且最后进行新增；\",\"image-20231022182012027\",\"有key的操作过程-diff算法 \",\"第一步的操作是从头开始进行遍历、比较： \",\"a和b是一致的会继续进行比较；\",\"c和f因为key不一致，所以就会break跳出循环\",\"第二步的操作是从尾部开始进行遍历、比较\",\"第三步是如果旧节点遍历完毕，但是依然有新的节点，那么就新增节点：\",\"第四步是如果新的节点遍历完毕，但是依然有旧的节点，那么就移除旧节点：\",\"第五步是最特色的情况，中间还有很多未知的或者乱序的节点：\",\"image-20231022182232738\",\"image-20231022182140133\",\"image-20231022182241976\",\"image-20231022182251535\",\"image-20231022182300781\"]},\"38\":{\"h\":\"有无key的结论\",\"t\":[\"有无key的结论 \",\"所以我们可以发现，Vue在进行diff算法的时候，会尽量利用我们的key来进行优化操作： \",\"在没有key的时候我们的效率是非常低效的；\",\"在进行插入或者重置顺序的时候，保持相同的key可以让diff算法更加的高效；\"]},\"39\":{\"h\":\"Vue 的Options API\"},\"40\":{\"h\":\"Computed\"},\"41\":{\"h\":\"认识计算属性\",\"t\":[\"我们知道，在模板中可以直接通过插值语法显示一些data中的数据。\",\"但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示；\",\"比如我们需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示；\",\"在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算；\",\"在模板中放入太多的逻辑会让模板过重和难以维护；\",\"并且如果多个地方都使用到，那么会有大量重复的代码；\",\"我们有没有什么方法可以将逻辑抽离出去呢？\",\"可以，其中一种方式就是将逻辑抽取到一个method中，放到methods的options中；\",\"但是，这种做法有一个直观的弊端，就是所有的data使用过程都会变成了一个方法的调用；\",\"另外一种方式就是使用计算属性computed；\",\"什么是计算属性呢？\",\"https://cn.vuejs.org/api/reactivity-core.html#computed\",\"官方并没有给出直接的概念解释；\",\"而是说：对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性；\",\"计算属性将被混入到组件实例中。所有 getter 和 setter 的 this 上下文自动地绑定为组件实例；\"]},\"42\":{\"h\":\"基本使用\",\"t\":[\"计算属性的用法：\",\"**选项：**computed\",\"类型：{ [key: string]: Function | { get: Function, set: Function } }\",\"我们来看三个案例：\",\"我们有两个变量：firstName 和 lastName，希望它们拼接之后在界面上显示；\",\"我们有一个分数：score \",\"当score大于60的时候，在界面上显示及格；\",\"当score小于60的时候，在界面上显示不及格；\",\"我们有一个变量message，记录一段文字：比如Hello World \",\"某些情况下我们是直接显示这段文字；\",\"某些情况下我们需要对这段文字进行反转；\",\"我们可以有三种实现思路： \",\"思路一：在模板语法中直接使用表达式；\",\"思路二：使用method对逻辑进行抽取；\",\"思路三：使用计算属性computed；\"]},\"43\":{\"h\":\"在模板语法中直接使用表达式\",\"t\":[\"缺点一：模板中存在大量的复杂逻辑，不便于维护（模板中表达式的初衷是用于简单的计算）；\",\"缺点二：当有多次一样的逻辑时，存在重复的代码；\",\"缺点三：多次使用的时候，很多运算也需要多次执行，没有缓存；\",\"<template id=\\\"my-app\\\"> <!-- 1.实现思路一: --> <h2>{{ firstName + lastName }}</h2> <h2>{{ score >= 60 ? \\\"及格\\\": \\\"不及格\\\" }}</h2> <h2>{{ message.split(\\\"\\\").reverse().join(\\\" \\\") }}</h2> </template> \"]},\"44\":{\"h\":\"使用method对逻辑进行抽取\",\"t\":[\"缺点一：我们事实上先显示的是一个结果，但是都变成了一种方法的调用；\",\"缺点二：多次使用方法的时候，没有缓存，也需要多次计算；\",\"<template id=\\\"my-app\\\"> <h2>{{getFullName()}}</h2> <h2>{{getResult()}}</h2> <h2>{{getReverseMessage()}}</h2> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { firstName: \\\"Kobe\\\", lastName: \\\"Bryant\\\", score: 80, message: \\\"Hello World\\\" } }, methods: { getFullName() { return this.firstName + \\\" \\\" + this.lastName; }, getResult() { return this.score >= 60 ? \\\"及格\\\": \\\"不及格\\\"; }, getReverseMessage() { return this.message.split(\\\" \\\").reverse().join(\\\" \\\"); } } } Vue.createApp(App).mount('#app'); </script> \"]},\"45\":{\"h\":\"computed 实现\",\"t\":[\"注意：计算属性看起来像是一个函数，但是我们在使用的时候不需要加()，这个后面讲setter和getter时会讲到；\",\"我们会发现无论是直观上，还是效果上计算属性都是更好的选择；\",\"并且计算属性是有缓存的；\",\"<template id=\\\"my-app\\\"> <h2>{{fullName}}</h2> <h2>{{result}}</h2> <h2>{{reverseMessage}}</h2> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { firstName: \\\"Kobe\\\", lastName: \\\"Bryant\\\", score: 80, message: \\\"Hello World\\\" } }, computed: { // 定义了一个计算属性叫fullname fullName() { return this.firstName + \\\" \\\" + this.lastName; }, result() { return this.score >= 60 ? \\\"及格\\\": \\\"不及格\\\"; }, reverseMessage() { return this.message.split(\\\" \\\").reverse().join(\\\" \\\"); } } } Vue.createApp(App).mount('#app'); </script> \"]},\"46\":{\"h\":\"计算属性 vs methods\",\"t\":[\"在上面的实现思路中，我们会发现计算属性和methods的实现看起来是差别是不大的，而且我们多次提到计算属性有缓存。\",\"接下来我们来看一下同一个计算多次使用，计算属性和methods的差异：\",\"<template id=\\\"my-app\\\"> <button @click=\\\"changeFirstName\\\">修改firstName</button> <h2>{{fullName}}</h2> <h2>{{fullName}}</h2> <h2>{{fullName}}</h2> <h2>{{fullName}}</h2> <h2>{{fullName}}</h2> <h2>{{fullName}}</h2> <h2>{{fullName}}</h2> <h2>{{fullName}}</h2> <h2>{{getFullName()}}</h2> <h2>{{getFullName()}}</h2> <h2>{{getFullName()}}</h2> <h2>{{getFullName()}}</h2> <h2>{{getFullName()}}</h2> <h2>{{getFullName()}}</h2> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { firstName: \\\"Kobe\\\", lastName: \\\"Bryant\\\" } }, computed: { // 计算属性是有缓存的, 当我们多次使用计算属性时, 计算属性中的运算只会执行一次. // 计算属性会随着依赖的数据(firstName)的改变, 而进行重新计算. fullName() { console.log(\\\"computed的fullName中的计算\\\"); return this.firstName + \\\" \\\" + this.lastName; } }, methods: { getFullName() { console.log(\\\"methods的getFullName中的计算\\\"); return this.firstName + \\\" \\\" + this.lastName; }, changeFirstName() { this.firstName = \\\"Coder\\\" } } } Vue.createApp(App).mount('#app'); </script> \",\"打印结果如下：\",\"我们会发现methods在多次使用时，会调用多次；\",\"而计算属性虽然使用了多次，但是计算的过程只调用了一次；\",\"这是因为计算属性会基于它们的依赖关系进行缓存；\",\"在数据不发生变化时，计算属性是不需要重新计算的；\",\"但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算；如下:\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <input type=\\\"text\\\" v-model=\\\"score\\\"> <!-- 1.使用methods --> <h2>{{getResult()}}</h2> <h2>{{getResult()}}</h2> <h2>{{getResult()}}</h2> <!-- 2.使用computed --> <h2>{{result}}</h2> <h2>{{result}}</h2> <h2>{{result}}</h2> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { score: 90 } }, computed: { result() { console.log(\\\"调用了计算属性result的getter\\\"); return this.score >= 60 ? \\\"及格\\\": \\\"不及格\\\"; } }, methods: { getResult() { console.log(\\\"调用了getResult方法\\\"); return this.score >= 60 ? \\\"及格\\\": \\\"不及格\\\"; } } } Vue.createApp(App).mount('#app'); </script> </body> \",\"当 score 变化, console 输出如下:\",\"调用了getResult方法 调用了getResult方法 调用了getResult方法 调用了计算属性result的getter \"]},\"47\":{\"h\":\"计算属性的 setter 和 getter\",\"t\":[\"计算属性在大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数。\",\"但是，如果我们确实想设置计算属性的值呢？\",\"这个时候我们也可以给计算属性设置一个setter的方法；\",\"<template id=\\\"my-app\\\"> <button @click=\\\"changeFullName\\\">修改fullName</button> <h2>{{fullName}}</h2> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { firstName: \\\"Kobe\\\", lastName: \\\"Bryant\\\" } }, computed: { // fullName 的 getter方法 fullName() { return this.firstName + \\\" \\\" + this.lastName; }, // fullName的getter和setter方法 fullName: { get: function() { return this.firstName + \\\" \\\" + this.lastName; }, set: function(newValue) { console.log(newValue); const names = newValue.split(\\\" \\\"); this.firstName = names[0]; this.lastName = names[1]; } } }, methods: { changeFullName() { this.fullName = \\\"Coder Why\\\"; } } } Vue.createApp(App).mount('#app'); </script> \",\"以下为内部判断\",\"图片\"]},\"48\":{\"h\":\"侦听器 watch\",\"t\":[\"用于声明在数据更改时调用的侦听回调。watch 选项期望接受一个对象，其中键是需要侦听的响应式组件实例属性 (例如，通过 data 或 computed 声明的属性)——值是相应的回调函数。该回调函数接受被侦听源的新值和旧值。\",\"什么是侦听器？ \",\"开发中我们在data返回的对象中定义了数据，这个数据通过插值语法等方式绑定到template中;\",\"当数据变化时，template会自动进行更新来显示最新的数据;\",\"但是在某些情况下，我们希望在代码逻辑中监听某个数据的变化，这个时候就需要用侦听器watch来完成了;\",\"用法如下： \",\"选项：watch\",\"类型: {[key: string]: string | Function | Object | Array}\"]},\"49\":{\"h\":\"简单案例\",\"t\":[\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> 您的问题: <input type=\\\"text\\\" v-model=\\\"question\\\"> <button @click=\\\"queryAnswer\\\">查找答案</button> <p>您的问题是: {{ question }}</p> <p>答案是: {{ anwser }}</p> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { // 侦听question的变化时, 去进行一些逻辑的处理(JavaScript, 网络请求) question: \\\"Hello World\\\", anwser: \\\"\\\" } }, watch: { // question侦听的data中的属性的名称 // newValue变化后的新值 // oldValue变化前的旧值 question: function(newValue, oldValue) { console.log(\\\"新值: \\\", newValue, \\\"旧值\\\", oldValue); this.queryAnswer(); } }, methods: { queryAnswer() { // console.log(`你的问题${this.question}的答案是哈哈哈哈哈`); this.anwser = `你的问题${this.question}的答案是哈哈哈哈哈`; } } } Vue.createApp(App).mount('#app'); </script> </body> \"]},\"50\":{\"h\":\"配置选项\",\"t\":[\"watch 默认是浅层的：被侦听的属性，仅在被赋新值时，才会触发回调函数——而嵌套属性的变化不会触发。如果想侦听所有嵌套的变更，你需要深层侦听器：\",\"以下为不使用深度监听, 当 info.name 在方法中被赋值改变时, 页面会改变, 但是watch不会侦听到, 理由如上\",\"<body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <h2>{{info.name}}</h2> <button @click=\\\"changeInfo\\\">改变info</button> <!-- 页面会改变, 但是watch不会侦听到 --> <button @click=\\\"changeInfoName\\\">改变info.name</button> <button @click=\\\"changeInfoNbaName\\\">改变info.nba.name</button> </template> <script src=\\\"../js/vue.js\\\"></script> <script> const App = { template: '#my-app', data() { return { info: { name: \\\"why\\\", age: 18, nba: {name: 'kobe'} } } }, watch: { // 默认情况下我们的侦听器只会针对监听的数据本身的改变(内部发生的改变是不能侦听) info(newInfo, oldInfo) { console.log(\\\"newValue:\\\", newInfo, \\\"oldValue:\\\", oldInfo); } }, methods: { changeInfo() { this.info = {name: \\\"kobe\\\"}; }, changeInfoName() { this.info.name = \\\"kobe\\\"; }, changeInfoNbaName() { this.info.nba.name = \\\"james\\\"; } } } Vue.createApp(App).mount('#app'); </script> </body> \",\"将 watch 中更改如下, 不管多深都会侦听到\",\"watch: { // 深度侦听/立即执行(一定会执行一次) info: { handler: function(newInfo, oldInfo) { console.log(\\\"newValue:\\\", newInfo, \\\"oldValue:\\\", oldInfo); }, deep: true, // 深度侦听 // immediate: true // 立即执行 } } \",\"immediate: true 立即执行, 这个时候无论后面数据是否有变化，侦听的函数都会有限执行一次；即当刷新页面时会立刻执行一次, 回调函数的初次执行就发生在 created 钩子之前。Vue 此时已经处理了 data、computed 和 methods 选项，所以这些属性在第一次调用时就是可用的。\",\"newValue: Proxy(Object) {name: 'why', age: 18, nba: {…}} oldValue: undefined \",\"注意: 引用对象 or watch 不能侦听到旧值, 可以利用 计算属性 缓存旧值, 或者自己深拷贝一份作为保存\"]},\"51\":{\"h\":\"其他方式\",\"t\":[\"https://cn.vuejs.org/api/options-state.html#watch\",\"export default { data() { return { a: 1, b: 2, c: { d: 4 }, e: 5, f: 6 } }, watch: { // 侦听根级属性 a(val, oldVal) { console.log(`new: ${val}, old: ${oldVal}`) }, // 字符串方法名称 b: 'someMethod', // 该回调将会在被侦听的对象的属性改变时调动，无论其被嵌套多深 c: { handler(val, oldVal) { console.log('c changed') }, deep: true }, // 侦听单个嵌套属性： 'c.d': function (val, oldVal) { // do something }, // 该回调将会在侦听开始之后立即调用 e: { handler(val, oldVal) { console.log('e changed') }, immediate: true }, // 你可以传入回调数组，它们将会被逐一调用 f: [ 'handle1', function handle2(val, oldVal) { console.log('handle2 triggered') }, { handler: function handle3(val, oldVal) { console.log('handle3 triggered') } /* ... */ } ] }, methods: { someMethod() { console.log('b changed') }, handle1() { console.log('handle 1 triggered') } }, created() { this.a = 3 // => new: 3, old: 1 } } \"]},\"52\":{\"h\":\"$watch 的API：\",\"t\":[\"https://cn.vuejs.org/api/component-instance.html#watch\",\"我们可以在created的生命周期（后续会讲到）中，使用 this.$watchs 来侦听；\",\"第一个参数是要侦听的源；\",\"第二个参数是侦听的回调函数callback；\",\"第三个参数是额外的其他选项，比如deep、immediate；\",\"created() { const unwatch = this.$watch(\\\"info\\\", function(newInfo, oldInfo) { console.log(newInfo, oldInfo); }, { deep: true, immediate: true }) // unwatch() } \"]},\"53\":{\"h\":\"阶段案例\",\"t\":[\"现在我们来做一个相对综合一点的练习：书籍购物车\",\"css\",\"table { border: 1px solid #e9e9e9; border-collapse: collapse; border-spacing: 0; } th, td { padding: 8px 16px; border: 1px solid #e9e9e9; text-align: left; } th { background-color: #f7f7f7; color: #5c6b77; font-weight: 600; } .counter { margin: 0 5px; } \",\"index\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\" /> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" /> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" /> <title>Document</title> <link rel=\\\"stylesheet\\\" href=\\\"./style.css\\\" /> </head> <body> <div id=\\\"app\\\"></div> <template id=\\\"my-app\\\"> <template v-if=\\\"books.length > 0\\\"> <table> <thead> <th>序号</th> <th>书籍名称</th> <th>出版日期</th> <th>价格</th> <th>购买数量</th> <th>操作</th> </thead> <tbody> <tr v-for=\\\"(book, index) in books\\\"> <td>{{index + 1}}</td> <td>{{book.name}}</td> <td>{{book.date}}</td> <td>{{formatPrice(book.price)}}</td> <td> <button :disabled=\\\"book.count <= 1\\\" @click=\\\"decrement(index)\\\"> - </button> <span class=\\\"counter\\\">{{book.count}}</span> <button @click=\\\"increment(index)\\\">+</button> </td> <td> <button @click=\\\"removeBook(index)\\\">移除</button> </td> </tr> </tbody> </table> <h2>总价格: {{formatPrice(totalPrice)}}</h2> </template> <template v-else> <h2>购物车为空~</h2> </template> </template> <script src=\\\"../js/vue.js\\\"></script> <script src=\\\"./index.js\\\"></script> <script> Vue.createApp({ template: \\\"#my-app\\\", data() { return { books: [ { id: 1, name: \\\"《算法导论》\\\", date: \\\"2006-9\\\", price: 85.0, count: 1, }, { id: 2, name: \\\"《UNIX编程艺术》\\\", date: \\\"2006-2\\\", price: 59.0, count: 1, }, { id: 3, name: \\\"《编程珠玑》\\\", date: \\\"2008-10\\\", price: 39.0, count: 1, }, { id: 4, name: \\\"《代码大全》\\\", date: \\\"2006-3\\\", price: 128.0, count: 1, }, ], }; }, computed: { totalPrice() { let finalPrice = 0; for (let book of this.books) { finalPrice += book.count * book.price; } return finalPrice; }, // Vue3不支持过滤器了, 推荐两种做法: 使用计算属性/使用全局的方法 filterBooks() { return this.books.map((item) => { const newItem = Object.assign({}, item); newItem.price = \\\"¥\\\" + item.price; return newItem; }); }, }, methods: { increment(index) { // 通过索引值获取到对象 this.books[index].count++; }, decrement(index) { this.books[index].count--; }, removeBook(index) { this.books.splice(index, 1); }, formatPrice(price) { return \\\"¥\\\" + price; }, }, }).mount(\\\"#app\\\"); </script> </body> </html> \"]},\"54\":{\"h\":\"v-model\",\"t\":[\"v-model 可以在组件上使用以实现双向绑定。\"]},\"55\":{\"h\":\"邂逅Vue3开发\"},\"56\":{\"h\":\"认识 Vue\"},\"57\":{\"h\":\"什么是 Vue\",\"t\":[\"Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。 \",\"全程是Vue.js或者Vuejs；\",\"什么是渐进式框架呢？表示我们可以在项目中一点点来引入和使用Vue，而不一定需要全部使用Vue来开发整个 项目；\"]},\"58\":{\"h\":\"Vue3带来的变化\",\"t\":[\"源码通过monorepo的形式来管理源代码： \",\"Mono：单个\",\"Repo：repository仓库\",\"主要是将许多项目的代码存储在同一个 repository 中；\",\"这样做的目的是多个包本身相互独立，可以有自己的功能逻辑、单元测试等，同时又在同一个仓库下方便管理；\",\"而且模块划分的更加清晰，可维护性、可扩展性更强；\",\"源码使用TypeScript来进行重写： \",\"在Vue2.x的时候，Vue使用 Flow 来进行类型检测；\",\"在Vue3.x的时候，Vue的源码全部使用 TypeScript 来进行重构，并且 Vue 本身对 TypeScript 支持也更好了；\"]},\"59\":{\"h\":\"性能方面\",\"t\":[\"使用Proxy进行数据劫持 \",\"在 Vue2.x 的时候，Vue2 是使用 Object.defineProperty 来劫持数据的 getter 和 setter 方法的；\",\"这种方式一致存在一个缺陷就是当给对象添加或者删除属性时，是无法劫持和监听的；\",\"所以在 Vue2.x 的时候，不得不提供一些特殊的API，比如 $set 或 $delete ，事实上都是一些 hack 方法，也增加了 开发者学习新的API的成本；\",\"而在 Vue3.x 开始，Vue 使用 Proxy 来实现数据的劫持\",\"删除了一些不必要的API： \",\"移除了实例上的 $on , $off 和 $once；\",\"移除了一些特性：如filter、内联模板等；\",\"包括编译方面的优化： \",\"生成Block Tree、Slot编译优化、diff算法优化；\"]},\"60\":{\"h\":\"新的API\",\"t\":[\"由Options API 到 Composition API： \",\"在 Vue2.x 的时候，我们会通过 Options API 来描述组件对象；\",\"Options API 包括data、props、methods、computed、生命周期等等这些选项；\",\"存在比较大的问题是多个逻辑可能是在不同的地方： \",\"比如created中会使用某一个method来修改data的数据，代码的内聚性非常差；\",\"Composition API可以将 相关联的代码 放到同一处 进行处理，而不需要在多个Options之间寻找；\",\"Hooks函数增加代码的复用性： \",\"在Vue2.x的时候，我们通常通过mixins在多个组件之间共享逻辑；但是有一个很大的缺陷就是 mixins也是由一大堆的Options组成的，并且多个mixins会存在命名冲突的问题；\",\"在Vue3.x中，我们可以通过Hook函数，来将一部分独立的逻辑抽取出去，并且它们还可以做到是响应式的；\"]},\"61\":{\"h\":\"如何使用 Vue\",\"t\":[\"方式一：在页面中通过CDN的方式来引入；\",\"方式二：下载Vue的JavaScript文件，并且自己手动引入；\",\"方式三：通过npm包管理工具安装使用它；\",\"方式四：直接通过Vue CLI创建项目，并且使用它；\"]},\"62\":{\"h\":\"CDN 引入\",\"t\":[\"<script src=\\\"https://unpkg.com/vue@next\\\"></script> \"]},\"63\":{\"h\":\"下载和引入\",\"t\":[\"下载Vue的源码，可以直接打开CDN的链接： \",\"打开链接，复制其中所有的代码；\",\"创建一个新的文件，比如vue.js，将代码复制到其中；\",\"<script src=\\\"../js/vue.js\\\"></script> \"]},\"64\":{\"h\":\"声明式编程和命令式编程\",\"t\":[\"原生开发和Vue开发的模式和特点,我们会发现是完全不同的,这里其实涉及到两种不同的编程范式命令式编程和声明式编程\",\"命令式编程关注的是“ how to do”,声明式编程关注的是\\\" what to do\\\",由框架(机器)完成\\\"how\\\"的过程\"]},\"65\":{\"h\":\"MVVM模型\",\"t\":[\"MVC和MVVM都是一种软件的体系结构 \",\"MVC是 Model-View-Controller的简称,是在前期被使用非常框架的架构模式,比如iS、前端\",\"MVVM是 Model-View- ViewMode的简称,是目前非常流行的架构模式\",\"通常情况下,我们也经常称vue是一个MVVM的框架 \",\"vue官方其实有说明,vue虽然并没有完全遵守MVVM的模型,但是整个设计是受到它的启发的\"]},\"66\":{\"h\":\"template属性\",\"t\":[\"在使用 createApp的时候,我们传入了一个对象,接下来我们详细解析一下之前传入的属性分别代表什么含义。 \",\"template属性:表示的是Vue需要帮助我们渲染的模板信息\",\"目前我们看到它里面有很多的HTML标签,这些标签会替换掉我们挂载到的元素(比如id为app的dⅳv)的innerHTML\",\"模板中有一些奇怪的语法,比如{},比如@ )click,这些都是模板特有的语法\",\"但是这个模板的写法有点过于别扭了,并且IDE很有可能没有任何提示,阻碍我们编程的效率\",\"vue提供了两种方式:\",\"方式一:使用 script标签,并且标记它的类型为 X-template;\",\"<body> <div id=\\\"app\\\">hhhh</div> <script type=\\\"x-template\\\" id=\\\"why\\\"> <div> <h2>{{message}}</h2> <h2>{{counter}}</h2> <button @click='increment'>+1</button> <button @click='decrement'>-1</button> </div> </script> <script src=\\\"../js//Vue.js\\\"></script> <script> Vue.createApp({ template: '#why', data: function(){ return{ message:\\\"Hello World\\\", counter: 100 } }, methods: { increment(){ this.counter++ }, decrement(){ this.counter-- } } }).mount(\\\"#app\\\") </script> </body> \",\"方式二:使用任意标签(通常使用 template标签,因为不会被浏览器渲染),设置id;v template元素是一种用于保存客户端内容的机制,该内容再加载页面时不会被呈现,但随后可以在运行时使用 JavaScript 实例化\",\" <body> <div id=\\\"app\\\"></div> <template id=\\\"why\\\"> <div> <h2>{{message}}</h2> <h2>{{counter}}</h2> <button @click='increment'>+1</button> <button @click='decrement'>-1</button> </div> </template> <script src=\\\"../js//Vue.js\\\"></script> <script> Vue.createApp({ template: '#why', data: function(){ return{ message:\\\"Hello World\\\", counter: 100 } }, methods: { increment(){ this.counter++ }, decrement(){ this.counter-- } } }).mount(\\\"#app\\\") </script> </body> \"]},\"67\":{\"h\":\"data属性\",\"t\":[\"data属性是传入一个函数,并且该函数需要返回一个对象\",\"在Vue2x的时候,也可以传入一个对象(虽然官方推荐是一个函数);\",\"在Vue3x的时候,必须传入一个函数,否则就会直接在浏览器中报错\",\"data中返回的对象会被vue的响应式系统劫持,之后对该对象的修改或者访问都会在劫持中被处理\",\"所以我们在 template中通过{ counter} 访问 counter,可以从对象中获取到数据\",\"所以我们修改 counter的值时, template中的{ counter)也会发生改变;\"]},\"68\":{\"h\":\"methods属性（重点）\",\"t\":[\"methods属性是一个对象,通常我们会在这个对象中定义很多的方法\",\"这些方法可以被绑定到 template模板中;\",\"在该方法中,我们可以使用this关键字来直接访问到data中返回的对象的属性;\",\"问题：官方文档有这个描述，即不能使用箭头函数\",\"为什么不能使用箭头函数(VUE3.0)？\",\"我们在methods中要使用data返回对象中的数据：\",\"那么这个this是必须有值的，并且应该可以通过this获取到data返回对象中的数据。\",\"那么我们这个this能不能是window呢？\",\"不可以是window，因为window中我们无法获取到data返回对象中的数据；\",\"但是如果我们使用箭头函数，那么这个this就会是window了；\",\"为什么是window呢？\",\"这里涉及到箭头函数使用this的查找规则，它会在自己的上层作用于中来查找this；\",\"最终刚好找到的是script作用于中的this，所以就是window；\",\"this到底是如何查找和绑定的呢？\",\"前端面试之彻底搞懂this指向\",\"不使用箭头函数的情况下，this到底指向什么\",\"事实上Vue的源码当中就是对methods中的所有函数进行了遍历，并且通过 bind 绑定了 this\",\"具体看 https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA\",\"// window 隐式绑定 foo(); const obj = { bar: foo }; obj.bar(); /* Window{} {bar: f()} */ const foo2 = () => { console.log(this); } const obj2 = { bar: foo2 }; obj2.bar(); /* Window{} Window{} */ \"]},\"69\":{\"h\":\"如何阅读Vue源码\",\"t\":[\"需要的环境 npm，yarn\",\"操作步骤 \",\"安装yarn npm install yarn -g\",\"在项目中配置yarn yarn install\",\"在package.json中的dev后加上--sourcemap\",\"打包项目 yarn dev （在vue/dist文件夹下有两个文件，vue.global.js和vue.global.js.map）\",\"在vue/examplex新建自己的文件夹以及测试demo\",\"在demo中打下断点—debugger\",\"在浏览器中打开调试面板，选择其中的source面板，查看执行对应的源码\"]},\"70\":{\"h\":\"Essential\"},\"71\":{\"h\":\"Learn\"},\"72\":{\"h\":\"Vue\"},\"73\":{\"h\":\"Web\"}},\"dirtCount\":0,\"index\":[[\"查看执行对应的源码\",{\"1\":{\"69\":1}}],[\"选择其中的source面板\",{\"1\":{\"69\":1}}],[\"选项期望接受一个对象\",{\"1\":{\"48\":1}}],[\"选项\",{\"1\":{\"42\":1,\"48\":1,\"50\":1}}],[\"安装yarn\",{\"1\":{\"69\":1}}],[\"操作步骤\",{\"1\":{\"69\":1}}],[\"操作符来检查该元素上是否定义了和绑定的\",{\"1\":{\"10\":1}}],[\"yarn\",{\"1\":{\"69\":4}}],[\"隐式绑定\",{\"1\":{\"68\":1}}],[\"qq\",{\"1\":{\"68\":1}}],[\"queryanswer\",{\"1\":{\"49\":3}}],[\"question侦听的data中的属性的名称\",{\"1\":{\"49\":1}}],[\"question\",{\"1\":{\"49\":6}}],[\"具体看\",{\"1\":{\"68\":1}}],[\"具体的步骤如下\",{\"1\":{\"1\":1}}],[\"最终刚好找到的是script作用于中的this\",{\"1\":{\"68\":1}}],[\"为什么是window呢\",{\"1\":{\"68\":1}}],[\"为什么不能使用箭头函数\",{\"1\":{\"68\":1}}],[\"问题\",{\"1\":{\"68\":1}}],[\"重点\",{\"0\":{\"68\":1}}],[\"访问\",{\"1\":{\"67\":1}}],[\"之后对该对象的修改或者访问都会在劫持中被处理\",{\"1\":{\"67\":1}}],[\"之后通过babe将js编译成\",{\"1\":{\"2\":1}}],[\"否则就会直接在浏览器中报错\",{\"1\":{\"67\":1}}],[\"必须传入一个函数\",{\"1\":{\"67\":1}}],[\"必须在子组件中已被正确声明\",{\"1\":{\"10\":1}}],[\"虽然官方推荐是一个函数\",{\"1\":{\"67\":1}}],[\"实例化\",{\"1\":{\"66\":1}}],[\"实现\",{\"0\":{\"45\":1}}],[\"实现思路一\",{\"1\":{\"43\":1}}],[\"但随后可以在运行时使用\",{\"1\":{\"66\":1}}],[\"但是这个模板的写法有点过于别扭了\",{\"1\":{\"66\":1}}],[\"但是整个设计是受到它的启发的\",{\"1\":{\"65\":1}}],[\"但是有一个很大的缺陷就是\",{\"1\":{\"60\":1}}],[\"但是watch不会侦听到\",{\"1\":{\"50\":2}}],[\"但是如果我们使用箭头函数\",{\"1\":{\"68\":1}}],[\"但是如果我们希望切换的是多个元素呢\",{\"1\":{\"26\":1}}],[\"但是如果依赖的数据发生变化\",{\"1\":{\"46\":1}}],[\"但是计算的过程只调用了一次\",{\"1\":{\"46\":1}}],[\"但是我们在使用的时候不需要加\",{\"1\":{\"45\":1}}],[\"但是我们并不希望div这种元素被渲染\",{\"1\":{\"26\":1}}],[\"但是都变成了一种方法的调用\",{\"1\":{\"44\":1}}],[\"但是\",{\"1\":{\"41\":1,\"47\":1}}],[\"但是设计它们的初衷是用于简单的运算\",{\"1\":{\"41\":1}}],[\"但是在某些情况下\",{\"1\":{\"48\":1}}],[\"但是在某些情况\",{\"1\":{\"41\":1}}],[\"但是依然有旧的节点\",{\"1\":{\"37\":1}}],[\"但是依然有新的节点\",{\"1\":{\"37\":1}}],[\"但是因为我们的c被f所使用了\",{\"1\":{\"37\":1}}],[\"但是某些方法不会替换原来的数组\",{\"1\":{\"32\":1}}],[\"但是最终template不会被渲染出来\",{\"1\":{\"26\":1}}],[\"但是注意\",{\"1\":{\"22\":1}}],[\"但是你也可以显式用\",{\"1\":{\"10\":1}}],[\"但是大多数情况下\",{\"1\":{\"2\":1}}],[\"阻碍我们编程的效率\",{\"1\":{\"66\":1}}],[\"目前我们看到它里面有很多的html标签\",{\"1\":{\"66\":1}}],[\"接下来我们详细解析一下之前传入的属性分别代表什么含义\",{\"1\":{\"66\":1}}],[\"接下来我们来看一下同一个计算多次使用\",{\"1\":{\"46\":1}}],[\"通常我们会在这个对象中定义很多的方法\",{\"1\":{\"68\":1}}],[\"通常使用\",{\"1\":{\"66\":1}}],[\"通常情况下\",{\"1\":{\"65\":1}}],[\"通过npm包管理工具安装使用它\",{\"1\":{\"61\":1}}],[\"通过索引值获取到对象\",{\"1\":{\"53\":1}}],[\"通过\",{\"1\":{\"48\":1}}],[\"完成\",{\"1\":{\"64\":1}}],[\"完整写法\",{\"1\":{\"21\":1}}],[\"完整代码\",{\"1\":{\"5\":1}}],[\"机器\",{\"1\":{\"64\":1}}],[\"由框架\",{\"1\":{\"64\":1}}],[\"由options\",{\"1\":{\"60\":1}}],[\"命令式编程关注的是\",{\"1\":{\"64\":1}}],[\"原生开发和vue开发的模式和特点\",{\"1\":{\"64\":1}}],[\"声明式编程关注的是\",{\"1\":{\"64\":1}}],[\"声明式编程和命令式编程\",{\"0\":{\"64\":1}}],[\"声明的属性\",{\"1\":{\"48\":1}}],[\"创建一个新的文件\",{\"1\":{\"63\":1}}],[\"打包项目\",{\"1\":{\"69\":1}}],[\"打开链接\",{\"1\":{\"63\":1}}],[\"打印结果如下\",{\"1\":{\"46\":1}}],[\"引入\",{\"0\":{\"62\":1}}],[\"引用对象\",{\"1\":{\"50\":1}}],[\"下载vue的源码\",{\"1\":{\"63\":1}}],[\"下载vue的javascript文件\",{\"1\":{\"61\":1}}],[\"下载和引入\",{\"0\":{\"63\":1}}],[\"下文中的代码的意思是\",{\"1\":{\"32\":1}}],[\"进行处理\",{\"1\":{\"60\":1}}],[\"放到同一处\",{\"1\":{\"60\":1}}],[\"放到methods的options中\",{\"1\":{\"41\":1}}],[\"相关联的代码\",{\"1\":{\"60\":1}}],[\"存在比较大的问题是多个逻辑可能是在不同的地方\",{\"1\":{\"60\":1}}],[\"存在重复的代码\",{\"1\":{\"43\":1}}],[\"生命周期等等这些选项\",{\"1\":{\"60\":1}}],[\"生成block\",{\"1\":{\"59\":1}}],[\"生成补丁\",{\"1\":{\"37\":1}}],[\"包括data\",{\"1\":{\"60\":1}}],[\"包括编译方面的优化\",{\"1\":{\"59\":1}}],[\"到\",{\"1\":{\"60\":1}}],[\"到表达式\",{\"1\":{\"10\":1}}],[\"新的api\",{\"0\":{\"60\":1}}],[\"新值\",{\"1\":{\"49\":1}}],[\"内联模板等\",{\"1\":{\"59\":1}}],[\"内部发生的改变是不能侦听\",{\"1\":{\"50\":1}}],[\"移除了一些特性\",{\"1\":{\"59\":1}}],[\"移除了实例上的\",{\"1\":{\"59\":1}}],[\"删除了一些不必要的api\",{\"1\":{\"59\":1}}],[\"开始\",{\"1\":{\"59\":1}}],[\"开发者学习新的api的成本\",{\"1\":{\"59\":1}}],[\"开发中我们在data返回的对象中定义了数据\",{\"1\":{\"48\":1}}],[\"开发中如何进行选择呢\",{\"1\":{\"28\":1}}],[\"性能方面\",{\"0\":{\"59\":1}}],[\"支持也更好了\",{\"1\":{\"58\":1}}],[\"支持额外的值类型如数组或对象\",{\"1\":{\"10\":1}}],[\"本身对\",{\"1\":{\"58\":1}}],[\"本质的区别\",{\"1\":{\"28\":1}}],[\"源码使用typescript来进行重写\",{\"1\":{\"58\":1}}],[\"源码通过monorepo的形式来管理源代码\",{\"1\":{\"58\":1}}],[\"单元测试等\",{\"1\":{\"58\":1}}],[\"单个\",{\"1\":{\"58\":1}}],[\"项目\",{\"1\":{\"57\":1}}],[\"全程是vue\",{\"1\":{\"57\":1}}],[\"读音\",{\"1\":{\"57\":1}}],[\"邂逅vue3开发\",{\"0\":{\"55\":1}}],[\"¥\",{\"1\":{\"53\":2}}],[\"推荐两种做法\",{\"1\":{\"53\":1}}],[\"代码的内聚性非常差\",{\"1\":{\"60\":1}}],[\"代码大全\",{\"1\":{\"53\":1}}],[\"代码片段\",{\"0\":{\"1\":1}}],[\"编程珠玑\",{\"1\":{\"53\":1}}],[\"x中\",{\"1\":{\"60\":1}}],[\"x的时候\",{\"1\":{\"58\":2,\"60\":1}}],[\"x\",{\"1\":{\"53\":1,\"59\":3,\"60\":1,\"66\":2}}],[\"书籍购物车\",{\"1\":{\"53\":1}}],[\"现在我们来做一个相对综合一点的练习\",{\"1\":{\"53\":1}}],[\"阶段案例\",{\"0\":{\"53\":1}}],[\"后续会讲到\",{\"1\":{\"52\":1}}],[\"字符串方法名称\",{\"1\":{\"51\":1}}],[\"字体显示黑色\",{\"1\":{\"12\":1}}],[\"字体显示红色\",{\"1\":{\"12\":1}}],[\"$off\",{\"1\":{\"59\":1}}],[\"$once\",{\"1\":{\"59\":1}}],[\"$on\",{\"1\":{\"59\":1}}],[\"$delete\",{\"1\":{\"59\":1}}],[\"$set\",{\"1\":{\"59\":1}}],[\"$watchs\",{\"1\":{\"52\":1}}],[\"$watch\",{\"0\":{\"52\":1},\"1\":{\"52\":1}}],[\"$\",{\"1\":{\"51\":2}}],[\"$event可以获取到事件发生时的事件对象\",{\"1\":{\"22\":1}}],[\"$event\",{\"1\":{\"22\":2}}],[\"`\",{\"1\":{\"51\":1}}],[\"`new\",{\"1\":{\"51\":1}}],[\"`你的问题$\",{\"1\":{\"49\":2}}],[\"6\",{\"1\":{\"51\":1}}],[\"600\",{\"1\":{\"53\":1}}],[\"60\",{\"1\":{\"25\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":2}}],[\"59\",{\"1\":{\"53\":1}}],[\"5px\",{\"1\":{\"53\":1}}],[\"5c6b77\",{\"1\":{\"53\":1}}],[\"5\",{\"1\":{\"51\":1}}],[\"50px\",{\"1\":{\"16\":2}}],[\"50\",{\"1\":{\"16\":1}}],[\"缓存旧值\",{\"1\":{\"50\":1}}],[\"此时已经处理了\",{\"1\":{\"50\":1}}],[\"此时我们渲染div\",{\"1\":{\"26\":1}}],[\"钩子之前\",{\"1\":{\"50\":1}}],[\"回调函数的初次执行就发生在\",{\"1\":{\"50\":1}}],[\"即不能使用箭头函数\",{\"1\":{\"68\":1}}],[\"即当刷新页面时会立刻执行一次\",{\"1\":{\"50\":1}}],[\"即可\",{\"1\":{\"36\":1}}],[\"即可自动填充\",{\"1\":{\"1\":1}}],[\"一定会执行一次\",{\"1\":{\"50\":1}}],[\"一个参数\",{\"1\":{\"30\":1}}],[\"一个对象\",{\"1\":{\"13\":1}}],[\"立即执行\",{\"1\":{\"50\":3}}],[\"深度侦听\",{\"1\":{\"50\":2}}],[\"理由如上\",{\"1\":{\"50\":1}}],[\"页面会改变\",{\"1\":{\"50\":2}}],[\"仅在被赋新值时\",{\"1\":{\"50\":1}}],[\"仅当事件是从特定键触发时才触发回调\",{\"1\":{\"20\":1,\"23\":1}}],[\"被侦听的属性\",{\"1\":{\"50\":1}}],[\"配置选项\",{\"0\":{\"50\":1}}],[\"配合像\",{\"1\":{\"9\":1}}],[\"旧值\",{\"1\":{\"49\":1}}],[\"网络请求\",{\"1\":{\"49\":1}}],[\"去进行一些逻辑的处理\",{\"1\":{\"49\":1}}],[\"侦听单个嵌套属性\",{\"1\":{\"51\":1}}],[\"侦听根级属性\",{\"1\":{\"51\":1}}],[\"侦听的函数都会有限执行一次\",{\"1\":{\"50\":1}}],[\"侦听question的变化时\",{\"1\":{\"49\":1}}],[\"侦听器\",{\"0\":{\"48\":1}}],[\"您的问题\",{\"1\":{\"49\":1}}],[\"简单案例\",{\"0\":{\"49\":1}}],[\"该内容再加载页面时不会被呈现\",{\"1\":{\"66\":1}}],[\"该回调将会在侦听开始之后立即调用\",{\"1\":{\"51\":1}}],[\"该回调将会在被侦听的对象的属性改变时调动\",{\"1\":{\"51\":1}}],[\"该回调函数接受被侦听源的新值和旧值\",{\"1\":{\"48\":1}}],[\"该指令只在没有构建步骤的环境下需要使用\",{\"1\":{\"9\":1}}],[\"该指令可以用于性能优化\",{\"1\":{\"5\":1}}],[\"例如\",{\"1\":{\"48\":1}}],[\"图片\",{\"1\":{\"47\":1}}],[\"输出如下\",{\"1\":{\"46\":1}}],[\"变化\",{\"1\":{\"46\":1}}],[\"定义了一个计算属性叫fullname\",{\"1\":{\"45\":1}}],[\"还是效果上计算属性都是更好的选择\",{\"1\":{\"45\":1}}],[\"注意\",{\"1\":{\"45\":1,\"50\":1}}],[\"注意上面的顺序\",{\"1\":{\"30\":1}}],[\"85\",{\"1\":{\"53\":1}}],[\"8\",{\"1\":{\"53\":1}}],[\"8px\",{\"1\":{\"53\":1}}],[\"80\",{\"1\":{\"44\":1,\"45\":1}}],[\"88\",{\"1\":{\"19\":2,\"30\":1,\"31\":1}}],[\"及格\",{\"1\":{\"43\":1,\"44\":1,\"45\":1,\"46\":2}}],[\"没有缓存\",{\"1\":{\"43\":1,\"44\":1}}],[\"没有key的操作过程\",{\"1\":{\"37\":1}}],[\"没有key的时候\",{\"1\":{\"33\":1}}],[\"没有key\",{\"1\":{\"37\":1}}],[\"很多运算也需要多次执行\",{\"1\":{\"43\":1}}],[\"多次使用方法的时候\",{\"1\":{\"44\":1}}],[\"多次使用的时候\",{\"1\":{\"43\":1}}],[\"多平台的渲染\",{\"1\":{\"34\":1}}],[\"缺点三\",{\"1\":{\"43\":1}}],[\"缺点二\",{\"1\":{\"43\":1,\"44\":1}}],[\"缺点一\",{\"1\":{\"43\":1,\"44\":1}}],[\"思路三\",{\"1\":{\"42\":1}}],[\"思路二\",{\"1\":{\"42\":1}}],[\"思路一\",{\"1\":{\"42\":1}}],[\"某些情况下我们需要对这段文字进行反转\",{\"1\":{\"42\":1}}],[\"某些情况下我们是直接显示这段文字\",{\"1\":{\"42\":1}}],[\"记录一段文字\",{\"1\":{\"42\":1}}],[\"记得用引号括起来\",{\"1\":{\"15\":2}}],[\"希望它们拼接之后在界面上显示\",{\"1\":{\"42\":1}}],[\"类似于\",{\"1\":{\"57\":1}}],[\"类似于v\",{\"1\":{\"31\":1}}],[\"类型\",{\"1\":{\"42\":1,\"48\":1}}],[\"上下文自动地绑定为组件实例\",{\"1\":{\"41\":1}}],[\"上面的方法会直接修改原来的数组\",{\"1\":{\"32\":1}}],[\"你可以传入回调数组\",{\"1\":{\"51\":1}}],[\"你可以使用\",{\"1\":{\"31\":1}}],[\"你需要深层侦听器\",{\"1\":{\"50\":1}}],[\"你都应该使用计算属性\",{\"1\":{\"41\":1}}],[\"官方文档有这个描述\",{\"1\":{\"68\":1}}],[\"官方并没有给出直接的概念解释\",{\"1\":{\"41\":1}}],[\"官方的解释对于初学者来说并不好理解\",{\"1\":{\"33\":1}}],[\"另外一种方式就是使用计算属性computed\",{\"1\":{\"41\":1}}],[\"就是所有的data使用过程都会变成了一个方法的调用\",{\"1\":{\"41\":1}}],[\"数据进行某种转化后显示\",{\"1\":{\"41\":1}}],[\"数组更新检测\",{\"0\":{\"32\":1}}],[\"数组元素项item是在前面的\",{\"1\":{\"30\":1}}],[\"数组通常是来自data或者prop\",{\"1\":{\"30\":1}}],[\"数组\",{\"1\":{\"30\":2}}],[\"数组语法\",{\"0\":{\"14\":1,\"17\":1},\"1\":{\"12\":1,\"14\":2,\"15\":1}}],[\"保持相同的key可以让diff算法更加的高效\",{\"1\":{\"38\":1}}],[\"比较\",{\"1\":{\"37\":2}}],[\"比如id为app的dⅳv\",{\"1\":{\"66\":1}}],[\"比如is\",{\"1\":{\"65\":1}}],[\"比如vue\",{\"1\":{\"63\":1}}],[\"比如created中会使用某一个method来修改data的数据\",{\"1\":{\"60\":1}}],[\"比如deep\",{\"1\":{\"52\":1}}],[\"比如hello\",{\"1\":{\"42\":1}}],[\"比如我们需要对多个data数据进行运算\",{\"1\":{\"41\":1}}],[\"比如下面的问题\",{\"1\":{\"33\":1}}],[\"比如点击\",{\"1\":{\"20\":1}}],[\"比如某段文字的颜色\",{\"1\":{\"15\":1}}],[\"比如\",{\"1\":{\"12\":1,\"32\":1,\"59\":1,\"66\":2}}],[\"应用补丁\",{\"1\":{\"37\":1}}],[\"应该怎么做呢\",{\"1\":{\"19\":1}}],[\"→\",{\"1\":{\"37\":2}}],[\"触发更新\",{\"1\":{\"37\":1}}],[\"算法导论\",{\"1\":{\"53\":1}}],[\"算法一定存在这样一个过程\",{\"1\":{\"37\":1}}],[\"算法是指生成更新补丁的方式\",{\"1\":{\"37\":1}}],[\"更新真实\",{\"1\":{\"37\":1}}],[\"树变化后\",{\"1\":{\"37\":1}}],[\"主要是将许多项目的代码存储在同一个\",{\"1\":{\"58\":1}}],[\"主要应用于虚拟\",{\"1\":{\"37\":1}}],[\"主要好处\",{\"1\":{\"34\":1}}],[\"0\",{\"1\":{\"36\":1,\"47\":1,\"53\":9,\"68\":1}}],[\"表示的是vue需要帮助我们渲染的模板信息\",{\"1\":{\"66\":1}}],[\"表示我们可以在项目中一点点来引入和使用vue\",{\"1\":{\"57\":1}}],[\"表\",{\"1\":{\"36\":1}}],[\"表达式\",{\"1\":{\"3\":1}}],[\"需要的环境\",{\"1\":{\"69\":1}}],[\"需要更新的是我们\",{\"1\":{\"36\":1}}],[\"需要注意参数问题\",{\"1\":{\"22\":1}}],[\"插入\",{\"0\":{\"36\":1}}],[\"真实\",{\"1\":{\"35\":1}}],[\"与\",{\"1\":{\"35\":1}}],[\"虚拟\",{\"0\":{\"35\":1},\"1\":{\"35\":1}}],[\"跨平台\",{\"1\":{\"34\":1}}],[\"好处\",{\"1\":{\"34\":1}}],[\"无论其被嵌套多深\",{\"1\":{\"51\":1}}],[\"无论是组件还是元素\",{\"1\":{\"34\":1}}],[\"无需传入\",{\"1\":{\"9\":1}}],[\"事实上vue的源码当中就是对methods中的所有函数进行了遍历\",{\"1\":{\"68\":1}}],[\"事实上都是一些\",{\"1\":{\"59\":1}}],[\"事实上\",{\"1\":{\"34\":1}}],[\"事件冒泡到父元素\",{\"1\":{\"23\":1}}],[\"事件可以参考\",{\"1\":{\"20\":1}}],[\"因为window中我们无法获取到data返回对象中的数据\",{\"1\":{\"68\":1}}],[\"因为不会被浏览器渲染\",{\"1\":{\"66\":1}}],[\"因为对于列表中\",{\"1\":{\"36\":1}}],[\"因为目前我们还没有比较完整的学习组件的概念\",{\"1\":{\"34\":1}}],[\"因为v\",{\"1\":{\"26\":1}}],[\"认识计算属性\",{\"0\":{\"41\":1}}],[\"认识\",{\"0\":{\"34\":1,\"56\":1}}],[\"什么是渐进式框架呢\",{\"1\":{\"57\":1}}],[\"什么是\",{\"0\":{\"57\":1}}],[\"什么是侦听器\",{\"1\":{\"48\":1}}],[\"什么是计算属性呢\",{\"1\":{\"41\":1}}],[\"什么是vnode\",{\"1\":{\"33\":1}}],[\"什么是新旧nodes\",{\"1\":{\"33\":1}}],[\"销毁key不存在的元素\",{\"1\":{\"33\":1}}],[\"复制其中所有的代码\",{\"1\":{\"63\":1}}],[\"复制自己需要生成代码片段的代码\",{\"1\":{\"1\":1}}],[\"复用相同类型元素的算法\",{\"1\":{\"33\":1}}],[\"过滤掉长度小于等于2的电影\",{\"1\":{\"32\":1}}],[\"而在\",{\"1\":{\"59\":1}}],[\"而且模块划分的更加清晰\",{\"1\":{\"58\":1}}],[\"而且我们多次提到计算属性有缓存\",{\"1\":{\"46\":1}}],[\"而不需要在多个options之间寻找\",{\"1\":{\"60\":1}}],[\"而不一定需要全部使用vue来开发整个\",{\"1\":{\"57\":1}}],[\"而不是使用div来完成\",{\"1\":{\"31\":1}}],[\"而不是作为\",{\"1\":{\"10\":1}}],[\"而嵌套属性的变化不会触发\",{\"1\":{\"50\":1}}],[\"而计算属性虽然使用了多次\",{\"1\":{\"46\":1}}],[\"而进行重新计算\",{\"1\":{\"46\":1}}],[\"而是说\",{\"1\":{\"41\":1}}],[\"而是有一大堆的元素\",{\"1\":{\"35\":1}}],[\"而是会生成新的数组\",{\"1\":{\"32\":1}}],[\"而使用key时\",{\"1\":{\"33\":1}}],[\"替换数组的方法\",{\"1\":{\"32\":1}}],[\"元素\",{\"1\":{\"34\":1}}],[\"元素来循环渲染一段包含多个元素的内容\",{\"1\":{\"31\":1}}],[\"元素或者组件以及其所有的子元素将视为静态内容并且跳过\",{\"1\":{\"5\":1}}],[\"少年派\",{\"1\":{\"30\":1,\"32\":1}}],[\"教父\",{\"1\":{\"30\":1,\"32\":1}}],[\"大话西游\",{\"1\":{\"30\":1,\"32\":1}}],[\"大小等等\",{\"1\":{\"15\":1}}],[\"盗梦空间\",{\"1\":{\"30\":1,\"32\":1}}],[\"星际穿越\",{\"1\":{\"30\":1,\"32\":1}}],[\"遍历对象\",{\"1\":{\"30\":1}}],[\"遍历数组\",{\"1\":{\"30\":1}}],[\"每一个item都是一个数字\",{\"1\":{\"30\":1}}],[\"三个参数\",{\"1\":{\"30\":1}}],[\"三元运算符来决定结果\",{\"1\":{\"41\":1}}],[\"三元运算符\",{\"1\":{\"3\":2}}],[\"二个参数\",{\"1\":{\"30\":1}}],[\"索引项index是在后面的\",{\"1\":{\"30\":1}}],[\"切换\",{\"1\":{\"28\":1}}],[\"其他方式\",{\"0\":{\"51\":1}}],[\"其中键是需要侦听的响应式组件实例属性\",{\"1\":{\"48\":1}}],[\"其中一种方式就是将逻辑抽取到一个method中\",{\"1\":{\"41\":1}}],[\"其对应的元素压根不会被渲染到dom中\",{\"1\":{\"28\":1}}],[\"其次\",{\"1\":{\"28\":1}}],[\"其判断的内容完全不会被渲染或者会被销毁掉\",{\"1\":{\"26\":1}}],[\"首先\",{\"1\":{\"28\":1}}],[\"才会触发回调函数\",{\"1\":{\"50\":1}}],[\"才会真正渲染条件块中的内容\",{\"1\":{\"26\":1}}],[\"才会被渲染出来\",{\"1\":{\"25\":1}}],[\"结合使用\",{\"0\":{\"26\":1}}],[\"9\",{\"1\":{\"53\":1}}],[\"95\",{\"1\":{\"25\":1}}],[\"90\",{\"1\":{\"25\":1,\"46\":1}}],[\"条件渲染\",{\"0\":{\"24\":1}}],[\"继续执行父元素的事件处理函数\",{\"1\":{\"23\":1}}],[\"然后再冒泡到该元素的父元素\",{\"1\":{\"23\":1}}],[\"它们将会被逐一调用\",{\"1\":{\"51\":1}}],[\"它们最终在vue中表示出来的都是一个个vnode\",{\"1\":{\"34\":1}}],[\"它会在自己的上层作用于中来查找this\",{\"1\":{\"68\":1}}],[\"它会基于key的变化重新排列元素顺序\",{\"1\":{\"33\":1}}],[\"它会先执行该元素上的事件处理函数\",{\"1\":{\"23\":1}}],[\"它的dom实际都是有渲染的\",{\"1\":{\"28\":1}}],[\"它可以在组件编译完毕前隐藏原始模板\",{\"1\":{\"9\":1}}],[\"传入事件\",{\"1\":{\"22\":1}}],[\"时\",{\"1\":{\"22\":1}}],[\"同时又在同一个仓库下方便管理\",{\"1\":{\"58\":1}}],[\"同时需要\",{\"1\":{\"22\":1}}],[\"同名的\",{\"1\":{\"10\":1}}],[\"情况二\",{\"1\":{\"22\":1}}],[\"情况一\",{\"1\":{\"22\":1}}],[\"鼠标移动\",{\"1\":{\"21\":1}}],[\"按钮1发生了点击\",{\"1\":{\"21\":1}}],[\"监听的事件=\",{\"1\":{\"21\":1}}],[\"right\",{\"1\":{\"20\":1,\"23\":1}}],[\"repository\",{\"1\":{\"58\":1}}],[\"repository仓库\",{\"1\":{\"58\":1}}],[\"repo\",{\"1\":{\"58\":1}}],[\"removebook\",{\"1\":{\"53\":2}}],[\"rel=\",{\"1\":{\"53\":1}}],[\"result\",{\"1\":{\"45\":2,\"46\":4}}],[\"red\",{\"1\":{\"6\":1,\"13\":1,\"16\":3,\"17\":1}}],[\"reversemessage\",{\"1\":{\"45\":2}}],[\"reverse\",{\"1\":{\"3\":2,\"32\":1,\"43\":1,\"44\":1,\"45\":1}}],[\"return\",{\"1\":{\"2\":1,\"3\":3,\"5\":1,\"6\":1,\"11\":1,\"13\":2,\"14\":1,\"16\":2,\"17\":1,\"18\":1,\"19\":1,\"21\":1,\"22\":1,\"23\":1,\"25\":1,\"26\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1,\"44\":4,\"45\":4,\"46\":6,\"47\":3,\"49\":1,\"50\":1,\"51\":1,\"53\":5,\"66\":2}}],[\"reactivity\",{\"1\":{\"41\":1}}],[\"react\",{\"1\":{\"2\":1}}],[\"react使用的jsx\",{\"1\":{\"2\":1}}],[\"react的开发模式\",{\"1\":{\"2\":1}}],[\"lang=\",{\"1\":{\"53\":1}}],[\"lastname\",{\"1\":{\"42\":1,\"43\":1,\"44\":2,\"45\":2,\"46\":3,\"47\":4}}],[\"learn\",{\"0\":{\"71\":1}}],[\"let\",{\"1\":{\"53\":2}}],[\"letters\",{\"1\":{\"36\":3}}],[\"length\",{\"1\":{\"32\":1,\"53\":1}}],[\"left\",{\"1\":{\"20\":1,\"23\":1,\"53\":1}}],[\"li\",{\"1\":{\"36\":2}}],[\"li>\",{\"1\":{\"30\":3,\"31\":3,\"32\":1,\"36\":1}}],[\"link\",{\"1\":{\"10\":1,\"11\":2}}],[\"log\",{\"1\":{\"21\":2,\"22\":2,\"23\":3,\"46\":4,\"47\":1,\"49\":2,\"50\":2,\"51\":7,\"52\":1,\"68\":1}}],[\"只需要一个getter方法即可\",{\"1\":{\"47\":1}}],[\"只是通过css的display属性来进行\",{\"1\":{\"28\":1}}],[\"只当点击鼠标中键时触发\",{\"1\":{\"20\":1,\"23\":1}}],[\"只当点击鼠标右键时触发\",{\"1\":{\"20\":1,\"23\":1}}],[\"只当点击鼠标左键时触发\",{\"1\":{\"20\":1,\"23\":1}}],[\"只当事件是从侦听器绑定的元素本身触发时才触发回调\",{\"1\":{\"20\":1,\"23\":1}}],[\"只触发一次回调\",{\"1\":{\"20\":1,\"23\":1}}],[\"模式添加侦听器\",{\"1\":{\"20\":1,\"23\":1}}],[\"模式\",{\"1\":{\"20\":1,\"23\":1}}],[\"模板中有一些奇怪的语法\",{\"1\":{\"66\":1}}],[\"模板中表达式的初衷是用于简单的计算\",{\"1\":{\"43\":1}}],[\"模板中存在大量的复杂逻辑\",{\"1\":{\"43\":1}}],[\"模板\",{\"1\":{\"9\":1}}],[\"模板语法\",{\"0\":{\"2\":1}}],[\"添加事件侦听器时使用\",{\"1\":{\"20\":1,\"23\":1}}],[\"调用了getresult方法\",{\"1\":{\"46\":4}}],[\"调用了计算属性result的getter\",{\"1\":{\"46\":2}}],[\"调用\",{\"1\":{\"20\":2,\"23\":2}}],[\"调用一个方法\",{\"1\":{\"16\":1}}],[\"essential\",{\"0\":{\"70\":1}}],[\"examplex新建自己的文件夹以及测试demo\",{\"1\":{\"69\":1}}],[\"export\",{\"1\":{\"51\":1}}],[\"equiv=\",{\"1\":{\"53\":1}}],[\"e9e9e9\",{\"1\":{\"53\":2}}],[\"e\",{\"1\":{\"51\":3}}],[\"else一起使用\",{\"1\":{\"28\":1}}],[\"else>\",{\"1\":{\"26\":1,\"53\":1}}],[\"else>不及格<\",{\"1\":{\"25\":1}}],[\"else\",{\"1\":{\"24\":2,\"25\":5}}],[\"element函数调用\",{\"1\":{\"2\":1}}],[\"enterkeyup\",{\"1\":{\"23\":2}}],[\"enter=\",{\"1\":{\"23\":1}}],[\"en\",{\"1\":{\"20\":1,\"53\":1}}],[\"events\",{\"1\":{\"20\":1}}],[\"event\",{\"1\":{\"20\":4,\"22\":5,\"23\":4}}],[\"预期\",{\"1\":{\"20\":1}}],[\"键盘事件等等\",{\"1\":{\"20\":1}}],[\"拖拽\",{\"1\":{\"20\":1}}],[\"前端面试之彻底搞懂this指向\",{\"1\":{\"68\":1}}],[\"前端\",{\"1\":{\"65\":1}}],[\"前端我们无论绑定src\",{\"1\":{\"18\":1}}],[\"前面我们绑定了元素的内容和属性\",{\"1\":{\"20\":1}}],[\"案例\",{\"1\":{\"19\":1}}],[\"非常简单\",{\"1\":{\"19\":1}}],[\"属性直接绑定一个对象\",{\"0\":{\"19\":1}}],[\"属性名\",{\"1\":{\"18\":1}}],[\"属性名称都是固定的\",{\"1\":{\"18\":1}}],[\"kobe\",{\"1\":{\"18\":2,\"44\":1,\"45\":1,\"46\":1,\"47\":1,\"50\":3}}],[\"kebab\",{\"1\":{\"15\":2}}],[\"key=\",{\"1\":{\"36\":1}}],[\"key属性主要用在vue的虚拟dom算法\",{\"1\":{\"33\":1}}],[\"keyup\",{\"1\":{\"23\":2}}],[\"keyalias\",{\"1\":{\"20\":1,\"23\":1}}],[\"key\",{\"0\":{\"33\":1},\"1\":{\"10\":1,\"30\":4,\"31\":2,\"33\":1,\"42\":1,\"48\":1}}],[\"如filter\",{\"1\":{\"59\":1}}],[\"如何阅读vue源码\",{\"0\":{\"69\":1}}],[\"如何使用\",{\"0\":{\"61\":1}}],[\"如何基于key重新排列的\",{\"1\":{\"33\":1}}],[\"如何尝试修改和复用的\",{\"1\":{\"33\":1}}],[\"如下\",{\"1\":{\"18\":1,\"46\":1}}],[\"如果想侦听所有嵌套的变更\",{\"1\":{\"50\":1}}],[\"如果不使用key\",{\"1\":{\"33\":1}}],[\"如果不会频繁的发生切换\",{\"1\":{\"28\":1}}],[\"如果需要同时传入某个参数\",{\"1\":{\"22\":1}}],[\"如果方法本身中有一个参数\",{\"1\":{\"22\":1}}],[\"如果该方法不需要额外参数\",{\"1\":{\"22\":1}}],[\"如果属性名称不是固定的\",{\"1\":{\"18\":1}}],[\"如果存在同名的\",{\"1\":{\"10\":1}}],[\"如果我们确实想设置计算属性的值呢\",{\"1\":{\"47\":1}}],[\"如果我们不只是一个简单的div\",{\"1\":{\"35\":1}}],[\"如果我们需要索引\",{\"1\":{\"30\":1}}],[\"如果我们的元素需要在显示和隐藏之间频繁的切换\",{\"1\":{\"28\":1}}],[\"如果我们希望将一个对象的所有属性\",{\"1\":{\"19\":1}}],[\"如果我们希望这个内容被vue可以解析出来\",{\"1\":{\"6\":1}}],[\"如果我们希望把数据显示到模板\",{\"1\":{\"3\":1}}],[\"如果我们展示的内容本身是\",{\"1\":{\"6\":1}}],[\"如果是子节点的化\",{\"1\":{\"5\":1}}],[\"值是相应的回调函数\",{\"1\":{\"48\":1}}],[\"值\",{\"1\":{\"18\":1}}],[\"700\",{\"1\":{\"16\":2}}],[\"并且通过\",{\"1\":{\"68\":1}}],[\"并且应该可以通过this获取到data返回对象中的数据\",{\"1\":{\"68\":1}}],[\"并且该函数需要返回一个对象\",{\"1\":{\"67\":1}}],[\"并且标记它的类型为\",{\"1\":{\"66\":1}}],[\"并且ide很有可能没有任何提示\",{\"1\":{\"66\":1}}],[\"并且使用它\",{\"1\":{\"61\":1}}],[\"并且自己手动引入\",{\"1\":{\"61\":1}}],[\"并且它们还可以做到是响应式的\",{\"1\":{\"60\":1}}],[\"并且多个mixins会存在命名冲突的问题\",{\"1\":{\"60\":1}}],[\"并且\",{\"1\":{\"58\":1}}],[\"并且计算属性是有缓存的\",{\"1\":{\"45\":1}}],[\"并且如果多个地方都使用到\",{\"1\":{\"41\":1}}],[\"并且最后进行新增\",{\"1\":{\"37\":1}}],[\"并且会移除\",{\"1\":{\"33\":1}}],[\"并且支持有一二三个参数\",{\"1\":{\"30\":1}}],[\"并且需要对其进行渲染\",{\"1\":{\"29\":1}}],[\"并且在v\",{\"1\":{\"26\":1}}],[\"并且是一个对象\",{\"1\":{\"16\":1}}],[\"并且我们前端提到过\",{\"1\":{\"3\":1}}],[\"p>\",{\"1\":{\"49\":2}}],[\"padding\",{\"1\":{\"53\":1}}],[\"patchunkeyedchildren方法\",{\"1\":{\"37\":1}}],[\"patchkeyedchildren方法\",{\"1\":{\"37\":1}}],[\"passive\",{\"1\":{\"20\":2,\"23\":2}}],[\"pop\",{\"1\":{\"32\":1}}],[\"push\",{\"1\":{\"32\":2}}],[\"p\",{\"1\":{\"20\":1}}],[\"px\",{\"1\":{\"16\":1}}],[\"price\",{\"1\":{\"53\":10}}],[\"proxy\",{\"1\":{\"50\":1,\"59\":1}}],[\"props\",{\"1\":{\"10\":2,\"60\":1}}],[\"property\",{\"1\":{\"10\":4,\"15\":2}}],[\"prop\",{\"1\":{\"10\":5}}],[\"preventdefault\",{\"1\":{\"20\":1,\"23\":1}}],[\"prevent\",{\"1\":{\"20\":1,\"23\":1}}],[\"pre>\",{\"1\":{\"8\":1}}],[\"pre用于跳过元素和它的子元素的编译过程\",{\"1\":{\"8\":1}}],[\"pre\",{\"0\":{\"8\":1}}],[\"+=\",{\"1\":{\"53\":1}}],[\"+\",{\"1\":{\"16\":1,\"43\":1,\"44\":2,\"45\":2,\"46\":4,\"47\":4,\"53\":3}}],[\"flow\",{\"1\":{\"58\":1}}],[\"f7f7f7\",{\"1\":{\"53\":1}}],[\"fullname的getter和setter方法\",{\"1\":{\"47\":1}}],[\"fullname\",{\"1\":{\"45\":2,\"46\":9,\"47\":5}}],[\"function\",{\"1\":{\"2\":1,\"20\":1,\"42\":3,\"47\":2,\"48\":1,\"49\":1,\"50\":1,\"51\":3,\"52\":1,\"66\":2}}],[\"f\",{\"0\":{\"36\":1},\"1\":{\"36\":2,\"51\":2,\"68\":1}}],[\"firstname\",{\"1\":{\"42\":1,\"43\":1,\"44\":2,\"45\":2,\"46\":5,\"47\":4}}],[\"filterbooks\",{\"1\":{\"53\":1}}],[\"filter\",{\"1\":{\"32\":3}}],[\"finalprice\",{\"1\":{\"53\":3}}],[\"finalstyleobj\",{\"1\":{\"16\":2}}],[\"finalfontsize\",{\"1\":{\"16\":2}}],[\"finalcolor\",{\"1\":{\"16\":4}}],[\"foo2\",{\"1\":{\"68\":2}}],[\"foo\",{\"1\":{\"68\":2}}],[\"formatprice\",{\"1\":{\"53\":3}}],[\"for进行列表渲染时\",{\"1\":{\"33\":1}}],[\"for\",{\"0\":{\"33\":1},\"1\":{\"53\":1}}],[\"for=\",{\"1\":{\"30\":3,\"31\":1,\"32\":1,\"36\":1,\"53\":1}}],[\"for同时也支持数字的遍历\",{\"1\":{\"30\":1}}],[\"for也支持遍历对象\",{\"1\":{\"30\":1}}],[\"for支持的类型\",{\"1\":{\"30\":1}}],[\"for的基本格式是\",{\"1\":{\"30\":1}}],[\"for类似于javascript的for循环\",{\"1\":{\"29\":1}}],[\"for来完成\",{\"1\":{\"29\":1}}],[\"fontweight\",{\"1\":{\"16\":2}}],[\"fontsize\",{\"1\":{\"16\":2,\"17\":1}}],[\"font\",{\"1\":{\"16\":3,\"53\":1}}],[\"名短横线分隔\",{\"1\":{\"15\":1}}],[\"名可以用驼峰式\",{\"1\":{\"15\":1}}],[\"名称\",{\"1\":{\"10\":1}}],[\"来将一部分独立的逻辑抽取出去\",{\"1\":{\"60\":1}}],[\"来描述组件对象\",{\"1\":{\"60\":1}}],[\"来实现数据的劫持\",{\"1\":{\"59\":1}}],[\"来劫持数据的\",{\"1\":{\"59\":1}}],[\"来进行重构\",{\"1\":{\"58\":1}}],[\"来进行类型检测\",{\"1\":{\"58\":1}}],[\"来侦听\",{\"1\":{\"52\":1}}],[\"来阻止\",{\"1\":{\"23\":1}}],[\"来命名\",{\"1\":{\"15\":1}}],[\"来绑定一些css内联样式\",{\"1\":{\"15\":1}}],[\"来展示\",{\"1\":{\"6\":1}}],[\"列表渲染\",{\"0\":{\"29\":1}}],[\"列表\",{\"1\":{\"14\":1}}],[\"方式四\",{\"1\":{\"61\":1}}],[\"方式三\",{\"1\":{\"61\":1}}],[\"方式二\",{\"1\":{\"61\":1,\"66\":1}}],[\"方式一\",{\"1\":{\"61\":1,\"66\":1}}],[\"方法\",{\"1\":{\"59\":1}}],[\"方法的\",{\"1\":{\"59\":1}}],[\"方法中\",{\"1\":{\"13\":1}}],[\"方便我们快速生成\",{\"1\":{\"1\":1}}],[\"呵呵呵呵\",{\"1\":{\"13\":1}}],[\"以供\",{\"1\":{\"22\":1}}],[\"以应用一个\",{\"1\":{\"14\":1}}],[\"以动态地切换\",{\"1\":{\"13\":1}}],[\"以下为不使用深度监听\",{\"1\":{\"50\":1}}],[\"以下为内部判断\",{\"1\":{\"47\":1}}],[\"以下为错误写法\",{\"1\":{\"3\":1}}],[\"以下报错\",{\"1\":{\"11\":1}}],[\"对于任何包含响应式数据的复杂逻辑\",{\"1\":{\"41\":1}}],[\"对于相同父元素的子元素节点并不会重新渲染整个列\",{\"1\":{\"36\":1}}],[\"对象\",{\"1\":{\"19\":1}}],[\"对象语法\",{\"0\":{\"13\":1,\"16\":1},\"1\":{\"12\":1,\"13\":2,\"15\":1}}],[\"对应的内容也会发生更新\",{\"1\":{\"3\":1}}],[\"window\",{\"1\":{\"68\":4}}],[\"width\",{\"1\":{\"53\":1}}],[\"width=device\",{\"1\":{\"53\":1}}],[\"what\",{\"1\":{\"64\":1}}],[\"why\",{\"1\":{\"13\":1,\"19\":2,\"30\":1,\"31\":1,\"47\":1,\"50\":2,\"66\":4}}],[\"weixin\",{\"1\":{\"68\":1}}],[\"weight\",{\"1\":{\"53\":1}}],[\"web\",{\"0\":{\"73\":1},\"1\":{\"20\":1}}],[\"watch\",{\"0\":{\"48\":1},\"1\":{\"48\":2,\"49\":1,\"50\":5,\"51\":2,\"52\":1}}],[\"www\",{\"1\":{\"11\":1}}],[\"world\",{\"1\":{\"3\":1,\"14\":1,\"16\":1,\"17\":1,\"21\":1,\"22\":1,\"23\":1,\"42\":1,\"44\":1,\"45\":1,\"49\":1,\"66\":2}}],[\"ua\",{\"1\":{\"53\":1}}],[\"utf\",{\"1\":{\"53\":1}}],[\"unpkg\",{\"1\":{\"62\":1}}],[\"unix编程艺术\",{\"1\":{\"53\":1}}],[\"unwatch\",{\"1\":{\"52\":2}}],[\"undefined\",{\"1\":{\"50\":1}}],[\"underline\",{\"1\":{\"17\":1}}],[\"unshift\",{\"1\":{\"32\":1}}],[\"ul>\",{\"1\":{\"30\":3,\"31\":1,\"32\":1,\"36\":1}}],[\"us\",{\"1\":{\"20\":1}}],[\"u\",{\"1\":{\"11\":1}}],[\"global\",{\"1\":{\"69\":2}}],[\"g\",{\"1\":{\"69\":1}}],[\"githubusercontent\",{\"1\":{\"11\":1}}],[\"getresult\",{\"1\":{\"44\":2,\"46\":4}}],[\"getreversemessage\",{\"1\":{\"3\":2,\"44\":2}}],[\"getfullname\",{\"1\":{\"44\":2,\"46\":7}}],[\"getfinalstyleobj\",{\"1\":{\"16\":2}}],[\"get\",{\"1\":{\"42\":1,\"47\":1}}],[\"getter方法\",{\"1\":{\"47\":1}}],[\"getter\",{\"0\":{\"47\":1},\"1\":{\"41\":1,\"59\":1}}],[\"getclassobj\",{\"1\":{\"13\":2}}],[\"generator\",{\"1\":{\"1\":1}}],[\"是目前非常流行的架构模式\",{\"1\":{\"65\":1}}],[\"是在前期被使用非常框架的架构模式\",{\"1\":{\"65\":1}}],[\"是无法劫持和监听的\",{\"1\":{\"59\":1}}],[\"是使用\",{\"1\":{\"59\":1}}],[\"是一套用于构建用户界面的渐进式框架\",{\"1\":{\"57\":1}}],[\"是一个事件修饰符\",{\"1\":{\"23\":1}}],[\"是一个表达式\",{\"1\":{\"3\":1}}],[\"是什么作用\",{\"0\":{\"33\":1}}],[\"是过滤的意思\",{\"1\":{\"32\":1}}],[\"是允许template中有多个根元素\",{\"1\":{\"10\":2}}],[\"小知识\",{\"1\":{\"10\":1}}],[\"动态绑定属性\",{\"0\":{\"18\":1},\"1\":{\"18\":1}}],[\"动态地绑定一个或多个\",{\"1\":{\"10\":1}}],[\"动态的绑定一个或多个\",{\"1\":{\"10\":1}}],[\"绑定了\",{\"1\":{\"68\":1}}],[\"绑定事件监听\",{\"1\":{\"20\":1}}],[\"绑定一个对象\",{\"1\":{\"21\":1}}],[\"绑定一个表达式\",{\"1\":{\"21\":1}}],[\"绑定一个\",{\"1\":{\"19\":1}}],[\"绑定一个data中的属性值\",{\"1\":{\"16\":1}}],[\"绑定到元素上的所有属性\",{\"1\":{\"19\":1}}],[\"绑定class\",{\"1\":{\"14\":1}}],[\"绑定class有两种方式\",{\"1\":{\"12\":1,\"15\":1}}],[\"绑定\",{\"0\":{\"12\":1,\"15\":1}}],[\"绑定值对的对象\",{\"1\":{\"10\":1}}],[\"绑定时\",{\"1\":{\"10\":1}}],[\"所有\",{\"1\":{\"41\":1}}],[\"所有后续所有的内容都要一次进行改动\",{\"1\":{\"37\":1}}],[\"所绑定的\",{\"1\":{\"10\":1}}],[\"所以就是window\",{\"1\":{\"68\":1}}],[\"所以就会break跳出循环\",{\"1\":{\"37\":1}}],[\"所以在\",{\"1\":{\"59\":1}}],[\"所以这些属性在第一次调用时就是可用的\",{\"1\":{\"50\":1}}],[\"所以我们修改\",{\"1\":{\"67\":1}}],[\"所以我们在\",{\"1\":{\"67\":1}}],[\"所以我们会将计算属性直接写成一个函数\",{\"1\":{\"47\":1}}],[\"所以我们可以发现\",{\"1\":{\"38\":1}}],[\"所以我们一般会借助于一个在线工具来完成\",{\"1\":{\"1\":1}}],[\"所以\",{\"1\":{\"37\":1}}],[\"所以目前我们先理解html元素创建出来的vnode\",{\"1\":{\"34\":1}}],[\"所以它们也将会触发视图更新\",{\"1\":{\"32\":1}}],[\"所以必须将其添加到一个元素上\",{\"1\":{\"26\":1}}],[\"所以对应的代码都是编写的类似于js的一种语法\",{\"1\":{\"2\":1}}],[\"特别是在和自定义元素打交道时\",{\"1\":{\"10\":1}}],[\"有无key的结论\",{\"0\":{\"38\":1},\"1\":{\"38\":1}}],[\"有key的操作过程\",{\"1\":{\"37\":1}}],[\"有key的时候\",{\"1\":{\"33\":1}}],[\"有key\",{\"1\":{\"37\":1}}],[\"有点类似于小程序中的block\",{\"1\":{\"26\":1}}],[\"有时候我们的元素\",{\"1\":{\"12\":1}}],[\"有时这是必要的\",{\"1\":{\"10\":1}}],[\"有些代码片段是需要经常写的\",{\"1\":{\"1\":1}}],[\"和\",{\"0\":{\"26\":1,\"47\":1},\"1\":{\"10\":1,\"32\":1,\"41\":1,\"42\":1,\"50\":1,\"59\":2}}],[\"和底层组件实例的数据绑定在\",{\"1\":{\"2\":1}}],[\"这里涉及到箭头函数使用this的查找规则\",{\"1\":{\"68\":1}}],[\"这里其实涉及到两种不同的编程范式命令式编程和声明式编程\",{\"1\":{\"64\":1}}],[\"这样做的目的是多个包本身相互独立\",{\"1\":{\"58\":1}}],[\"这样的\",{\"1\":{\"9\":1}}],[\"这是因为计算属性会基于它们的依赖关系进行缓存\",{\"1\":{\"46\":1}}],[\"这种方式一致存在一个缺陷就是当给对象添加或者删除属性时\",{\"1\":{\"59\":1}}],[\"这种做法有一个直观的弊端\",{\"1\":{\"41\":1}}],[\"这种绑定的方式\",{\"1\":{\"18\":1}}],[\"这次更新对于ul和button是不需要进行更新\",{\"1\":{\"36\":1}}],[\"这次因为某些样式我们需要根据数据动态来决定\",{\"1\":{\"15\":1}}],[\"这些方法可以被绑定到\",{\"1\":{\"68\":1}}],[\"这些都是模板特有的语法\",{\"1\":{\"66\":1}}],[\"这些标签会替换掉我们挂载到的元素\",{\"1\":{\"66\":1}}],[\"这些被包裹过的方法包括\",{\"1\":{\"32\":1}}],[\"这些内容只有在条件为true时\",{\"1\":{\"25\":1}}],[\"这三个指令与javascript的条件语句if\",{\"1\":{\"25\":1}}],[\"这个数据通过插值语法等方式绑定到template中\",{\"1\":{\"48\":1}}],[\"这个后面讲setter和getter时会讲到\",{\"1\":{\"45\":1}}],[\"这个案例是当我点击按钮时会在中间插入一个f\",{\"1\":{\"36\":1}}],[\"这个key属性有什么作用呢\",{\"1\":{\"33\":1}}],[\"这个别名可以自定来定义\",{\"1\":{\"30\":1}}],[\"这个时候无论后面数据是否有变化\",{\"1\":{\"50\":1}}],[\"这个时候就需要用侦听器watch来完成了\",{\"1\":{\"48\":1}}],[\"这个时候我们也可以给计算属性设置一个setter的方法\",{\"1\":{\"47\":1}}],[\"这个时候我们可以使用v\",{\"1\":{\"29\":1}}],[\"这个时候我们就需要进行条件判断了\",{\"1\":{\"24\":1}}],[\"这个时候\",{\"1\":{\"20\":1,\"26\":1}}],[\"这个行为在大多数情况都符合期望的绑定值类型\",{\"1\":{\"10\":1}}],[\"设置id\",{\"1\":{\"66\":1}}],[\"设置\",{\"1\":{\"10\":1}}],[\"赋值\",{\"1\":{\"10\":1}}],[\"会调用多次\",{\"1\":{\"46\":1}}],[\"会尽量利用我们的key来进行优化操作\",{\"1\":{\"38\":1}}],[\"会将它作为\",{\"1\":{\"10\":1}}],[\"会保留在所绑定的元素上\",{\"1\":{\"9\":1}}],[\"则\",{\"1\":{\"10\":1}}],[\"默认是浅层的\",{\"1\":{\"50\":1}}],[\"默认传入event对象\",{\"1\":{\"22\":1}}],[\"默认的class和动态的class结合\",{\"1\":{\"13\":1}}],[\"默认会利用\",{\"1\":{\"10\":1}}],[\"默认情况下我们的侦听器只会针对监听的数据本身的改变\",{\"1\":{\"50\":1}}],[\"默认情况下\",{\"1\":{\"6\":1}}],[\"详见下方的指南链接\",{\"1\":{\"10\":1}}],[\"详细信息\",{\"1\":{\"9\":1}}],[\"或短横线分隔\",{\"1\":{\"15\":1}}],[\"或一个组件\",{\"1\":{\"10\":1}}],[\"或\",{\"1\":{\"10\":1,\"48\":1,\"59\":1}}],[\"或者自己深拷贝一份作为保存\",{\"1\":{\"50\":1}}],[\"或者需要将多个数据结合起来进行显示\",{\"1\":{\"41\":1}}],[\"或者\",{\"1\":{\"10\":1}}],[\"强制绑定为\",{\"1\":{\"10\":2}}],[\"转变为驼峰式命名\",{\"1\":{\"10\":1}}],[\"将代码复制到其中\",{\"1\":{\"63\":1}}],[\"将\",{\"1\":{\"50\":1}}],[\"将被侦听的数组的变更方法进行了包裹\",{\"1\":{\"32\":1}}],[\"将返回的对象放到一个methods\",{\"1\":{\"13\":1}}],[\"将对象放到一个单独的属性中\",{\"1\":{\"13\":1}}],[\"将短横线命名的\",{\"1\":{\"10\":1}}],[\"将不可见\",{\"1\":{\"9\":1}}],[\"参数传递\",{\"0\":{\"22\":1}}],[\"参数\",{\"1\":{\"10\":1,\"20\":1}}],[\"不使用箭头函数的情况下\",{\"1\":{\"68\":1}}],[\"不可以是window\",{\"1\":{\"68\":1}}],[\"不得不提供一些特殊的api\",{\"1\":{\"59\":1}}],[\"不能侦听到旧值\",{\"1\":{\"50\":1}}],[\"不管多深都会侦听到\",{\"1\":{\"50\":1}}],[\"不及格\",{\"1\":{\"43\":1,\"44\":1,\"45\":1,\"46\":2}}],[\"不便于维护\",{\"1\":{\"43\":1}}],[\"不一定一一对应\",{\"1\":{\"35\":1}}],[\"不带参数\",{\"1\":{\"10\":1}}],[\"不常用指令\",{\"0\":{\"4\":1}}],[\"obj2\",{\"1\":{\"68\":2}}],[\"obj\",{\"1\":{\"68\":2}}],[\"object\",{\"1\":{\"10\":1,\"20\":1,\"30\":3,\"48\":1,\"50\":1,\"53\":1,\"59\":1}}],[\"of\",{\"1\":{\"53\":1}}],[\"options\",{\"1\":{\"51\":1,\"60\":2}}],[\"or\",{\"1\":{\"50\":1}}],[\"org\",{\"1\":{\"20\":1,\"33\":1,\"41\":1,\"51\":1,\"52\":1}}],[\"old\",{\"1\":{\"51\":2}}],[\"oldval\",{\"1\":{\"51\":7}}],[\"oldvalue\",{\"1\":{\"49\":2,\"50\":3}}],[\"oldvalue变化前的旧值\",{\"1\":{\"49\":1}}],[\"oldinfo\",{\"1\":{\"50\":4,\"52\":2}}],[\"on支持修饰符\",{\"1\":{\"23\":1}}],[\"on=\",{\"1\":{\"21\":1}}],[\"on的用法\",{\"1\":{\"20\":1}}],[\"on指令\",{\"1\":{\"20\":1}}],[\"on绑定事件\",{\"1\":{\"20\":1}}],[\"on\",{\"0\":{\"20\":1,\"23\":1},\"1\":{\"21\":3}}],[\"once\",{\"1\":{\"20\":1,\"23\":1}}],[\"once用于指定元素或者组件只渲染一次\",{\"1\":{\"5\":1}}],[\"once指令\",{\"0\":{\"5\":1}}],[\"once>\",{\"1\":{\"2\":1,\"5\":3}}],[\"|\",{\"1\":{\"10\":1,\"20\":2,\"42\":1,\"48\":3}}],[\"带参数\",{\"1\":{\"10\":1}}],[\"期望\",{\"1\":{\"10\":1}}],[\"修饰符相当于对事件进行了一些特殊的处理\",{\"1\":{\"23\":1}}],[\"修饰符来强制绑定方式\",{\"1\":{\"10\":1}}],[\"修饰符\",{\"1\":{\"10\":2,\"20\":1}}],[\"缩写\",{\"1\":{\"10\":1,\"20\":1}}],[\"规则\",{\"1\":{\"9\":1}}],[\"npm\",{\"1\":{\"69\":2}}],[\"next\",{\"1\":{\"62\":1}}],[\"newitem\",{\"1\":{\"53\":3}}],[\"newinfo\",{\"1\":{\"50\":4,\"52\":2}}],[\"new\",{\"1\":{\"51\":1}}],[\"newvalue变化后的新值\",{\"1\":{\"49\":1}}],[\"newvalue\",{\"1\":{\"47\":3,\"49\":2,\"50\":3}}],[\"newmovie\",{\"1\":{\"32\":4}}],[\"nba\",{\"1\":{\"50\":4}}],[\"node\",{\"1\":{\"34\":1}}],[\"none\",{\"1\":{\"9\":2}}],[\"num\",{\"1\":{\"30\":2}}],[\"n\",{\"1\":{\"30\":1}}],[\"name<\",{\"1\":{\"50\":2}}],[\"names\",{\"1\":{\"47\":3}}],[\"name=\",{\"1\":{\"19\":1,\"53\":1}}],[\"name\",{\"1\":{\"3\":2,\"18\":2,\"19\":1,\"22\":2,\"30\":1,\"31\":1,\"50\":8,\"53\":5}}],[\"直到编译完成前\",{\"1\":{\"9\":1}}],[\"直到相关组件实例被挂载后才移除\",{\"1\":{\"9\":1}}],[\"直到挂载的组件将它们替换为实际渲染的内容\",{\"1\":{\"9\":1}}],[\"直接通过vue\",{\"1\":{\"61\":1}}],[\"直接\",{\"1\":{\"1\":1}}],[\"用法如下\",{\"1\":{\"48\":1}}],[\"用法\",{\"1\":{\"10\":1,\"20\":1}}],[\"用途\",{\"1\":{\"10\":1}}],[\"用户可能先看到的是还没编译完成的双大括号标签\",{\"1\":{\"9\":1}}],[\"用于声明在数据更改时调用的侦听回调\",{\"1\":{\"48\":1}}],[\"用于阻止事件冒泡\",{\"1\":{\"23\":1}}],[\"用于隐藏尚未完成编译的\",{\"1\":{\"9\":1}}],[\"用于更新元素的\",{\"1\":{\"7\":1}}],[\"未编译模板闪现\",{\"1\":{\"9\":1}}],[\"可扩展性更强\",{\"1\":{\"58\":1}}],[\"可维护性\",{\"1\":{\"58\":1}}],[\"可以从对象中获取到数据\",{\"1\":{\"67\":1}}],[\"可以直接打开cdn的链接\",{\"1\":{\"63\":1}}],[\"可以有自己的功能逻辑\",{\"1\":{\"58\":1}}],[\"可以在组件上使用以实现双向绑定\",{\"1\":{\"54\":1}}],[\"可以在方法中获取\",{\"1\":{\"22\":1}}],[\"可以利用\",{\"1\":{\"50\":1}}],[\"可以\",{\"1\":{\"41\":1}}],[\"可以非常方便的实现\",{\"1\":{\"41\":1}}],[\"可以用于描述某一个标签\",{\"1\":{\"34\":1}}],[\"可以用于遍历一组数据\",{\"1\":{\"29\":1}}],[\"可以用于绑定一个包含了多个\",{\"1\":{\"10\":1}}],[\"可以使用格式\",{\"1\":{\"30\":1}}],[\"可以使用\",{\"1\":{\"23\":1}}],[\"可以使用computed\",{\"1\":{\"3\":1}}],[\"可以阻止事件继续冒泡到父元素\",{\"1\":{\"23\":1}}],[\"可以通过\",{\"1\":{\"22\":1}}],[\"可以不添加\",{\"1\":{\"22\":1}}],[\"可以嵌套对象语法\",{\"1\":{\"14\":1}}],[\"可选的\",{\"1\":{\"10\":1}}],[\"可能会出现一种叫做\",{\"1\":{\"9\":1}}],[\"加快编译的速度\",{\"1\":{\"8\":1}}],[\"跳过不需要编译的节点\",{\"1\":{\"8\":1}}],[\"显示原始的mustache标签\",{\"1\":{\"8\":1}}],[\"等价于\",{\"1\":{\"7\":1}}],[\"那么这个this就会是window了\",{\"1\":{\"68\":1}}],[\"那么这个this是必须有值的\",{\"1\":{\"68\":1}}],[\"那么我们这个this能不能是window呢\",{\"1\":{\"68\":1}}],[\"那么会有大量重复的代码\",{\"1\":{\"41\":1}}],[\"那么会默认将原生事件event参数传递进去\",{\"1\":{\"22\":1}}],[\"那么就移除旧节点\",{\"1\":{\"37\":1}}],[\"那么就新增节点\",{\"1\":{\"37\":1}}],[\"那么就使用\",{\"1\":{\"37\":1}}],[\"那么久使用\",{\"1\":{\"37\":1}}],[\"那么vue中对于列表的更新究竟是如何操作的呢\",{\"1\":{\"36\":1}}],[\"那么vue并不会对其进行特殊的解析\",{\"1\":{\"6\":1}}],[\"那么它们应该会形成一个\",{\"1\":{\"35\":1}}],[\"那么使用v\",{\"1\":{\"28\":2}}],[\"那么方法后的\",{\"1\":{\"22\":1}}],[\"那么可以使用\",{\"1\":{\"6\":1}}],[\"也会发生改变\",{\"1\":{\"67\":1}}],[\"也增加了\",{\"1\":{\"59\":1}}],[\"也需要多次计算\",{\"1\":{\"44\":1}}],[\"也就是虚拟节点\",{\"1\":{\"34\":1}}],[\"也是根据一个条件决定是否显示元素或者组件\",{\"1\":{\"27\":1}}],[\"也只能渲染一次\",{\"1\":{\"5\":1}}],[\"也可以传入一个对象\",{\"1\":{\"67\":1}}],[\"也可以有多个键值对\",{\"1\":{\"13\":1}}],[\"也可以是其他方式\",{\"1\":{\"30\":1}}],[\"也可以是组件的\",{\"1\":{\"10\":1}}],[\"也可以是一个javascript的表达式\",{\"1\":{\"3\":1}}],[\"也可以调用函数\",{\"1\":{\"3\":1}}],[\"assign\",{\"1\":{\"53\":1}}],[\"align\",{\"1\":{\"53\":1}}],[\"alt=\",{\"1\":{\"10\":3,\"11\":3,\"18\":1}}],[\"anwser\",{\"1\":{\"49\":3}}],[\"any\",{\"1\":{\"10\":1}}],[\"array\",{\"1\":{\"48\":1}}],[\"area\",{\"1\":{\"21\":3}}],[\"a和b是一致的会继续进行比较\",{\"1\":{\"37\":1}}],[\"a\",{\"1\":{\"36\":2,\"51\":3}}],[\"api可以将\",{\"1\":{\"60\":1}}],[\"api\",{\"0\":{\"39\":1},\"1\":{\"33\":1,\"41\":1,\"51\":1,\"52\":1,\"60\":4}}],[\"app\",{\"1\":{\"1\":1,\"3\":5,\"5\":6,\"6\":5,\"8\":1,\"10\":1,\"11\":5,\"13\":6,\"14\":6,\"16\":6,\"17\":6,\"18\":6,\"19\":6,\"21\":6,\"22\":6,\"23\":6,\"25\":5,\"26\":6,\"27\":1,\"28\":1,\"30\":6,\"31\":6,\"32\":6,\"36\":6,\"43\":1,\"44\":5,\"45\":5,\"46\":11,\"47\":5,\"49\":6,\"50\":6,\"53\":4,\"66\":4}}],[\"addmovie\",{\"1\":{\"32\":2}}],[\"age\",{\"1\":{\"19\":1,\"22\":2,\"30\":1,\"31\":1,\"50\":2}}],[\"age=\",{\"1\":{\"19\":1}}],[\"active\",{\"1\":{\"13\":8,\"14\":3}}],[\"avatars\",{\"1\":{\"11\":1}}],[\"a>\",{\"1\":{\"10\":1,\"11\":1,\"18\":1}}],[\"attr\",{\"1\":{\"10\":2}}],[\"attrorprop\",{\"1\":{\"10\":1}}],[\"attributes\",{\"1\":{\"33\":1}}],[\"attribute\",{\"1\":{\"10\":7}}],[\"abc\",{\"1\":{\"3\":2,\"5\":1,\"13\":4,\"14\":4}}],[\"错误用法\",{\"1\":{\"3\":1}}],[\"=>\",{\"1\":{\"32\":1,\"51\":1,\"53\":1,\"68\":1}}],[\"=\",{\"1\":{\"3\":4,\"5\":1,\"6\":1,\"11\":1,\"13\":3,\"14\":1,\"16\":1,\"17\":1,\"18\":3,\"19\":2,\"21\":2,\"22\":1,\"23\":1,\"25\":1,\"26\":2,\"30\":1,\"31\":1,\"32\":3,\"36\":1,\"44\":1,\"45\":1,\"46\":3,\"47\":5,\"49\":2,\"50\":4,\"51\":1,\"52\":1,\"53\":3,\"68\":3}}],[\"bryant\",{\"1\":{\"44\":1,\"45\":1,\"46\":1,\"47\":1}}],[\"b\",{\"1\":{\"36\":2,\"51\":3}}],[\"built\",{\"1\":{\"33\":1}}],[\"button>\",{\"1\":{\"3\":1,\"5\":3,\"13\":1,\"21\":3,\"22\":2,\"23\":2,\"26\":1,\"32\":1,\"36\":1,\"46\":1,\"47\":1,\"49\":1,\"50\":3,\"53\":3,\"66\":4}}],[\"btnclick\",{\"1\":{\"23\":4}}],[\"btn2click\",{\"1\":{\"22\":2}}],[\"btn1click\",{\"1\":{\"21\":5,\"22\":2}}],[\"book\",{\"1\":{\"53\":9}}],[\"books\",{\"1\":{\"53\":8}}],[\"boolean\",{\"1\":{\"13\":1}}],[\"border\",{\"1\":{\"53\":4}}],[\"body\",{\"1\":{\"17\":1}}],[\"body>\",{\"1\":{\"13\":1,\"14\":1,\"16\":1,\"18\":1,\"19\":1,\"21\":1,\"22\":1,\"23\":1,\"26\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1,\"46\":1,\"49\":1,\"50\":1,\"53\":1,\"66\":2}}],[\"bar\",{\"1\":{\"68\":5}}],[\"baidu\",{\"1\":{\"11\":1}}],[\"backgroundcolor\",{\"1\":{\"16\":2}}],[\"background\",{\"1\":{\"6\":1,\"53\":1}}],[\"blue\",{\"1\":{\"6\":1}}],[\"bind=\",{\"1\":{\"19\":1}}],[\"bind提供一个语法糖\",{\"1\":{\"10\":1,\"11\":1}}],[\"bind的基本使用\",{\"1\":{\"10\":1,\"11\":1}}],[\"bind\",{\"0\":{\"10\":1},\"1\":{\"2\":1,\"10\":3,\"11\":2,\"13\":1,\"15\":1,\"19\":1,\"68\":1}}],[\"哈哈哈\",{\"1\":{\"3\":2}}],[\"计算属性在大多数情况下\",{\"1\":{\"47\":1}}],[\"计算属性的\",{\"0\":{\"47\":1}}],[\"计算属性的用法\",{\"1\":{\"42\":1}}],[\"计算属性依然会重新进行计算\",{\"1\":{\"46\":1}}],[\"计算属性是不需要重新计算的\",{\"1\":{\"46\":1}}],[\"计算属性是有缓存的\",{\"1\":{\"46\":1}}],[\"计算属性会随着依赖的数据\",{\"1\":{\"46\":1}}],[\"计算属性中的运算只会执行一次\",{\"1\":{\"46\":1}}],[\"计算属性和methods的差异\",{\"1\":{\"46\":1}}],[\"计算属性看起来像是一个函数\",{\"1\":{\"45\":1}}],[\"计算属性将被混入到组件实例中\",{\"1\":{\"41\":1}}],[\"计算属性\",{\"0\":{\"46\":1},\"1\":{\"3\":1,\"50\":1}}],[\"james\",{\"1\":{\"50\":1}}],[\"javascript\",{\"1\":{\"49\":1,\"66\":1}}],[\"js和vue\",{\"1\":{\"69\":1}}],[\"json中的dev后加上\",{\"1\":{\"69\":1}}],[\"js或者vuejs\",{\"1\":{\"57\":1}}],[\"js\",{\"1\":{\"3\":2,\"5\":2,\"6\":2,\"13\":2,\"14\":2,\"16\":2,\"17\":2,\"18\":2,\"19\":2,\"21\":2,\"22\":2,\"23\":3,\"25\":2,\"26\":2,\"30\":2,\"31\":2,\"32\":2,\"36\":2,\"44\":2,\"45\":2,\"46\":4,\"47\":2,\"49\":2,\"50\":2,\"53\":3,\"63\":3,\"66\":4,\"69\":1}}],[\"jsx\",{\"1\":{\"2\":1}}],[\"join\",{\"1\":{\"3\":2,\"43\":1,\"44\":1,\"45\":1}}],[\"s\",{\"1\":{\"68\":1}}],[\"slot编译优化\",{\"1\":{\"59\":1}}],[\"slice\",{\"1\":{\"32\":1}}],[\"sourcemap\",{\"1\":{\"69\":1}}],[\"solid\",{\"1\":{\"53\":2}}],[\"something\",{\"1\":{\"51\":1}}],[\"somemethod\",{\"1\":{\"51\":2}}],[\"sort\",{\"1\":{\"32\":1}}],[\"set\",{\"1\":{\"42\":1,\"47\":1}}],[\"setter\",{\"0\":{\"47\":1},\"1\":{\"41\":1,\"59\":1}}],[\"self\",{\"1\":{\"20\":1,\"23\":1}}],[\"shift\",{\"1\":{\"32\":1}}],[\"show元素无论是否需要显示到浏览器上\",{\"1\":{\"28\":1}}],[\"show不可以和v\",{\"1\":{\"28\":1}}],[\"show是不支持template\",{\"1\":{\"28\":1}}],[\"show=\",{\"1\":{\"27\":1,\"28\":1}}],[\"show和v\",{\"0\":{\"28\":1},\"1\":{\"27\":1}}],[\"show\",{\"0\":{\"27\":1},\"1\":{\"24\":1,\"28\":1}}],[\"script标签\",{\"1\":{\"66\":1}}],[\"script>\",{\"1\":{\"3\":2,\"5\":2,\"6\":2,\"11\":1,\"13\":2,\"14\":2,\"16\":2,\"17\":2,\"18\":2,\"19\":2,\"21\":2,\"22\":2,\"23\":2,\"25\":2,\"26\":2,\"30\":2,\"31\":2,\"32\":2,\"36\":2,\"44\":2,\"45\":2,\"46\":4,\"47\":2,\"49\":2,\"50\":2,\"53\":3,\"62\":1,\"63\":1,\"66\":5}}],[\"scale=1\",{\"1\":{\"53\":1}}],[\"score\",{\"1\":{\"25\":4,\"42\":1,\"43\":1,\"44\":2,\"45\":2,\"46\":5}}],[\"state\",{\"1\":{\"51\":1}}],[\"statement\",{\"1\":{\"20\":1,\"21\":1}}],[\"string\",{\"1\":{\"42\":1,\"48\":2}}],[\"stop=\",{\"1\":{\"23\":1}}],[\"stoppropagation\",{\"1\":{\"20\":1,\"23\":3}}],[\"stop\",{\"1\":{\"20\":1,\"23\":2}}],[\"stylesheet\",{\"1\":{\"53\":1}}],[\"style2obj\",{\"1\":{\"17\":2}}],[\"style1obj\",{\"1\":{\"17\":2}}],[\"style>\",{\"1\":{\"13\":1}}],[\"style\",{\"0\":{\"15\":1},\"1\":{\"10\":1,\"15\":1,\"18\":1,\"53\":1}}],[\"style=\",{\"1\":{\"6\":1,\"16\":6,\"17\":1}}],[\"size\",{\"1\":{\"16\":3}}],[\"s=60\",{\"1\":{\"11\":1}}],[\"spacing\",{\"1\":{\"53\":1}}],[\"span>\",{\"1\":{\"6\":1,\"53\":1}}],[\"special\",{\"1\":{\"33\":1}}],[\"splice\",{\"1\":{\"32\":1,\"36\":1,\"53\":1}}],[\"split\",{\"1\":{\"3\":2,\"43\":1,\"44\":1,\"45\":1,\"47\":1}}],[\"src=\",{\"1\":{\"3\":1,\"5\":1,\"6\":1,\"10\":3,\"11\":3,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":2,\"19\":1,\"21\":1,\"22\":1,\"23\":1,\"25\":1,\"26\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1,\"44\":1,\"45\":1,\"46\":2,\"47\":1,\"49\":1,\"50\":1,\"53\":2,\"62\":1,\"63\":1,\"66\":2}}],[\"snippet\",{\"1\":{\"1\":1}}],[\"hym0jgbi25grng\",{\"1\":{\"68\":1}}],[\"how\",{\"1\":{\"64\":2}}],[\"hooks函数增加代码的复用性\",{\"1\":{\"60\":1}}],[\"hack\",{\"1\":{\"59\":1}}],[\"handle\",{\"1\":{\"51\":1}}],[\"handle3\",{\"1\":{\"51\":2}}],[\"handle2\",{\"1\":{\"51\":2}}],[\"handle1\",{\"1\":{\"51\":2}}],[\"handler\",{\"1\":{\"50\":1,\"51\":3}}],[\"head>\",{\"1\":{\"53\":1}}],[\"height\",{\"1\":{\"19\":1,\"30\":1,\"31\":1}}],[\"height=\",{\"1\":{\"19\":1}}],[\"hello\",{\"1\":{\"3\":1,\"14\":1,\"16\":1,\"17\":1,\"21\":1,\"22\":1,\"23\":1,\"44\":1,\"45\":1,\"49\":1,\"66\":2}}],[\"href\",{\"1\":{\"18\":1}}],[\"href=\",{\"1\":{\"10\":1,\"11\":1,\"18\":1,\"53\":1}}],[\"http\",{\"1\":{\"53\":1}}],[\"https\",{\"1\":{\"1\":1,\"11\":2,\"20\":1,\"33\":1,\"41\":1,\"51\":1,\"52\":1,\"62\":1,\"68\":1}}],[\"html>\",{\"1\":{\"53\":2}}],[\"html=\",{\"1\":{\"6\":1}}],[\"html\",{\"0\":{\"6\":1},\"1\":{\"6\":2,\"33\":1,\"41\":1,\"51\":1,\"52\":1}}],[\"h2>\",{\"1\":{\"3\":7,\"5\":6,\"7\":2,\"8\":1,\"25\":3,\"26\":6,\"27\":1,\"28\":2,\"30\":3,\"32\":1,\"43\":3,\"44\":3,\"45\":3,\"46\":20,\"47\":1,\"50\":1,\"53\":2,\"66\":4}}],[\">hhhh<\",{\"1\":{\"66\":1}}],[\">移除<\",{\"1\":{\"53\":1}}],[\">+<\",{\"1\":{\"53\":1}}],[\">+1<\",{\"1\":{\"5\":3,\"66\":2}}],[\">改变info\",{\"1\":{\"50\":2}}],[\">改变info<\",{\"1\":{\"50\":1}}],[\">查找答案<\",{\"1\":{\"49\":1}}],[\">修改fullname<\",{\"1\":{\"47\":1}}],[\">修改firstname<\",{\"1\":{\"46\":1}}],[\">=\",{\"1\":{\"43\":1,\"44\":1,\"45\":1,\"46\":2}}],[\">插入f元素<\",{\"1\":{\"36\":1}}],[\">添加电影<\",{\"1\":{\"32\":1}}],[\">良好<\",{\"1\":{\"25\":1}}],[\">优秀<\",{\"1\":{\"25\":1}}],[\">按钮<\",{\"1\":{\"23\":2}}],[\">按钮2<\",{\"1\":{\"22\":1}}],[\">按钮1<\",{\"1\":{\"21\":2,\"22\":1}}],[\">div<\",{\"1\":{\"21\":1}}],[\">呵呵呵呵<\",{\"1\":{\"13\":4,\"16\":2,\"28\":1}}],[\">哈哈哈哈<\",{\"1\":{\"13\":1,\"14\":3,\"16\":3,\"19\":3,\"27\":1,\"28\":1}}],[\">哈哈哈<\",{\"1\":{\"6\":1,\"17\":1,\"18\":2}}],[\">百度一下<\",{\"1\":{\"10\":1,\"11\":1}}],[\"><\",{\"1\":{\"3\":1,\"5\":2,\"6\":2,\"7\":1,\"13\":2,\"14\":2,\"16\":2,\"17\":2,\"18\":3,\"19\":2,\"21\":4,\"22\":2,\"23\":2,\"25\":1,\"26\":2,\"30\":2,\"31\":3,\"32\":2,\"36\":2,\"44\":1,\"45\":1,\"46\":3,\"47\":1,\"49\":2,\"50\":2,\"53\":3,\"62\":1,\"63\":1,\"66\":3}}],[\">切换<\",{\"1\":{\"3\":1,\"13\":1,\"26\":1}}],[\">\",{\"1\":{\"3\":7,\"5\":1,\"6\":1,\"7\":1,\"8\":2,\"10\":8,\"11\":7,\"13\":7,\"14\":3,\"16\":4,\"17\":1,\"18\":3,\"19\":2,\"21\":6,\"22\":3,\"23\":3,\"25\":4,\"26\":2,\"27\":1,\"28\":1,\"30\":6,\"31\":2,\"32\":4,\"36\":2,\"43\":2,\"44\":1,\"45\":1,\"46\":5,\"47\":1,\"49\":2,\"50\":2,\"53\":11,\"66\":4}}],[\"mp\",{\"1\":{\"68\":1}}],[\"mvvm是\",{\"1\":{\"65\":1}}],[\"mvvm模型\",{\"0\":{\"65\":1}}],[\"mvc是\",{\"1\":{\"65\":1}}],[\"mvc和mvvm都是一种软件的体系结构\",{\"1\":{\"65\":1}}],[\"mixins也是由一大堆的options组成的\",{\"1\":{\"60\":1}}],[\"middle\",{\"1\":{\"20\":1,\"23\":1}}],[\"map\",{\"1\":{\"53\":1,\"69\":1}}],[\"margin\",{\"1\":{\"53\":1}}],[\"mono\",{\"1\":{\"58\":1}}],[\"model\",{\"0\":{\"54\":1},\"1\":{\"54\":1,\"65\":2}}],[\"model=\",{\"1\":{\"25\":1,\"32\":1,\"46\":1,\"49\":1}}],[\"movies\",{\"1\":{\"30\":2,\"32\":5}}],[\"movie\",{\"1\":{\"30\":2,\"32\":2}}],[\"mousemove\",{\"1\":{\"21\":6}}],[\"mousemove=\",{\"1\":{\"21\":1}}],[\"mount\",{\"1\":{\"3\":1,\"5\":1,\"6\":1,\"11\":1,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"21\":1,\"22\":1,\"23\":1,\"25\":1,\"26\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1,\"44\":1,\"45\":1,\"46\":2,\"47\":1,\"49\":1,\"50\":1,\"53\":1,\"66\":2}}],[\"mozilla\",{\"1\":{\"20\":1}}],[\"msg\",{\"1\":{\"6\":3}}],[\"methods属性是一个对象\",{\"1\":{\"68\":1}}],[\"methods属性\",{\"0\":{\"68\":1}}],[\"methods的getfullname中的计算\",{\"1\":{\"46\":1}}],[\"methods中方法\",{\"1\":{\"21\":1}}],[\"methods\",{\"0\":{\"46\":1},\"1\":{\"3\":1,\"5\":1,\"13\":1,\"16\":1,\"21\":1,\"22\":1,\"23\":1,\"32\":1,\"36\":1,\"44\":1,\"46\":2,\"47\":1,\"49\":1,\"50\":2,\"51\":1,\"53\":1,\"60\":1,\"66\":2}}],[\"message\",{\"1\":{\"3\":5,\"5\":3,\"7\":2,\"8\":2,\"9\":1,\"14\":1,\"16\":1,\"17\":1,\"21\":1,\"22\":1,\"23\":1,\"43\":1,\"44\":2,\"45\":2,\"66\":4}}],[\"my\",{\"1\":{\"3\":2,\"5\":2,\"6\":2,\"8\":1,\"10\":1,\"11\":2,\"13\":2,\"14\":2,\"16\":2,\"17\":2,\"18\":2,\"19\":2,\"21\":2,\"22\":2,\"23\":2,\"25\":2,\"26\":2,\"27\":1,\"28\":1,\"30\":2,\"31\":2,\"32\":2,\"36\":2,\"43\":1,\"44\":2,\"45\":2,\"46\":4,\"47\":2,\"49\":2,\"50\":2,\"53\":2}}],[\"mustache的基本使用\",{\"1\":{\"3\":1}}],[\"mustache的使用\",{\"1\":{\"3\":1}}],[\"mustache中不仅仅可以是data中的属性\",{\"1\":{\"3\":1}}],[\"mustache\",{\"0\":{\"3\":1},\"1\":{\"3\":1}}],[\"id\",{\"1\":{\"53\":4}}],[\"id=\",{\"1\":{\"3\":1,\"5\":2,\"6\":1,\"8\":1,\"10\":1,\"11\":1,\"13\":2,\"14\":2,\"16\":2,\"17\":2,\"18\":2,\"19\":2,\"21\":2,\"22\":2,\"23\":2,\"25\":1,\"26\":2,\"27\":1,\"28\":1,\"30\":2,\"31\":2,\"32\":2,\"36\":2,\"43\":1,\"44\":1,\"45\":1,\"46\":3,\"47\":1,\"49\":2,\"50\":2,\"53\":2,\"66\":4}}],[\"ie=edge\",{\"1\":{\"53\":1}}],[\"item是我们给每项元素起的一个别名\",{\"1\":{\"30\":1}}],[\"item\",{\"1\":{\"30\":2,\"32\":2,\"36\":3,\"53\":3}}],[\"isactive\",{\"1\":{\"13\":6,\"14\":3}}],[\"isshowha\",{\"1\":{\"26\":4}}],[\"isshow\",{\"1\":{\"3\":5,\"27\":1,\"28\":2}}],[\"immediate\",{\"1\":{\"50\":2,\"51\":1,\"52\":2}}],[\"imgurl\",{\"1\":{\"10\":3,\"11\":4}}],[\"image\",{\"1\":{\"1\":1,\"6\":1,\"22\":1,\"23\":1,\"28\":1,\"34\":1,\"35\":1,\"37\":8}}],[\"initial\",{\"1\":{\"53\":1}}],[\"install\",{\"1\":{\"69\":2}}],[\"instance\",{\"1\":{\"52\":1}}],[\"insertf\",{\"1\":{\"36\":2}}],[\"index+1\",{\"1\":{\"30\":1,\"32\":1}}],[\"index\",{\"1\":{\"30\":7,\"32\":1,\"53\":13}}],[\"inline\",{\"1\":{\"20\":1,\"21\":1}}],[\"info\",{\"1\":{\"19\":3,\"30\":2,\"31\":2,\"50\":8,\"52\":1}}],[\"info对象会被拆解成div的各个属性\",{\"1\":{\"19\":1}}],[\"in\",{\"1\":{\"10\":1,\"30\":8,\"31\":1,\"32\":1,\"33\":1,\"36\":1,\"53\":1}}],[\"increment\",{\"1\":{\"5\":4,\"53\":2,\"66\":4}}],[\"if当条件为false时\",{\"1\":{\"28\":1}}],[\"if的区别\",{\"0\":{\"28\":1}}],[\"if的用法看起来是一致的\",{\"1\":{\"27\":1}}],[\"if的渲染原理\",{\"1\":{\"26\":1}}],[\"if上使用\",{\"1\":{\"26\":1}}],[\"if是一个指令\",{\"1\":{\"26\":1}}],[\"if是惰性的\",{\"1\":{\"26\":1}}],[\"if=\",{\"1\":{\"25\":2,\"26\":1,\"28\":1,\"53\":1}}],[\"if类似\",{\"1\":{\"25\":1}}],[\"if用于根据条件来渲染某一块的内容\",{\"1\":{\"25\":1}}],[\"if\",{\"0\":{\"26\":1},\"1\":{\"3\":1,\"24\":2,\"25\":1,\"28\":1,\"31\":1}}],[\"4\",{\"1\":{\"3\":2,\"51\":1,\"53\":1}}],[\"函数\",{\"1\":{\"3\":1}}],[\"39\",{\"1\":{\"53\":1}}],[\"30px\",{\"1\":{\"16\":2,\"17\":1}}],[\"3\",{\"1\":{\"3\":2,\"10\":2,\"51\":2,\"53\":2}}],[\"2scrlta\",{\"1\":{\"68\":1}}],[\"2008\",{\"1\":{\"53\":1}}],[\"2006\",{\"1\":{\"53\":3}}],[\"20231022182300781\",{\"1\":{\"37\":1}}],[\"20231022182341619\",{\"1\":{\"37\":1}}],[\"20231022182251535\",{\"1\":{\"37\":1}}],[\"20231022182241976\",{\"1\":{\"37\":1}}],[\"20231022182232738\",{\"1\":{\"37\":1}}],[\"20231022182140133\",{\"1\":{\"37\":1}}],[\"20231022182012027\",{\"1\":{\"37\":1}}],[\"20231020164733530\",{\"1\":{\"37\":1}}],[\"20231020163154944\",{\"1\":{\"35\":1}}],[\"20231020162812819\",{\"1\":{\"34\":1}}],[\"20231019222841008\",{\"1\":{\"28\":1}}],[\"20231019005251770\",{\"1\":{\"23\":1}}],[\"20231019004604619\",{\"1\":{\"22\":1}}],[\"20231018083558572\",{\"1\":{\"6\":1}}],[\"20231016233051010\",{\"1\":{\"1\":1}}],[\"2+\",{\"1\":{\"10\":2}}],[\"2\",{\"1\":{\"3\":2,\"10\":1,\"11\":1,\"32\":1,\"36\":1,\"46\":1,\"51\":1,\"53\":2}}],[\"基本使用\",{\"0\":{\"11\":1,\"21\":1,\"25\":1,\"30\":1,\"42\":1},\"1\":{\"3\":1}}],[\"基本指令\",{\"0\":{\"0\":1}}],[\"1<\",{\"1\":{\"66\":2}}],[\"128\",{\"1\":{\"53\":1}}],[\"16px\",{\"1\":{\"53\":1}}],[\"1px\",{\"1\":{\"53\":2}}],[\"18\",{\"1\":{\"19\":2,\"22\":1,\"30\":1,\"31\":1,\"50\":2}}],[\"10335230\",{\"1\":{\"11\":1}}],[\"100\",{\"1\":{\"3\":1,\"5\":1,\"21\":1,\"66\":2}}],[\"10\",{\"1\":{\"3\":1,\"30\":1,\"53\":1}}],[\"1\",{\"1\":{\"3\":2,\"10\":1,\"11\":1,\"19\":2,\"30\":1,\"31\":1,\"43\":1,\"46\":1,\"47\":1,\"51\":3,\"53\":8}}],[\"当\",{\"1\":{\"46\":1,\"50\":1}}],[\"当我们多次使用计算属性时\",{\"1\":{\"46\":1}}],[\"当有多次一样的逻辑时\",{\"1\":{\"43\":1}}],[\"当score小于60的时候\",{\"1\":{\"42\":1}}],[\"当score大于60的时候\",{\"1\":{\"42\":1}}],[\"当条件为true时\",{\"1\":{\"26\":1}}],[\"当条件为false时\",{\"1\":{\"26\":1}}],[\"当一个元素上的事件被触发时\",{\"1\":{\"23\":1}}],[\"当通过methods中定义方法\",{\"1\":{\"22\":1}}],[\"当数据变化时\",{\"1\":{\"48\":1}}],[\"当数据另一个状态时\",{\"1\":{\"12\":1}}],[\"当数据为某个状态时\",{\"1\":{\"12\":1}}],[\"当数据发生变化时\",{\"1\":{\"5\":1}}],[\"当不带参数使用时\",{\"1\":{\"10\":1}}],[\"当用于组件\",{\"1\":{\"10\":1}}],[\"当用于绑定\",{\"1\":{\"10\":1}}],[\"当使用\",{\"1\":{\"10\":1}}],[\"当使用直接在\",{\"1\":{\"9\":1}}],[\"当然\",{\"1\":{\"3\":1}}],[\"当data中的数据发生改变时\",{\"1\":{\"3\":1}}],[\"的innerhtml\",{\"1\":{\"66\":1}}],[\"的过程\",{\"1\":{\"64\":1}}],[\"的时候\",{\"1\":{\"59\":2,\"60\":1}}],[\"的api\",{\"0\":{\"52\":1}}],[\"的答案是哈哈哈哈哈`\",{\"1\":{\"49\":2}}],[\"的改变\",{\"1\":{\"46\":1}}],[\"的options\",{\"0\":{\"39\":1}}],[\"的列表\",{\"1\":{\"36\":1}}],[\"的案例\",{\"0\":{\"36\":1}}],[\"的样子\",{\"1\":{\"34\":1}}],[\"的修饰符\",{\"0\":{\"23\":1}}],[\"的格式来定义\",{\"1\":{\"18\":1}}],[\"的简写\",{\"1\":{\"13\":1}}],[\"的情况\",{\"1\":{\"9\":1}}],[\"的\",{\"1\":{\"6\":1,\"36\":1,\"41\":1,\"47\":1}}],[\"的文本插值\",{\"1\":{\"3\":1}}],[\"的开发模式\",{\"1\":{\"2\":1}}],[\"双大括号\",{\"1\":{\"3\":1}}],[\"双大括号语法\",{\"0\":{\"3\":1}}],[\"使用任意标签\",{\"1\":{\"66\":1}}],[\"使用proxy进行数据劫持\",{\"1\":{\"59\":1}}],[\"使用全局的方法\",{\"1\":{\"53\":1}}],[\"使用计算属性\",{\"1\":{\"53\":1}}],[\"使用计算属性computed\",{\"1\":{\"42\":1}}],[\"使用computed\",{\"1\":{\"46\":1}}],[\"使用methods\",{\"1\":{\"46\":1}}],[\"使用method对逻辑进行抽取\",{\"0\":{\"44\":1},\"1\":{\"42\":1}}],[\"使用\",{\"1\":{\"23\":1,\"52\":1,\"59\":1,\"66\":1}}],[\"使用v\",{\"1\":{\"20\":1}}],[\"使用最多的语法是\",{\"1\":{\"3\":1}}],[\"使用基于html的模板语法\",{\"1\":{\"2\":1}}],[\"中更改如下\",{\"1\":{\"50\":1}}],[\"中间还有很多未知的或者乱序的节点\",{\"1\":{\"37\":1}}],[\"中的\",{\"0\":{\"33\":1}}],[\"中书写的模板时\",{\"1\":{\"9\":1}}],[\"中\",{\"1\":{\"3\":1,\"23\":1,\"52\":1,\"58\":1}}],[\"语法糖\",{\"1\":{\"21\":1}}],[\"语法\",{\"0\":{\"3\":1},\"1\":{\"3\":1}}],[\"cdn\",{\"0\":{\"62\":1}}],[\"charset=\",{\"1\":{\"53\":1}}],[\"changed\",{\"1\":{\"51\":3}}],[\"changeinfonbaname\",{\"1\":{\"50\":2}}],[\"changeinfoname\",{\"1\":{\"50\":2}}],[\"changeinfo\",{\"1\":{\"50\":2}}],[\"changefullname\",{\"1\":{\"47\":2}}],[\"changefirstname\",{\"1\":{\"46\":2}}],[\"c和f因为key不一致\",{\"1\":{\"37\":1}}],[\"c和d来说它们事实上并不需要有任何的改动\",{\"1\":{\"37\":1}}],[\"c\",{\"1\":{\"36\":2,\"51\":4}}],[\"cn\",{\"1\":{\"33\":1,\"41\":1,\"51\":1,\"52\":1}}],[\"capture\",{\"1\":{\"20\":2,\"23\":2}}],[\"case\",{\"1\":{\"15\":2}}],[\"camelcase\",{\"1\":{\"15\":1}}],[\"camel\",{\"1\":{\"10\":1}}],[\"cba=\",{\"1\":{\"18\":1}}],[\"cba\",{\"1\":{\"13\":3,\"14\":2,\"18\":1}}],[\"csspropertyvalue\",{\"1\":{\"16\":1}}],[\"csspropertyname\",{\"1\":{\"16\":1}}],[\"css\",{\"1\":{\"9\":1,\"15\":2,\"53\":2}}],[\"cli创建项目\",{\"1\":{\"61\":1}}],[\"click调用时\",{\"1\":{\"22\":1}}],[\"click=\",{\"1\":{\"3\":1,\"5\":3,\"13\":1,\"21\":3,\"22\":2,\"23\":2,\"26\":1,\"32\":1,\"36\":1,\"46\":1,\"47\":1,\"49\":1,\"50\":3,\"53\":3,\"66\":4}}],[\"click\",{\"1\":{\"2\":1,\"21\":2,\"23\":3,\"66\":1}}],[\"class><\",{\"1\":{\"18\":1}}],[\"classobj\",{\"1\":{\"13\":5}}],[\"classname\",{\"1\":{\"13\":2}}],[\"class=\",{\"1\":{\"13\":9,\"14\":4,\"21\":3,\"31\":1,\"53\":1}}],[\"class也是动态的\",{\"1\":{\"12\":1}}],[\"class\",{\"0\":{\"12\":1},\"1\":{\"10\":1,\"13\":3,\"14\":2,\"18\":1}}],[\"cloak>\",{\"1\":{\"9\":1}}],[\"cloak\",{\"0\":{\"9\":1},\"1\":{\"9\":3}}],[\"count++\",{\"1\":{\"53\":1}}],[\"count\",{\"1\":{\"53\":8}}],[\"counter的值时\",{\"1\":{\"67\":1}}],[\"counter++\",{\"1\":{\"5\":1,\"21\":1,\"66\":2}}],[\"counter\",{\"1\":{\"3\":2,\"5\":5,\"21\":2,\"53\":2,\"66\":6,\"67\":3}}],[\"collapse\",{\"1\":{\"53\":2}}],[\"color\",{\"1\":{\"6\":1,\"13\":1,\"16\":3,\"17\":1,\"53\":2}}],[\"coder\",{\"1\":{\"46\":1,\"47\":1}}],[\"coderwhy\",{\"1\":{\"22\":1}}],[\"core\",{\"1\":{\"41\":1}}],[\"controller的简称\",{\"1\":{\"65\":1}}],[\"content=\",{\"1\":{\"53\":2}}],[\"concat\",{\"1\":{\"32\":1}}],[\"console\",{\"1\":{\"21\":2,\"22\":2,\"23\":3,\"46\":5,\"47\":1,\"49\":2,\"50\":2,\"51\":7,\"52\":1,\"68\":1}}],[\"const\",{\"1\":{\"3\":1,\"5\":1,\"6\":1,\"11\":1,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"21\":1,\"22\":1,\"23\":1,\"25\":1,\"26\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1,\"44\":1,\"45\":1,\"46\":2,\"47\":2,\"49\":1,\"50\":1,\"52\":1,\"53\":1,\"68\":3}}],[\"composition\",{\"1\":{\"60\":2}}],[\"component\",{\"1\":{\"52\":1}}],[\"compatible\",{\"1\":{\"53\":1}}],[\"computed的fullname中的计算\",{\"1\":{\"46\":1}}],[\"computed\",{\"0\":{\"40\":1,\"45\":1},\"1\":{\"13\":1,\"41\":1,\"42\":1,\"45\":1,\"46\":2,\"47\":1,\"48\":1,\"50\":1,\"53\":1,\"60\":1}}],[\"com\",{\"1\":{\"11\":2,\"62\":1,\"68\":1}}],[\"created\",{\"1\":{\"50\":1,\"51\":1,\"52\":1}}],[\"createapp的时候\",{\"1\":{\"66\":1}}],[\"createapp\",{\"1\":{\"3\":1,\"5\":1,\"6\":1,\"11\":1,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"21\":1,\"22\":1,\"23\":1,\"25\":1,\"26\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1,\"44\":1,\"45\":1,\"46\":2,\"47\":1,\"49\":1,\"50\":1,\"53\":1,\"66\":2}}],[\"create\",{\"1\":{\"2\":1}}],[\"<=\",{\"1\":{\"53\":1}}],[\"<td>\",{\"1\":{\"53\":6}}],[\"<tr\",{\"1\":{\"53\":1}}],[\"<tbody>\",{\"1\":{\"53\":1}}],[\"<th>操作<\",{\"1\":{\"53\":1}}],[\"<th>购买数量<\",{\"1\":{\"53\":1}}],[\"<th>价格<\",{\"1\":{\"53\":1}}],[\"<th>出版日期<\",{\"1\":{\"53\":1}}],[\"<th>书籍名称<\",{\"1\":{\"53\":1}}],[\"<th>序号<\",{\"1\":{\"53\":1}}],[\"<thead>\",{\"1\":{\"53\":1}}],[\"<table>\",{\"1\":{\"53\":1}}],[\"<title>document<\",{\"1\":{\"53\":1}}],[\"<template\",{\"1\":{\"3\":1,\"5\":1,\"6\":1,\"8\":1,\"10\":1,\"11\":1,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"21\":1,\"22\":1,\"23\":1,\"25\":1,\"26\":3,\"27\":1,\"28\":1,\"30\":1,\"31\":2,\"32\":1,\"36\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":2,\"47\":1,\"49\":1,\"50\":1,\"53\":3,\"66\":1}}],[\"<template>\",{\"1\":{\"2\":1}}],[\"<meta\",{\"1\":{\"53\":3}}],[\"<head>\",{\"1\":{\"53\":1}}],[\"<html\",{\"1\":{\"53\":1}}],[\"<h2\",{\"1\":{\"5\":1,\"7\":1,\"8\":1,\"25\":3,\"27\":1,\"28\":2}}],[\"<h2>购物车为空~<\",{\"1\":{\"53\":1}}],[\"<h2>总价格\",{\"1\":{\"53\":1}}],[\"<h2>遍历数字<\",{\"1\":{\"30\":1}}],[\"<h2>个人信息<\",{\"1\":{\"30\":1}}],[\"<h2>电影列表<\",{\"1\":{\"30\":1,\"32\":1}}],[\"<h2>呵呵呵呵<\",{\"1\":{\"26\":3}}],[\"<h2>哈哈哈哈<\",{\"1\":{\"26\":3}}],[\"<h2>\",{\"1\":{\"3\":7,\"5\":5,\"7\":1,\"43\":3,\"44\":3,\"45\":3,\"46\":20,\"47\":1,\"50\":1,\"66\":4}}],[\"<p>答案是\",{\"1\":{\"49\":1}}],[\"<p>您的问题是\",{\"1\":{\"49\":1}}],[\"<link\",{\"1\":{\"53\":1}}],[\"<li>\",{\"1\":{\"31\":2}}],[\"<li\",{\"1\":{\"30\":3,\"31\":1,\"32\":1,\"36\":1}}],[\"<ul>\",{\"1\":{\"30\":3,\"31\":1,\"32\":1,\"36\":1}}],[\"<input\",{\"1\":{\"23\":1,\"25\":1,\"32\":1,\"46\":1,\"49\":1}}],[\"<img\",{\"1\":{\"10\":3,\"11\":3,\"18\":1}}],[\"<body>\",{\"1\":{\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"21\":1,\"22\":1,\"23\":1,\"26\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1,\"46\":1,\"49\":1,\"50\":1,\"53\":1,\"66\":2}}],[\"<button\",{\"1\":{\"3\":1,\"5\":3,\"13\":1,\"21\":3,\"22\":2,\"23\":2,\"26\":1,\"32\":1,\"36\":1,\"46\":1,\"47\":1,\"49\":1,\"50\":3,\"53\":3,\"66\":4}}],[\"<a\",{\"1\":{\"10\":1,\"11\":1,\"18\":1}}],[\"<style>\",{\"1\":{\"13\":1}}],[\"<span\",{\"1\":{\"6\":1,\"53\":1}}],[\"<script>\",{\"1\":{\"3\":1,\"5\":1,\"6\":1,\"11\":1,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"21\":1,\"22\":1,\"23\":1,\"25\":1,\"26\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1,\"44\":1,\"45\":1,\"46\":2,\"47\":1,\"49\":1,\"50\":1,\"53\":1,\"66\":2}}],[\"<script\",{\"1\":{\"3\":1,\"5\":1,\"6\":1,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"21\":1,\"22\":1,\"23\":1,\"25\":1,\"26\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1,\"44\":1,\"45\":1,\"46\":2,\"47\":1,\"49\":1,\"50\":1,\"53\":2,\"62\":1,\"63\":1,\"66\":3}}],[\"<\",{\"1\":{\"2\":2,\"3\":15,\"5\":10,\"6\":3,\"7\":2,\"8\":3,\"9\":1,\"10\":5,\"11\":5,\"13\":10,\"14\":5,\"16\":6,\"17\":3,\"18\":4,\"19\":4,\"21\":8,\"22\":5,\"23\":4,\"25\":2,\"26\":5,\"27\":1,\"28\":1,\"30\":11,\"31\":7,\"32\":5,\"36\":5,\"43\":5,\"44\":5,\"45\":5,\"46\":27,\"47\":3,\"49\":5,\"50\":5,\"53\":21,\"66\":12}}],[\"<div>\",{\"1\":{\"6\":1,\"9\":1,\"66\":2}}],[\"<div><\",{\"1\":{\"2\":1}}],[\"<div\",{\"1\":{\"2\":1,\"5\":3,\"6\":1,\"9\":1,\"13\":7,\"14\":4,\"16\":6,\"17\":2,\"18\":4,\"19\":4,\"21\":4,\"22\":1,\"23\":2,\"26\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1,\"46\":1,\"49\":1,\"50\":1,\"53\":1,\"66\":2}}],[\"口在底层的实现中\",{\"1\":{\"2\":1}}],[\"起\",{\"1\":{\"2\":1}}],[\"date\",{\"1\":{\"53\":5}}],[\"data中返回的对象会被vue的响应式系统劫持\",{\"1\":{\"67\":1}}],[\"data属性是传入一个函数\",{\"1\":{\"67\":1}}],[\"data属性\",{\"0\":{\"67\":1}}],[\"data\",{\"1\":{\"3\":1,\"5\":1,\"6\":1,\"11\":1,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"21\":1,\"22\":1,\"23\":1,\"25\":1,\"26\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1,\"44\":1,\"45\":1,\"46\":2,\"47\":1,\"48\":1,\"49\":1,\"50\":2,\"51\":1,\"53\":1,\"66\":2}}],[\"data返回的对象是有添加到vue的响应式系统中\",{\"1\":{\"3\":1}}],[\"debugger\",{\"1\":{\"69\":1}}],[\"dev\",{\"1\":{\"69\":1}}],[\"developer\",{\"1\":{\"20\":1}}],[\"defineproperty\",{\"1\":{\"59\":1}}],[\"default\",{\"1\":{\"51\":1}}],[\"decrement\",{\"1\":{\"53\":2,\"66\":4}}],[\"deep\",{\"1\":{\"50\":1,\"51\":1,\"52\":1}}],[\"d\",{\"1\":{\"36\":1,\"51\":2}}],[\"d它们都是没有变化的\",{\"1\":{\"36\":1}}],[\"doctype\",{\"1\":{\"53\":1}}],[\"docs\",{\"1\":{\"20\":1}}],[\"do\",{\"1\":{\"51\":1,\"64\":2}}],[\"dom\",{\"0\":{\"35\":1},\"1\":{\"2\":1,\"9\":2,\"10\":4,\"35\":2,\"37\":2}}],[\"dist文件夹下有两个文件\",{\"1\":{\"69\":1}}],[\"disabled=\",{\"1\":{\"53\":1}}],[\"display\",{\"1\":{\"9\":2}}],[\"diff\",{\"1\":{\"37\":2}}],[\"diff算法优化\",{\"1\":{\"59\":1}}],[\"diff算法\",{\"1\":{\"37\":2}}],[\"divider\",{\"1\":{\"31\":1}}],[\"divclick\",{\"1\":{\"23\":3}}],[\"div>\",{\"1\":{\"2\":2,\"5\":3,\"6\":2,\"9\":1,\"13\":7,\"14\":4,\"16\":6,\"17\":2,\"18\":4,\"19\":4,\"21\":4,\"22\":1,\"23\":2,\"26\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1,\"46\":1,\"49\":1,\"50\":1,\"53\":1,\"66\":4}}],[\"允许开发者以声明式的方式将\",{\"1\":{\"2\":1}}],[\"了解\",{\"1\":{\"2\":1}}],[\"typescript\",{\"1\":{\"58\":2}}],[\"type=\",{\"1\":{\"23\":1,\"25\":1,\"32\":1,\"46\":1,\"49\":1,\"66\":1}}],[\"to\",{\"1\":{\"64\":2}}],[\"totalprice\",{\"1\":{\"53\":2}}],[\"toggle\",{\"1\":{\"3\":2,\"13\":2}}],[\"tbody>\",{\"1\":{\"53\":1}}],[\"td>\",{\"1\":{\"53\":6}}],[\"td\",{\"1\":{\"53\":1}}],[\"thead>\",{\"1\":{\"53\":1}}],[\"th>\",{\"1\":{\"53\":6}}],[\"th\",{\"1\":{\"53\":2}}],[\"this到底指向什么\",{\"1\":{\"68\":1}}],[\"this到底是如何查找和绑定的呢\",{\"1\":{\"68\":1}}],[\"this\",{\"1\":{\"3\":3,\"5\":1,\"13\":5,\"32\":5,\"36\":1,\"41\":1,\"44\":4,\"45\":4,\"46\":7,\"47\":7,\"49\":4,\"50\":3,\"51\":1,\"52\":2,\"53\":5,\"66\":4,\"68\":2}}],[\"target\",{\"1\":{\"23\":1}}],[\"table>\",{\"1\":{\"53\":1}}],[\"table\",{\"1\":{\"53\":1}}],[\"tab\",{\"1\":{\"1\":1}}],[\"title>\",{\"1\":{\"53\":1}}],[\"title\",{\"1\":{\"13\":4,\"14\":4}}],[\"textdecoration\",{\"1\":{\"17\":1}}],[\"text=\",{\"1\":{\"7\":1}}],[\"textcontent\",{\"1\":{\"7\":1}}],[\"text\",{\"0\":{\"7\":1},\"1\":{\"23\":1,\"25\":1,\"32\":1,\"46\":1,\"49\":1,\"53\":1}}],[\"template模板中\",{\"1\":{\"68\":1}}],[\"template模板中只能有一个根元素\",{\"1\":{\"10\":1}}],[\"template中的\",{\"1\":{\"67\":1}}],[\"template中通过\",{\"1\":{\"67\":1}}],[\"template标签\",{\"1\":{\"66\":1}}],[\"template属性\",{\"0\":{\"66\":1},\"1\":{\"66\":1}}],[\"template会自动进行更新来显示最新的数据\",{\"1\":{\"48\":1}}],[\"template元素是一种用于保存客户端内容的机制\",{\"1\":{\"66\":1}}],[\"template元素使用\",{\"0\":{\"31\":1}}],[\"template元素可以当做不可见的包裹元素\",{\"1\":{\"26\":1}}],[\"template元素\",{\"1\":{\"26\":1}}],[\"template\",{\"0\":{\"26\":1},\"1\":{\"3\":2,\"5\":1,\"6\":1,\"11\":1,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"21\":1,\"22\":1,\"23\":1,\"25\":1,\"26\":1,\"30\":1,\"31\":2,\"32\":1,\"36\":1,\"44\":1,\"45\":1,\"46\":2,\"47\":1,\"49\":1,\"50\":1,\"53\":1,\"66\":4}}],[\"template>\",{\"1\":{\"2\":1,\"3\":1,\"5\":1,\"6\":1,\"8\":1,\"10\":1,\"11\":1,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"21\":1,\"22\":1,\"23\":1,\"25\":1,\"26\":3,\"27\":1,\"28\":1,\"30\":1,\"31\":2,\"32\":1,\"36\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":2,\"47\":1,\"49\":1,\"50\":1,\"53\":3,\"66\":1}}],[\"tr>\",{\"1\":{\"53\":1}}],[\"tree\",{\"1\":{\"35\":1,\"59\":1}}],[\"true\",{\"1\":{\"3\":1,\"13\":5,\"14\":1,\"20\":1,\"23\":1,\"26\":1,\"50\":3,\"51\":2,\"52\":2}}],[\"triggered\",{\"1\":{\"51\":3}}],[\"trigger\",{\"1\":{\"1\":1}}],[\"在浏览器中打开调试面板\",{\"1\":{\"69\":1}}],[\"在demo中打下断点\",{\"1\":{\"69\":1}}],[\"在package\",{\"1\":{\"69\":1}}],[\"在项目中配置yarn\",{\"1\":{\"69\":1}}],[\"在该方法中\",{\"1\":{\"68\":1}}],[\"在该网站中生成代码片段\",{\"1\":{\"1\":1}}],[\"在页面中通过cdn的方式来引入\",{\"1\":{\"61\":1}}],[\"在方法中被赋值改变时\",{\"1\":{\"50\":1}}],[\"在使用\",{\"1\":{\"66\":1}}],[\"在使用时\",{\"1\":{\"46\":1}}],[\"在使用v\",{\"1\":{\"33\":1}}],[\"在数据不发生变化时\",{\"1\":{\"46\":1}}],[\"在上面的实现思路中\",{\"1\":{\"46\":1}}],[\"在模板语法中直接使用表达式\",{\"0\":{\"43\":1},\"1\":{\"42\":1}}],[\"在模板中放入太多的逻辑会让模板过重和难以维护\",{\"1\":{\"41\":1}}],[\"在模板中使用表达式\",{\"1\":{\"41\":1}}],[\"在模板中可以直接通过插值语法显示一些data中的数据\",{\"1\":{\"41\":1}}],[\"在模板中\",{\"1\":{\"2\":1}}],[\"在界面上显示不及格\",{\"1\":{\"42\":1}}],[\"在界面上显示及格\",{\"1\":{\"42\":1}}],[\"在进行插入或者重置顺序的时候\",{\"1\":{\"38\":1}}],[\"在没有key的时候我们的效率是非常低效的\",{\"1\":{\"38\":1}}],[\"在操作真实dom的时候\",{\"1\":{\"36\":1}}],[\"在新旧nodes对比时辨识vnodes\",{\"1\":{\"33\":1}}],[\"在遍历一个数组的时候会经常需要拿到数组的索引\",{\"1\":{\"30\":1}}],[\"在真实开发中\",{\"1\":{\"29\":1}}],[\"在用法上的区别\",{\"1\":{\"28\":1}}],[\"在给元素绑定事件时\",{\"1\":{\"23\":1}}],[\"在\",{\"1\":{\"23\":1,\"59\":1,\"60\":1}}],[\"在vue\",{\"1\":{\"69\":2}}],[\"在vue3x的时候\",{\"1\":{\"67\":1}}],[\"在vue3\",{\"1\":{\"58\":1,\"60\":1}}],[\"在vue2x的时候\",{\"1\":{\"67\":1}}],[\"在vue2\",{\"1\":{\"58\":1,\"60\":1}}],[\"在vue中\",{\"1\":{\"36\":1}}],[\"在vue中如何监听事件呢\",{\"1\":{\"20\":1}}],[\"在vscode中配置代码片段\",{\"1\":{\"1\":1}}],[\"在前端开发中\",{\"1\":{\"20\":1}}],[\"在前端开发中另外一个非常重要的特性就是交互\",{\"1\":{\"20\":1}}],[\"在某些情况下\",{\"1\":{\"18\":1,\"24\":1}}],[\"在开发中\",{\"1\":{\"12\":1}}],[\"在处理绑定时\",{\"1\":{\"10\":1}}],[\"第三个参数是额外的其他选项\",{\"1\":{\"52\":1}}],[\"第三步是如果旧节点遍历完毕\",{\"1\":{\"37\":1}}],[\"第三步\",{\"1\":{\"1\":1}}],[\"第二个参数是侦听的回调函数callback\",{\"1\":{\"52\":1}}],[\"第二步的操作是从尾部开始进行遍历\",{\"1\":{\"37\":1}}],[\"第二步\",{\"1\":{\"1\":1}}],[\"第一个参数是要侦听的源\",{\"1\":{\"52\":1}}],[\"第一步的操作是从头开始进行遍历\",{\"1\":{\"37\":1}}],[\"第一步\",{\"1\":{\"1\":1}}],[\"第五步是最特色的情况\",{\"1\":{\"37\":1}}],[\"第四步是如果新的节点遍历完毕\",{\"1\":{\"37\":1}}],[\"我们在methods中要使用data返回对象中的数据\",{\"1\":{\"68\":1}}],[\"我们在前面练习vue的过程中\",{\"1\":{\"1\":1}}],[\"我们传入了一个对象\",{\"1\":{\"66\":1}}],[\"我们也经常称vue是一个mvvm的框架\",{\"1\":{\"65\":1}}],[\"我们通常通过mixins在多个组件之间共享逻辑\",{\"1\":{\"60\":1}}],[\"我们通常会给元素或者组件绑定一个key属性\",{\"1\":{\"33\":1}}],[\"我们会通过\",{\"1\":{\"60\":1}}],[\"我们会发现是完全不同的\",{\"1\":{\"64\":1}}],[\"我们会发现methods在多次使用时\",{\"1\":{\"46\":1}}],[\"我们会发现计算属性和methods的实现看起来是差别是不大的\",{\"1\":{\"46\":1}}],[\"我们会发现无论是直观上\",{\"1\":{\"45\":1}}],[\"我们会发现上面的diff算法效率并不高\",{\"1\":{\"37\":1}}],[\"我们希望在代码逻辑中监听某个数据的变化\",{\"1\":{\"48\":1}}],[\"我们事实上先显示的是一个结果\",{\"1\":{\"44\":1}}],[\"我们有一个变量message\",{\"1\":{\"42\":1}}],[\"我们有一个分数\",{\"1\":{\"42\":1}}],[\"我们有两个变量\",{\"1\":{\"42\":1}}],[\"我们有没有什么方法可以将逻辑抽离出去呢\",{\"1\":{\"41\":1}}],[\"我们来看三个案例\",{\"1\":{\"42\":1}}],[\"我们可能需要对数据进行一些转化后再显示\",{\"1\":{\"41\":1}}],[\"我们可以通过hook函数\",{\"1\":{\"60\":1}}],[\"我们可以在created的生命周期\",{\"1\":{\"52\":1}}],[\"我们可以有三种实现思路\",{\"1\":{\"42\":1}}],[\"我们可以确定的是\",{\"1\":{\"36\":1}}],[\"我们可以选择使用template\",{\"1\":{\"26\":1}}],[\"我们可以直接使用\",{\"1\":{\"19\":1}}],[\"我们可以使用this关键字来直接访问到data中返回的对象的属性\",{\"1\":{\"68\":1}}],[\"我们可以使用\",{\"1\":{\"18\":1}}],[\"我们可以利用\",{\"1\":{\"15\":1}}],[\"我们可以把一个数组传给\",{\"1\":{\"14\":1}}],[\"我们可以传给\",{\"1\":{\"13\":1}}],[\"我们只需要在中间插入一个\",{\"1\":{\"36\":1}}],[\"我们先来看一个案例\",{\"1\":{\"36\":1}}],[\"我们先来看一下官方的解释\",{\"1\":{\"33\":1}}],[\"我们先来解释一下vnode的概念\",{\"1\":{\"34\":1}}],[\"我们使用template来对多个元素进行包裹\",{\"1\":{\"31\":1}}],[\"我们知道\",{\"1\":{\"30\":1,\"41\":1}}],[\"我们往往会从服务器拿到一组数据\",{\"1\":{\"29\":1}}],[\"我们需要根据当前的条件决定某些元素或组件是否渲染\",{\"1\":{\"24\":1}}],[\"我们需要经常和用户进行各种各样的交互\",{\"1\":{\"20\":1}}],[\"我们就必须监听用户发生的事件\",{\"1\":{\"20\":1}}],[\"我们称之为\",{\"1\":{\"18\":1}}],[\"我们属性的名称可能也不是固定的\",{\"1\":{\"18\":1}}],[\"我们再vscode中我们可以生成一个代码片段\",{\"1\":{\"1\":1}}],[\"viewmode的简称\",{\"1\":{\"65\":1}}],[\"view\",{\"1\":{\"57\":1,\"65\":2}}],[\"viewport\",{\"1\":{\"53\":1}}],[\"vjuː\",{\"1\":{\"57\":1}}],[\"vs\",{\"0\":{\"46\":1}}],[\"vscode中的代码片段有固定的格式\",{\"1\":{\"1\":1}}],[\"vscode\",{\"0\":{\"1\":1}}],[\"vnode的本质是一个javascript的对象\",{\"1\":{\"34\":1}}],[\"vnode的全称是virtual\",{\"1\":{\"34\":1}}],[\"vnode\",{\"0\":{\"34\":1},\"1\":{\"35\":1}}],[\"val\",{\"1\":{\"51\":7}}],[\"value\",{\"1\":{\"18\":2,\"23\":1,\"30\":5,\"31\":2}}],[\"var\",{\"1\":{\"3\":2}}],[\"v=4\",{\"1\":{\"11\":1}}],[\"v\",{\"0\":{\"5\":1,\"6\":1,\"7\":1,\"8\":1,\"9\":1,\"10\":1,\"20\":1,\"23\":1,\"26\":1,\"27\":1,\"28\":1,\"33\":1,\"54\":1},\"1\":{\"2\":2,\"5\":4,\"6\":2,\"7\":1,\"8\":2,\"9\":4,\"10\":5,\"11\":4,\"13\":1,\"15\":1,\"19\":2,\"20\":2,\"21\":4,\"23\":1,\"24\":4,\"25\":7,\"26\":4,\"27\":2,\"28\":6,\"29\":1,\"30\":7,\"31\":1,\"32\":2,\"36\":1,\"46\":1,\"49\":1,\"53\":3,\"54\":1,\"66\":1}}],[\"vue提供了两种方式\",{\"1\":{\"66\":1}}],[\"vue提供了下面的指令来进行条件判断\",{\"1\":{\"24\":1}}],[\"vue虽然并没有完全遵守mvvm的模型\",{\"1\":{\"65\":1}}],[\"vue官方其实有说明\",{\"1\":{\"65\":1}}],[\"vue的源码全部使用\",{\"1\":{\"58\":1}}],[\"vue使用\",{\"1\":{\"58\":1}}],[\"vue在进行diff算法的时候\",{\"1\":{\"38\":1}}],[\"vue源码对于key的判断\",{\"0\":{\"37\":1}}],[\"vue事实上会对于有key和没有key会调用两个不同的方法\",{\"1\":{\"36\":1}}],[\"vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改\",{\"1\":{\"33\":1}}],[\"vuejs\",{\"1\":{\"33\":1,\"41\":1,\"51\":1,\"52\":1}}],[\"vue2\",{\"1\":{\"10\":1,\"59\":3,\"60\":1}}],[\"vue\",{\"0\":{\"39\":1,\"56\":1,\"57\":1,\"61\":1,\"72\":1},\"1\":{\"3\":2,\"5\":2,\"6\":2,\"10\":2,\"11\":1,\"13\":2,\"14\":2,\"16\":2,\"17\":2,\"18\":2,\"19\":2,\"21\":2,\"22\":2,\"23\":3,\"25\":2,\"26\":2,\"30\":2,\"31\":2,\"32\":3,\"36\":2,\"44\":2,\"45\":2,\"46\":4,\"47\":2,\"49\":2,\"50\":3,\"53\":2,\"57\":1,\"58\":1,\"59\":1,\"62\":1,\"63\":1,\"66\":4,\"69\":1}}],[\"vue将模板编译成虚拟dom渲染函数\",{\"1\":{\"2\":1}}],[\"vue也支持\",{\"1\":{\"2\":1}}],[\"vue3带来的变化\",{\"0\":{\"58\":1}}],[\"vue3不支持过滤器了\",{\"1\":{\"53\":1}}],[\"vue3\",{\"0\":{\"0\":1},\"1\":{\"10\":2,\"59\":1,\"68\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
